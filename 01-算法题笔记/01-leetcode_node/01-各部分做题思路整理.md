# 数组
## 移除有序数组中的重复元素（每个元素最多包含有n个重复元素）——leetcode26、80题
### 解法1：双指针 + count计数
该方法通用性不够好，如果count > 2就稍微有点复杂。
### 解法2【推荐】：找到num\[i] != num\[i - count]即可说明重复元素小于等于count
通用性更好，count(count > 0)为何值都可以。
```CPP
int removeDuplicates(vector<int>& nums,int count) {
    int i = 0;
    for (int num : nums) {
        if (i < count || num > nums[i - count]) {
            nums[i++] = num;
        }
    }
    return i;
}
```
## 使用二分法进行数组元素查找


### 使用二分法的窍门（碰到下面的情况，用二分法准没错）
- 给出的数组有序，让查找某个值
- 部分数组有序，要求查找某个值/查找符合要求的某个元素
- 题目要求用logn时间复杂度求解
- 题目要求高效查找（二分法查找速度毫无疑问是最快的）
### 一维数组二分查找
下面两题均是在有序数组上查找某个元素/查找某个临界点，最简单的一类二分法的题目。  

符合二分法小结的第一、二种情况——[分治思想：二分法总结](https://github.com/KyelYang/c-plus-Interview-data/blob/master/01-%E7%AE%97%E6%B3%95%E9%A2%98%E7%AC%94%E8%AE%B0/01-leetcode_node/02-%E4%BA%8C%E5%88%86%E6%B3%95.md)  
#### leetcode 35. 搜索插入位置
略。
#### leetcode 278. 第一个错误的版本
略。

**只要数组的某一部分有序，也能用二分法，下题就是一个典型例子**  

#### leetcode33 81. 搜索旋转排序数组（有序数组在某个节点上发生了旋转，有序数组可能包含重复元素）
符合二分法小结的第五种情况——[分治思想：二分法总结](https://github.com/KyelYang/c-plus-Interview-data/blob/master/01-%E7%AE%97%E6%B3%95%E9%A2%98%E7%AC%94%E8%AE%B0/01-leetcode_node/02-%E4%BA%8C%E5%88%86%E6%B3%95.md)  

#### 解法：不包含重复元素的情况
```
0　　1　　2　　[4]　　5　　6　　7
7　　0　　1　　[2]　　4　　5　　6
6　　7　　0　  [1]　　2　　4　　5
5　　6　　7　　[0]　　1　　2　　4
4　　5　　6　　[7]　　0　　1　　2
2　　4　　5　　[6]　　7　　0　　1
1　　2　　4　　[5]　　6　　7　　0
```
没有思路就把所有可能的情况列出来，找规律！！  

从上面可以得出规律，如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了。  
```CPP
int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[mid] < nums[right]) {
                if (nums[mid] < target && nums[right] >= target) left = mid + 1;
                else right = mid - 1;
            } else {
                if (nums[left] <= target && nums[mid] > target) right = mid - 1;
                else left = mid + 1;
            }
        }
        return -1;
    }
```

#### 解法拓展：包含重复元素的情况
如果可以有重复值，就会出现来面两种情况：
```
1 3 1 1  
1 1 3 1   //这两种情况中间值等于最右值，目标值3既可以在左边又可以在右边  
```
对于这种情况其实处理非常简单，只要把最右值向左一位即可继续循环，如果还相同则继续移，直到移到不同值为止。其他地方和上面相同。  

### 二维数组二分查找
- 如果二维数组能够展开成一个一维有序数组，那么用一次二分法就能解决查找问题。74题是一个典型例子 
- 如果二维数组不能展开成一个一维有序数组，那么就得用多次二分法才能解决查找问题。240是一个典型例子 

#### leetcode 74. 搜索二维矩阵
一次二分法解决查找问题。  
```CPP
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if(matrix.empty() || matrix[0].empty()) return false;
    int m = matrix.size(),n = matrix[0].size();

    long left = 0,right = m * n;    //定义边界
    while(left < right){
        long mid = left + (right - left) /2;    //二分中点，定义为long类型是为了防止越界
        int i = mid / n,j = mid % n;    //根据中点找到对应的二维数组下标i,j
        if(matrix[i][j] == target) return true;
        else if(matrix[i][j] < target) left = mid + 1;
        else right = mid;
    }
    return false;
```
#### leetcode 240. 搜索二维矩阵 II
此题二维数组不能展开成一个一维有序数组，是因为没有上题的这个条件：i行的末尾元素小于i + 1行的首元素。  

因此，需要多次二分法才能解决查找问题。  

这题除了二分还有一个更trick的方法，即从左下/右上节点（临界点）开始进行判断，每次删除一行/一列
```CPP
bool searchMatrix(vector<vector<int> > &matrix, int target) {
    if (matrix.empty() || matrix[0].empty()) return false;
    if (target < matrix[0][0] || target > matrix.back().back()) return false;
    
    int x = matrix.size() - 1, y = 0;
    while (true) {
        if (matrix[x][y] > target) --x; //删除一列
        else if (matrix[x][y] < target) ++y;    //删除一行
        else return true;
        if (x < 0 || y >= matrix[0].size()) break;  //删除到边界了，还没有找到target，因此直接退出查找
    }
    return false;
}
```

#### 【特别好的题目】leetcode 378. 有序矩阵中第K小的元素
**解法1：由于二维数组的每一行是有序的，可以用数组来模拟堆**  
```CPP
int kthSmallest(vector<vector<int>>& matrix, int k) {
    int n = matrix.size();
    vector<int> vec(n,0);
    //iota(vec.begin(),vec.end(),0);

    int min_val,pos;


    for(int i = 0;i < k;i++){
        min_val = INT_MAX;
        for(int j = 0;j < n;j++){
            if(vec[j] < n && matrix[j][vec[j]] < min_val){
                min_val = matrix[j][vec[j]];
                pos = j;
            }
        }
        vec[pos] += 1;
    }

    return min_val;
}
```
**解法2：对于有序数组查找某个值，很明显最优解是二分**  
本题亮点思路如下：  
- mid不仅可以作为下标，还可以作为值去进行比较，此时left，mid，right均为值
- 如果题目没有中间比较对象，那么可以尝试创造比较对象去进行比较，比如由于二维有序数组左上角值最小，右下角值最大，可以求得中间值mid作为taget
- 本题是多维有序数组，求第k小(count数)，更好的思路是直接对count进行二分！！【记住，求什么就对什么进行二分查找！！】
```CPP
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int left = matrix[0][0],right = matrix.back().back();
        while(left < right){
            int mid = left + (right - left) / 2;    //计算mid作为中间比较值
            int count = search_count(matrix,mid);   //找出mid在二维数组中是第几小，即count值
            if(count < k) left = mid + 1;   //对count进行二分
            else right = mid;
        }
        return left;    //返回该k位置上的值
    }

private:
    int search_count(vector<vector<int>>& matrix, int mid){
        int n = matrix.size();
        int i = n - 1,j = 0,count = 0;
        while(0 <= i && j < n){
            if(matrix[i][j] <= mid){
                count += i + 1;
                j++;
            }else i--;
        }
        return count;
    }
```

## 二分查找的拓展—分治算法

### 一维解空间（有序）查找满足条件的target

#### leetcode 69. x 的平方根

二分法小结的第三种情况，找到小于根号x的最大整数。  
```CPP
int mySqrt(int x) {
    if(x < 2) return x;
    int left = 2,right = x;
    while(left < right){
        int mid = left + (right - left) /2;
        int tmp = x / mid;  //做除法而不是乘法是因为乘法会越界
        if(tmp == mid) return mid;
        else if(mid < tmp) left = mid + 1;
        else right = mid;
    }
    return right - 1;   //此时right表示的是大于根号x的最小整数，right-1即为小于根号x的最大整数
}
```

#### leetcode 367. 有效的完全平方数
二分法小结的第一种情况，十分简单。  

```CPP
bool isPerfectSquare(int num) {
    if(num == 1) return true;
    int left = 1,right = num;
    while(left < right){
        int mid = left + (right - left) /2;
        int tmp = num / mid;
        if((num % mid == 0) && tmp == mid) return true;
        else if(mid < tmp) left = mid + 1;
        else right = mid;
    }
    return false;
}
```

### 不是在解空间进行搜索，而是通过分治（二分）思想递推（递归）求解
#### leetcode 50. Pow(x, n)
```CPP
double myPow(double x, int n) {
    double res = 1.0;
    for (int i = n; i != 0; i /= 2) {
        if (i % 2 != 0) res *= x;
        x *= x;
    }
    return n < 0 ? 1 / res : res;   //n为负数需要做除法
}
```

##  寻找两个正序数组的中位数（2个有序数组查找共同的中位数）——leetcode 4
### 解法1：双指针，时间复杂度O((N + M) / 2)
指针p指向第一个数组的第一个元素，指针q指向第二个数组的第一个元素，如果P指向的值小于q指向的值，p++，反之q++，直到找到中位数，返回结果。  

### 解法2【推荐】：同时对两个数组采用二分法，时间复杂度O(log(N + M))
具体做法比较复杂，详见[[LeetCode] 4. Median of Two Sorted Arrays 两个有序数组的中位数](https://www.cnblogs.com/grandyang/p/4465932.html)

## 最长连续序列——leetcode128 之前没做，先放一放

## K数之和（整体思路）
这类题目，一般要求查找序列中满足：
```CPP
num1 + num2 + num3 + ... =（or < or > or 最接近等） target;  //数字要求比较灵活，2数，3数，...k数（一般不超过4个数），判断条件也灵活
```

### 方法1：固定指针+双指针
使用双指针的前提条件是序列有序，如果无序，原始序列的遍历就无法使用双指针，只能用暴力for循环，此时时间复杂度是O(N^2)；如果有序（排序复杂度O(logN)），再用双指针，查找的时间复杂度可以降到O(N)。  

- 第一步，是对原始序列进行排序。  

- 第二步，如果K数之和的K大于2，假设K等于3，此时需要一个固定指针 + 双指针；固定指针作为最外层循环，用来固定每次双指针遍历时的最外层节点。  

- 第三步，固定指针、双指针都得去重，去重思路也比较简单，详细过程见下述。  

### 方法2：hashmap
hashmap查找的时间复杂度为O(1)，属于用空间换时间。如果对于时间复杂度要求比较高的场合，尽量用hashmap。  

使用hashmap的前提——不然没法使用hashmap：
- 两数之和——两个数字在一个or两个序列中都行
- 三/四数之和——三/四个数字至少分布在2个以上的数组中
- 五/六数之和——五/六个数字至少分布在3个以上的数组中

使用hashmap的主要过程：
- 遍历原始序列，建立hashmap
- 使用差值查看另外一个/K个数组是否在原始序列中
```CPP
if(map.count(target - nums[i])) ...;
```

## 两数之和——leetcode 1
### 解法：使用HashMap
#### 时间复杂度O(N)，空间复杂度O(N)
核心思路：用target减去遍历到的数字，就是另一个需要的数字，只用查看另外一个数字是否在hashmap中即可  
```CPP
if(map.count(target - nums[i])) ...;
```

一次遍历建立hashmap，一次遍历查找目标结果，但以下将两次遍历放到一个for循环中  
```CPP
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> m;
    for (int i = 0; i < nums.size(); ++i) {
        if (m.count(target - nums[i])) {
            return {i, m[target - nums[i]]};
        }
        m[nums[i]] = i;
    }
    return {};
    }
```
## 三数之和——leetcode 15
### 解法：三指针——固定第一个指针，第二个指针从左开始，第三个指针从右开始
#### 时间复杂度O(N^2)，空间复杂度O(1)
#### step 1:给原始序列排序
使用双指针、三指针等，一般对原始数组的要求是有序！  

排序时间复杂度O(logN)。  

#### step 2:将第一个指针固定在最左边
第一个指针固定在左、中、右得视情况而定。  

本题中固定在最左边的原因是最左边的数val在三个指针中值是最小的，如果
```CPP
val * 3 > target;
```
那么后续遍历中三数之和的结果肯定大于target，不符合题目要求，因此可以剪枝。  
```CPP
3sum >= val * 3 > target;
```
第一个指针还需要去重处理。  
```CPP
if (first > 0 && nums[first] == nums[first - 1]) continue;
```

#### step 3:第二个指针从左开始，第三个指针从右开始遍历序列
两指针遍历，其中包含去重的过程：  
```CPP
//前面 target -= nums[first]，因此下面只用查找两数之和
while (left < right) {
    if (nums[left] + nums[right] == target) {   //满足条件
        res.push_back({nums[first], nums[left], nums[right]});  //保存结果
        while (left < right && nums[left] == nums[left + 1]) ++left;    //左指针去重
        while (left < right && nums[right] == nums[right - 1]) --right; //右指针去重
        ++left; --right;    //去完重后，左右指针分别向内移动一步
    } else if (nums[left] + nums[right] < target) ++left;   //若3sum小于target，则左指针右移
    else --right;   //否则，右指针左移
    }
```
## 最接近的三数之和——leetcode 16
和上面题目的思路完全一样，遍历的过程中只需要定义一个变量diff用来记录差的绝对值。  

## 三数之和较小值——leetcode 259
和上面题目的思路完全一样，但是针对这题，有一个新的剪枝技巧：  

当判断三数之和小于目标值时，如果当前符合要求，此时结果应该加上right-left，因为数组排序了以后，new_right < right时，必然存在new_result < cur_result < target，因此right左边的结果都符合要求，不必再去遍历判断。  

然后将左指针右移一位，否则将右指针左移一位。  

## 四数之和——leetcode 18
### 解法：四指针！前两个指针固定节点，后两个指针为left，right性质的指针  
#### 时间复杂度O(N^3)，空间复杂度O(1)
和三指针思路一样，唯一的区别就是：每个指针都得去重，去重思路也一模一样。  

## 四数之和II——leetcode 454
### 解法1【推荐】：双hashmap
#### 时间复杂度O(N^2)，空间复杂度O(N)
包含有4个数组，因为每个数字分别存在对应的数组中，而不是在一个序列中，因此可以采用双hashmap进行快速查找。  

如果把A和B的两两之和都求出来，在 HashMap 中建立两数之和跟其出现次数之间的映射，那么再遍历C和D中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了。  

在实现过程中只用一个hashmap就能解决，但是核心思路其实是双hashmap。  
```CPP
int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
    int res = 0;
    unordered_map<int, int> m;
    for (int i = 0; i < A.size(); ++i) {
        for (int j = 0; j < B.size(); ++j) {
            ++m[A[i] + B[j]];
        }
    }
    for (int i = 0; i < C.size(); ++i) {
        for (int j = 0; j < D.size(); ++j) {
            int target = -1 * (C[i] + D[j]);
            res += m[target];
        }
    }
    return res;
    }
```

### 解法2：四指针
#### 时间复杂度O(N^3)，空间复杂度O(1)
思路和上一题一样。  

## 接雨水问题
## 盛最多水的容器——leetcode 11
### 解法：双指针！时间复杂度O(N)，空间复杂度O(1)

定义left、right指针从左右两端开始向中间搜索，每移动一次，找出左右两个边缘中较小的那个乘以两边缘的距离，计算一次结果，返回其中最大的结果即可。  

双指针中一般还可以通过去重进行优化。  

```CPP
public int maxArea(int[] height) {
    int res = 0, i = 0, j = height.length - 1;
    while (i < j) {
        int h = Math.min(height[i], height[j]); //找出两指针中较小的那个值
        res = Math.max(res, h * (j - i));   //计算一次结果，并将更大的值存在res中
        while (i < j && h == height[i]) ++i;    //left指针去重
        while (i < j && h == height[j]) --j;    //right指针去重
    }
    return res;
    }
```
## 接雨水——leetcode 42
### 解法1：双指针——一次遍历即可——时间复杂度O(N)，空间复杂度O(1)
创建left和right两个指针分别指向数组的首尾位置，从两边向中间扫描，在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是left指向的值，则从左向右扫描，如果较小值是right指向的值，则从右向左扫描；若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，以此类推直至left和right指针重合。  
```CPP
int trap(vector<int>& height) {
    int left = 0, right = height.size() - 1, level = 0, res = 0;
    while (left < right) {
        int lower = height[(height[l] < height[r]) ? l++ : r--];    //找出两个指针中更小的那个值
        level = max(level, lower);  //更新当前最低水槽值的较大值
        res += level - lower;   //如果当前指针最小值比最低水槽值小，则将差值加到res中
    }
    return res;
    }
```

### 解法2：遍历两次数组——从左到右、从右到左两次遍历数组——时间复杂度O(2N)，空间复杂度O(N)
算法需要遍历两遍数组，第一遍在dp\[i] 中存入i位置左边的最大值，然后开始第二遍遍历数组，第二次遍历时找右边最大值，然后和左边最大值比较取其中的较小值，然后跟当前值A\[i] 相比，如果大于当前值，则将差值存入结果。  
```CPP
//最清晰的思路是遍历3次数组，第一次从左到右更新dp数组，第二次从右到左更新dp数组，第三次查找结果；
//但优化后只需要两次遍历即可
int trap(vector<int>& height) {
    int res = 0, mx = 0, n = height.size();
    vector<int> dp(n, 0);
    for (int i = 0; i < n; ++i) {   //从左到右遍历数组，保存当前遇到的最大值
        dp[i] = mx;
        mx = max(mx, height[i]);
    }
    mx = 0;
    for (int i = n - 1; i >= 0; --i) {  //从右到左遍历数组
        dp[i] = min(dp[i], mx); //保存两个水槽中较低值
        mx = max(mx, height[i]);    //更新mx
        if (dp[i] > height[i]) res += dp[i] - height[i];    //保存差值
    }
    return res;
    }
```
### 解法3：维护一个递减栈——时间复杂度O(N)，空间复杂度O(N)

#### 递增栈、递减栈是一个非常重要的技巧，很多mid、hard难度的数组题都能用到，而且一般都是最优解

#### 递增栈、递减栈中一般保存的是数组的下标——方便后续计算

#### 核心思路
```CPP
stack<int> stk; //创建栈
for(int i = 0;i < nums.size();i++){ //遍历原始数组
    if (stk.empty() || nums[i] <= nums[st.top()]) st.push(i++); //维持一个递减栈/递增栈
    else ...;   //否则，出栈，并进行元素处理
}
```
#### 本题思路
遍历高度数组，如果此时栈为空，或者当前高度小于等于栈顶高度，则把当前高度的坐标压入栈，注意这里不直接把高度压入栈，而是把坐标压入栈，这样方便在后来算水平距离。  

当遇到比栈顶高度大的时候，就说明有可能会有坑存在，可以装雨水。此时的右边界是当前元素的高度，左边界是第二个栈顶元素的高度（因为第一个栈顶元素要出栈）。  

也因此栈里至少有一个高度，如果只有一个的话，那么不能形成坑（缺少左边界），直接跳过；如果多余一个的话，那么此时把栈顶元素取出来当作坑，新的栈顶元素就是左边界，当前高度是右边界，只要取二者较小的，减去坑的高度，长度就是右边界坐标减去左边界坐标再减1，二者相乘就是盛水量啦。  

```CPP
int trap(vector<int>& height) {
    stack<int> st;
    int i = 0, res = 0, n = height.size();
    while (i < n) {
        if (st.empty() || height[i] <= height[st.top()]) {  //维持一个递减栈
            st.push(i++);
        } else {
            int t = st.top(); st.pop();
            if (st.empty()) continue;   //栈中没有左边界，则直接跳过
            res += (min(height[i], height[st.top()]) - height[t]) * (i - st.top() - 1); //计算水量，并加到res中
        }
    }
    return res;
    }
```
## 除自身以外数组的乘积——leetcode 238
### 解法：遍历两次遍历数组——时间复杂度O(3N)，空间复杂度O(2N)
从左往右、从右往左遍历两次数组，将两次遍历结果分别保存在两个数组vec1，vec2中，第三次遍历时：
```CPP
res[i] = vec1[i - 1] * vec2[i + 1]; //以i为分割点计算最终结果
```

### 解法优化：上述遍历次数可以优化成两次，同时不需要额外的数组来保存中间结果——时间复杂度O(2N)，空间复杂度O(1)

由于最终的结果都是要乘到结果res中，所以可以不用单独的数组来保存乘积，而是直接累积到结果res中，我们先从前面遍历一遍，将乘积的累积存入结果res中，然后从后面开始遍历，用到一个临时变量right，初始化为1，然后每次不断累积，最终得到正确结果：  
```CPP
vector<int> productExceptSelf(vector<int>& nums) {
    vector<int> res(nums.size(), 1);
    for (int i = 1; i < nums.size(); ++i) {
        res[i] = res[i - 1] * nums[i - 1];
    }
    int right = 1;
    for (int i = nums.size() - 1; i >= 0; --i) {
        res[i] *= right;
        right *= nums[i];
    }
    return res;
}
```

## 全排列——回溯
leetcode 31、46、47、60等，包含10题左右

## 矩阵旋转
leetcode 48：上下颠倒，然后根据对角线交换元素即可

## 字符串加法

数组题：leetcode 66 可以从高位往低位加，即从左往右，只要记住9的位置即可
链表题：leetcode 2、445

## 爬楼梯——动态规划
leetcode 70

## 格雷编码——回溯
LeetCode 89

## 矩阵题
- 根据题干要求改变矩阵中的元素
leetcode 73

## 最优化应用问题——加油站
leetcode 134

## 只出现一次的数——系列题
leetcode 136、137、260

## 有效数读——还没完成过
leetcode 36

# 链表【送分题】
## 链表查找
### 快慢指针（根据题意要求，快指针可以一次走2、3、4步等等）
#### 环形链表 leetcode 141
判断链表是否有环，用快慢指针，快指针一次走2步，如果fast == slow 则说明存在环。  
#### 环形链表 II leetcode 142
- 先确定链表是否存在环，并且找到快慢节点的相遇结点
- 再利用双指针（两个慢指针）找到环入口结点

### 双指针（两个慢指针，即每次只走一步的指针），出发不同步
#### 删除链表的倒数第N个结点 leetcode 19
first指针先走n步，second指针再出发，等到first指针为null时，second指向倒数第N个结点的前一个节点，再进行删除操作即可。  

## 链表复制
### 思路1【推荐】：在每个原结点p后面插入一个复制p了的q结点，复制完后，再将q结点挨个摘出来组成复制后的新链表  
复制带随机指针的链表 leetcode 138  

### 思路2：使用hashmap，构建老结点和新拷贝节点的映射，然后再建立新链表

### 【注】以上方法适用于一切节点的复制，比如树、图的复制

## 链表修改
### 思路1【作弊思路】：直接改变结点的val，而不去操作结点
### 思路2：原地修改链表——将单链表中部分结点摘出来组成一个新的子链表，然后再将子链表按照题目要求插入到原始链表中，形成修改后的链表
#### 两两交换链表中的节点 leetcode 24
- 将偶数位的链表摘出来组成新的子链表
- 将新的子链表挨个插入到原始链表节点的前面

#### 重排链表 leetcode 143
- 双指针找到链表中间结点
- 将原始链表后半部分摘出来组成新的子链表（头插法逆序）
- 按照题目要求重新插入到原始链表中

### 链表修改的注意事项
- 如果需要修改链表，则一定要定义一个新的节点pre_head，且pre_head->next = head；并保证不会改动pre_head，最终返回pre_head->next；其他操作的节点另外定义
- 若要调整链表节点cur位置，一定需要先找到cur节点的前一个节点pre，方便后续链表指针改变

## 链表逆转
### 链表逆转的递归思路
#### 整个链表逆转leetcode 206
```CPP
ListNode* reverseList(ListNode* head) {
    if(!head || !head->next) return head;
    ListNode *new_head = reverseList(head->next);
    head->next->next = head;
    head->next = NULL;
    return new_head;  //节点new_head为逆转后的头结点，如果不需要该节点，可以删掉返回值
}
```

#### 部分链表逆转leetcode 92
```CPP
void helper(ListNode* first,ListNode* second){  //传入要逆转的首尾节点，下面版本没有返回新的头结点，如果需要，可以按照上面那种返回方式加上
    if(first == second) return;
    helper(first->next,second);
    first->next->next = first;
    first->next = NULL;
}
```
### K个一组翻转链表 leetcode 25
- 遍历链表，每遍历k个节点时，就部分逆转链表，逆转代码参考上面

### 链表递归的通用思路
#### 思路1：一直递归到链表末尾，然后从末尾向前返回，返回的过程中建立新的链表，上述链表逆转就是用的这种思路
```CPP
ListNode* helper(ListNode* head){
    if(!head || !head->next) return head;   //找到链表末尾节点，并返回
    ListNode* p = helper(head->next);   //先深度遍历到链表末尾，并从后往前建立新的链表
    if(xxx) head->next = xxx;   //这里可以加入构建新链表的条件，比如去除重复节点
    else xxx;
    return head;
}
```
比如 删除排序链表中的重复元素：leetcode 83  

#### 思路2：从前往后递归链表，边递归的过程中边建立新的链表
```CPP
ListNode* helper(ListNode* head) {
        if (!head) return head; //递归边界条件
        if (xxx) {  //如果该节点满足插入条件
            head->next = helper(head->next);  //将该节点加入到新链表中，并继续递归
            return head;    //返回递归后的新链表头结点
        }else{
            xxx;    //...
            return helper(head->next);  //继续递归下去，查找符合要求的节点
        }
    }
```
比如 删除排序链表中的重复元素 II：leetcode 82  

### 链表逆转的递推思路
#### 使用头插法
- 需要定义3个节点：
  - 一个为头插法的前一个节点pre_head，pre->head指向调整后的头结点
  - 一个为头插法的第一个节点pre，该节点记录插入位置
  - 一个为cur节点，该节点记录当前插入到第几个节点
- pre和cur节点完成节点逆转的指针交换操作

## 链表排序
### 单链表实现快排
```CPP
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        quick_sort(head,NULL);
        return head;
    }

private:
    void quick_sort(ListNode* head,ListNode* tail){
        if(head == tail) return;
        ListNode* pos = helper(head,tail);
        quick_sort(head,pos);
        quick_sort(pos->next,tail);
    }

    ListNode* helper(ListNode* head,ListNode* tail){
        ListNode *p = head;
        ListNode *q = p->next;
        int tmp = p->val;
        while(q != tail){
            if(q->val < tmp){
                p = p->next;
                swap(p->val,q->val);
            }
            q = q->next;
        }
        swap(head->val,p->val);
        return p;
    }
};
```

### 单链表实现归并排序
```CPP
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode *pre,*slow,*fast;
        pre = slow = fast = head;
        while(fast && fast->next){
            pre = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        pre->next = NULL;
        return merge(sortList(head),sortList(slow));
    }

private:
    ListNode* merge(ListNode* l1,ListNode* l2){
        ListNode* pre_head = new ListNode(-1);
        ListNode* cur = pre_head;
        while(l1 && l2){
            if(l1->val < l2->val){
                cur->next = l1;
                l1 = l1->next;
            }else{
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;
        }
        if(l1) cur->next = l1;
        if(l2) cur->next = l2;
        return pre_head->next;
    }
};
```

# 旋转问题
## 链表旋转 leetcode 61
最简单的思路：
- 将链表首尾节点相连
- 找到旋转后链表的新的头结点new_head和new_head的前一个节点p，断开p->next，即p成为新链表的尾结点
## 数组旋转
### 一维数组旋转（数组比链表旋转更简单是因为数组可以利用下标直接交换元素） leetcode 189
#### 思路1：三次旋转（适用于一切单序列的旋转，比如也适用于链表旋转），用reverse很容易实现。
**时间复杂度O(N)，空间复杂度O(1)，但最坏时间复杂度可以到O(2N)**  
- 将前k个节点旋转
- 将k+1~N节点旋转
- 最后再讲整个序列旋转即可

```CPP
void rotate(vector<int>& nums, int k) {
    if (nums.empty() || (k %= nums.size()) == 0) return;
    int n = nums.size();
    reverse(nums.begin(), nums.begin() + n - k);
    reverse(nums.begin() + n - k, nums.end());
    reverse(nums.begin(), nums.end());
}
```

#### 思路2：创建一个新数组，将偏移了k个位置的节点复制到新数组的首节点。时间复杂度O(N)，空间复杂度O(N)  
```CPP
void rotate(vector<int>& nums, int k) {
    vector<int> t = nums;
    for (int i = 0; i < nums.size(); ++i) {
        nums[(i + k) % nums.size()] = t[i];
    }
}
```
#### 思路3：旋转数组的操作可以看做从数组的末尾取k个数组放入数组的开头，因此可以用STL的push_back和erase实现。  

**时间复杂度O(N)，空间复杂度O(1)。由于vector容器删除时需要移动元素的位置，因此时间复杂度比想象中更高**  

```CPP
void rotate(vector<int>& nums, int k) {
    if (nums.empty() || (k %= nums.size()) == 0) return;
    int n = nums.size();
    for (int i = 0; i < n - k; ++i) {
        nums.push_back(nums[0]);
        nums.erase(nums.begin());
    }
}
```

#### 思路4【推荐】：奇淫技巧，通过不停的交换某两个数字的位置来实现旋转。时间复杂度O(N)，空间复杂度O(1)  
其实整体思路类似于递归，先找到旋转后的前k个元素，然后再在\[k+1,n)中继续查找，直到全部查找完。  
```CPP
void rotate(vector<int>& nums, int k) {
    if (nums.empty()) return;
    int n = nums.size(), start = 0;   
    while (n && (k %= n)) {
        for (int i = 0; i < k; ++i) {
            swap(nums[i + start], nums[n - k + i + start]);
        }
        n -= k;
        start += k;
    }
}
```

# 树
## 深度优先遍历（先序、中序、后序遍历）
### 递归遍历（最简单）
#### 先序(中、左、右)
```cpp
void preOrder(TreeNode *root) {
    if (!root) return;
    cout << root->val << endl;
    if (root->left) preOrder(root->left);
    if (root->right) preOrder(root->right);
}
```
#### 中序(左、中、右)
```cpp
void inOrder(TreeNode *root) {
    if (!root) return;
    if (root->left) inOrder(root->left);
    cout << root->val << endl;
    if (root->right) inOrder(root->right);
}
```
#### 后序(左、右、中)
```cpp
void postOrder(TreeNode *root) {
    if (!root) return;
    if (root->left) postOrder(root->left);
    if (root->right) postOrder(root->right);
    cout << root->val << endl;
}
```
### 递推遍历（使用栈；递推方法很多，以下递推思路最清晰）
#### 先序(中、左、右)
```cpp
void preOrder(TreeNode* root) {
    if(!root) return;
    stack<TreeNode*> stk;
    TreeNode* p = root;
    while(!stk.empty() || p){
        if(p){
            cout << root->val << endl;  //优先访问父节点
            stk.push(p);    
            p = p->left;    //先遍历左子节点
        }else{
            p = stk.top();stk.pop();
            p = p->right;   //再遍历右子节点
        }
    }
}
```
#### 中序(左、中、右)
```cpp
void inOrder(TreeNode* root) {
    if(!root) return;
    stack<TreeNode*> stk;
    TreeNode* p = root;
    while(!stk.empty() || p){
        if(p){
            stk.push(p);    
            p = p->left;    //先遍历左子节点
        }else{
            p = stk.top();stk.pop();
            cout << root->val << endl;  //只调整了这一行代码的位置。优先访问左子节点
            p = p->right;   //再遍历右子节点
        }
    }
}
```
#### 后序(左、右、中)
后序遍历为(左、右、中)，前序遍历为(中、左、右)，将前序遍历的左右节点访问顺序对换，则前序遍历的访问顺序变为(中、右、左)，刚好为后序遍历的逆序，因此可以采用前序遍历的变形版来得到后序遍历的序列。  

下述代码将后序遍历的访问序列存储在vector中。  

```cpp
vector<int> postOrder(TreeNode* root) {
    if(!root) return {};
    vector<int> res;
    stack<TreeNode*> stk;
    TreeNode* p = root;
    while(!stk.empty() || p){
        if(p){
            res.insert(res.begin(),p->val); //采用头插法，此时插入的序列为逆序序列；优先访问父节点
            stk.push(p);
            p = p->right;   //先遍历右子节点
        }else{
            p = stk.top();stk.pop();
            p = p->left;    //再遍历左子节点
        }
    }
    return res;
}
```
### 更优化的二叉树遍历方法——Morris Traversal
#### 上述方法时间复杂度、空间复杂度均为O(N)，采用下述方法空间复杂度可以优化到O(1)。  

要使用O(1)空间进行遍历，最大的难点在于，遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的p指针），由于不能用栈作为辅助空间。  

为了解决这个问题，Morris方法用到了线索二叉树（threaded binary tree）的概念。  

在Morris方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了。  

#### 中序遍历
```CPP
void inOrder(TreeNode* root) {
    if(!root) return;
    TreeNode *cur, *pre;    //cur节点指向现在访问的节点，pre节点找cur节点的前驱
    cur = root;
    while (cur) {
        if (!cur->left) {
            cout << cur->val << endl;  //左子节点不存在，则可以打印父节点
            cur = cur->right;   //因为左子节点不存在、父节点已访问，因此可以顺理成章访问右子节点
        } else {    //当左子节点存在，此时必须先找到cur节点的前驱节点，即左子树的最右子节点
            pre = cur->left;     
            while (pre->right && pre->right != cur) pre = pre->right;   //寻找左子树的最右子节点
            if (!pre->right) {  //此时找到了左子树的最右子节点
                pre->right = cur;   //构建前驱->cur节点的关系
                cur = cur->left;    //此时前驱关系已建立，可以安心访问cur的左子树
            } else {    //只有当 re->right == cur条件成立时，才走这条路。此时已经访问到cur的前驱节点
                pre->right = NULL;  //当前左子树的节点全部都访问完毕，需要访问父节点cur。为了防止产生死循环，需要将之前构建的前驱关系删掉
                cout << cur->val << endl;    //访问父节点cur
                cur = cur->right;   //因为左子节点、父节点已访问，因此可以顺理成章地访问右子节点
            }
        }
    }
}
```
#### 先序遍历
前序遍历与中序遍历相似，代码上只有一行不同，不同就在于输出的顺序。  
```CPP
void preOrder(TreeNode* root) {
    if(!root) return;
    TreeNode *cur, *pre;    
    cur = root;
    while (cur) {
        if (!cur->left) {
            cout << cur->val << endl;  
            cur = cur->right;   
        } else {    
            pre = cur->left;     
            while (pre->right && pre->right != cur) pre = pre->right;   
            if (!pre->right) { 
                cout << cur->val << endl;   //此时先打印父节点，再访问左子树
                pre->right = cur;   
                cur = cur->left;    
            } else {    
                pre->right = NULL;  
                //cout << cur->val << endl; 中序遍历时的输出位置 
                cur = cur->right;   
            }
        }
    }
}
```

#### 后序遍历
后续遍历同样可以采用将先序遍历的左右节点交换，然后逆序输出的方法。  

```CPP
vector<int> postOrder(TreeNode* root) {
        vector<int> res;
        if (!root) return res;
        TreeNode *cur, *post;
        cur = root;
        while (cur) {
            if (!cur->right) {
                res.insert(res.begin(),cur->val);
                cur = cur->left;
            } else {
                post = cur->right;
                while (post->left && post->left != cur) post = post->left;
                if (!post->left) {
                    res.insert(res.begin(),cur->val);
                    post->left = cur;
                    cur = cur->right;
                } else {
                    post->left = NULL;
                    cur = cur->left;
                }
            }
        }
        return res;
    }
}
```

### 时间复杂度分析
证明时间复杂度为O(n)，最大的疑惑在于寻找中序遍历下二叉树中所有节点的前驱节点的时间复杂度是多少，即以下两行代码：
```CPP
while (prev->right != NULL && prev->right != cur)
    prev = prev->right;
```
直觉上，认为它的复杂度是O(nlgn)，因为找单个节点的前驱节点与树的高度有关。  

但事实上，寻找所有节点的前驱节点只需要O(n)时间。  

n个节点的二叉树中一共有n-1条边，整个过程中每条边最多只走2次，一次是为了定位到某个节点，另一次是为了寻找上面某个节点的前驱节点，如下图所示，其中红色是为了定位到某个节点，黑色线是为了找到前驱节点。所以复杂度为O(n)。

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/130.jpg" width = 60% height = 60% /></div>

- [Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）](https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html)

## 广度优先遍历（层次遍历）
### 递归模板
```CPP
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> res;
    levelorder(root, 0, res);
    return res;
}
    
void levelorder(TreeNode* node, int level, vector<vector<int>>& res) {  //需要加入level保存层的信息
    if (!node) return;
    if (res.size() == level) res.push_back({}); //访问新一层，先创建一个初始化vec
    res[level].push_back(node->val);    //将该层节点加入到vec[level]中
    if (node->left) levelorder(node->left, level + 1, res); 
    if (node->right) levelorder(node->right, level + 1, res);
}
```

### 递推模板
```CPP
vector<vector<int>> levelOrder(TreeNode* root) {
    if (!root) return {};
    vector<vector<int>> res;
    queue<TreeNode*> q{{root}};
    while (!q.empty()) {    //队列不为空，一直循环遍历
        vector<int> vec;
        for (int i = q.size(); i > 0; --i) {    //size的大小即是当前层内结点总数
            TreeNode *t = q.front(); q.pop();
            vec.push_back(t->val);
            if (t->left) q.push(t->left);
            if (t->right) q.push(t->right);
        }
        res.push_back(vec); //当前层节点访问完毕，将记录当前层节点的数组加入到最终数组res中
    }
    return res;
}
```
### 层次遍历的各类题目
- 二叉树的层序遍历 leetcode 102
- 二叉树的层序遍历II leetcode 107
- 二叉树的锯齿形层次遍历 leetcode 103
- ...
### 层次遍历的变型思路——将结果顺序or逆序保存
#### 使用insert(每次在vec首部插入元素都会导致vec中所有元素的位置移动，因此性能不如先插到vec尾部，再整体逆转)
```cpp
res[level].insert(res[level].begin(),root->val);    //逆序保存单个节点
```
#### 使用rbegin、rend
```cpp
res.push_back(vec.rbegin(),vec.rend());    //将整个vec逆序
```
#### 使用reverse、reverse_copy
```cpp
reverse(vec.begin(),vec.end()); //将整个vec逆序，逆序结果保存在vec中

vector<int> rev_vec;
reverse_copy(vec.begin(),vec.end(),rev_vec.begin()); //将vec逆序的结果保存在新创建的rev_vec中
```

## 二叉树递归的传参技巧
### 层高不需要以参数值level传递，只需return就行了，如果需要利用到层高，可以将return后的层高保存到变量中
```CPP
if(!root) return 0;
int left_level = helper(root->left);
```
### 如果需要记录层的信息以及返回结果为true/flase，可以令返回值为负数代表false，返回值为正数代表true，这样可以在递归函数中少传参数
比如：平衡二叉树 leetcode 110
```CPP
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return helper(root) != -1;
    }
private:
    int helper(TreeNode* root){
        if(!root) return 0;
        int left = helper(root->left);
        if(left == -1) return -1;   //层高返回为-1，说明为非平衡二叉树，不再进行后续递归，直接返回-1给主函数
        int right =  helper(root->right);
        if(right == -1) return -1;
        if(abs(left - right) > 1) return -1;
        return max(left,right) + 1;
    }
};
```
## 二叉树的查找
## 递归查找（需要从题干中确定递归起点和递归终点）
### 起点：根节点，终点：叶节点
以下两题解法类似，为二叉树树递归最简单的情况  
#### leetcode 104. 二叉树的最大深度
```CPP
int maxDepth(TreeNode* root) {
    if(!root) return 0;
    return 1 + max(maxDepth(root->left),maxDepth(root->right));
}
```
#### leetcode 559. N叉树的最大深度
略。  

#### leetcode 111. 二叉树的最小深度
此题需要判断终点是否为叶节点，因为有个特例情况\[1,2]，该二叉树的最小深度是2而不是1。  
```CPP
int minDepth(TreeNode* root) {
    if(!root) return 0;
    else if(!root->right) return 1 + minDepth(root->left);  //非叶节点，继续递归
    else if(!root->left) return 1 + minDepth(root->right);  //非叶节点，继续递归
    return 1 + min(minDepth(root->left),minDepth(root->right));
}
```
### 查找公共节点
#### leetcode 235. 二叉搜索树的最近公共祖先
利用二叉搜索树的性质，公共父节点的值一定位于两个子节点之间
```CPP
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) return NULL;
    if (root->val > max(p->val, q->val))    //如果根节点的值大于p和q之间的较大值，说明p和q都在左子树中
        return lowestCommonAncestor(root->left, p, q);
    else if (root->val < min(p->val, q->val))   //如果根节点小于p和q之间的较小值，说明p和q都在右子树中
        return lowestCommonAncestor(root->right, p, q);
    else return root;   //如果都不是，则说明当前根节点就是最小共同父节点
}
```
此题用while循环也能搞定,相同的思路
```CPP
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    while (true) {
        if (root->val > max(p->val, q->val)) root = root->left;
        else if (root->val < min(p->val, q->val)) root = root->right;
        else break;
    }      
    return root;
}
```

#### leetcode 236. 二叉树的最近公共祖先
非常标准的一套二叉树递归代码：
- 根据题目分析，采用后续遍历的递归方式
- 第一步判断单节点的递归返回条件
- 第二步进行后续遍历的递归
- 第三步进行判断，如果两个节点都存在，那么说明父节点是最近公共祖先，返回；否则，说明父节点的上面才是最近公共祖先，单一返回父节点
```CPP
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || p == root || q == root) return root;   //递归返回的条件判断
    TreeNode *left = lowestCommonAncestor(root->left, p, q);
    if (left && left != p && left != q) return left;    //剪枝，如果当前返回的节点既不是空节点、p节点也不是q节点，那么一定是最近公共父节点，直接返回，不需要再递归右子树
    TreeNode *right = lowestCommonAncestor(root->right, p , q);
    if (left && right) return root; //如果两个节点都满足条件，返回父节点
    return left ? left : right; //否则返回存在的那个节点
}
```

### 路径和问题
### 起点：根节点，终点：叶节点
#### 判断是否存在路径和为sum：leetcode 112. 路径总和
略。
#### 找到所有路径总和等于给定目标和的路径：leetcode 113. 路径总和 II
```CPP
public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        if(!root) return {};
        vector<vector<int>> res;
        vector<int> vec;
        helper(res,vec,root,sum);
        return res;
    }

private:
    void helper(vector<vector<int>> &res,vector<int>& vec,TreeNode* root, int sum){
        if(!root) return;
        vec.push_back(root->val);
        if(!root->left && !root->right && sum == root->val){    //找到符合条件的路径，加到res中
                res.push_back(vec);
        }
        helper(res,vec,root->left,sum - root->val);
        helper(res,vec,root->right,sum - root->val);
        vec.pop_back();
    }
```
### 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
#### leetcode 437. 路径总和 III
```CPP
public:
    int pathSum(TreeNode* root, int sum) {
        if(!root) return 0;
        return helper(root,sum) + pathSum(root->left,sum) + pathSum(root->right,sum);   //每一个节点都作为起始节点去递归，将所有可能的路径数量相加
        
    }

private:
    int helper(TreeNode* root, int sum){
        if(!root) return 0;
        int count = 0;
        if(root->val == sum) count++;   //尽管此时已经找到了一条符合要求的路径，但是后续依然往下递归，因为有的节点值可能为负数，这样后续路径和可能相加为0，再加上当前找到的符合要求的路径，就又能构造出一条新的、以root为起始点的路径
        return count + helper(root->left,sum - root->val) + helper(root->right,sum - root->val);
    }
```
【注】此题可用递推+hashmap的方法，边遍历边记录，减少重复计算

### 每条从根到叶子节点的路径都代表一个数字，计算从根到叶子节点生成的所有数字之和 
#### leetcode 129. 求根到叶子节点数字之和
```CPP
public:
    int sumNumbers(TreeNode* root) {
        return helper(root,0);
    }

private:
    int helper(TreeNode* root,int tmp){
        if(!root) return 0;
        tmp = tmp * 10 + root->val;
        if(!root->left && !root->right) return tmp; //有这个条件就可以保证访问左右空的叶节点时不会将tmp的值计算两次
        return helper(root->left,tmp) + helper(root->right,tmp);
    }
```
### 从树中任意节点出发，达到任意节点的序列
#### leetcode 124. 二叉树中的最大路径和
```CPP
    int maxPathSum(TreeNode* root) {
        int res = INT_MIN;
        helper(root, res);
        return res;
    }
    int helper(TreeNode* node, int& res) {
        if (!node) return 0;
        int left = max(helper(node->left, res), 0); //left要么大于0，要么取0
        int right = max(helper(node->right, res), 0);   //right要么大于0，要么取0
        res = max(res, left + right + node->val);   //找当前能组成的最大路径
        return max(left, right) + node->val;    //返回最大子路径（只能选择左、右、非、子节点路径中的一个）
    }
```

## 递归：搜索、判断
### 采用先序遍历，同时遍历两个（多个）起始节点，一一判断
以下两题思路完全一样。
#### leetcode 100. 相同的树
略。
#### leetcode 101. 对称二叉树
```CPP
public:
    bool isSymmetric(TreeNode* root) {
        return helper(root,root);
    }
private:
    bool helper(TreeNode* p1,TreeNode* p2){ //传入两个节点
        if(!p1 && !p2) return true;
        if(!p1 || !p2 || p1->val != p2->val) return false;  //如果节点值不同，直接返回
        return helper(p1->left,p2->right) && helper(p1->right,p2->left);    //两种对称的递归方式
    }
```
### 遍历树的高度（判断它是否是高度平衡的二叉树）
#### leetcode 110. 平衡二叉树
用了前面说的技巧，遍历高度的时候，可以将返回值为-1作为flase，返回值大于零作为true；同时在递归过程中返回值大于零也代表着树的高度h，这样返回值就能包含两种含义，可以少传递一个参数。  

```CPP
public:
    bool isBalanced(TreeNode* root) {
        return helper(root) != -1;
    }
private:
    int helper(TreeNode* root){
        if(!root) return 0;
        int left = helper(root->left);
        if(left == -1) return -1;   //返回值为-1，说明不符合平衡二叉树的情况，剪枝，不再递归，直接返回结果。
        int right =  helper(root->right);
        if(right == -1) return -1;  //返回值为-1，说明不符合平衡二叉树的情况，剪枝，不再递归，直接返回结果。
        if(abs(left - right) > 1) return -1;    //验证是否高度平衡
        return max(left,right) + 1;
    }
```

## 二叉搜索树
这类题目主要为验证是否为二叉搜索树、构造二叉搜索树、修改二叉搜索树。  

### 二叉搜索树做题的一个重要性质：中序遍历为递增的有序序列

很多叉搜索树的题目都能通过此性质解决。    


### 验证二叉搜索树
#### leetcode 98. 验证二叉搜索树
**思路**  
- 中序遍历，判断cur->val >= pre->val 即可。

```CPP
    bool isValidBST(TreeNode* root) {
        if(!root) return true;
        return helper(root,LONG_MIN,LONG_MAX);
    }
private:
    bool helper(TreeNode* root,long mn,long mx){    //mn和nx相当于占位符，下面递归中每次只用得到其中一个
        if(!root) return true;
        if(root->val <= mn || root->val >= mx) return false;
        return helper(root->left,mn,root->val) && helper(root->right,root->val,mx);
    }
```

上面的递归只能判断左<根<右的情况。  

如果遇到有的题目将二叉搜索树定义为左<=根<右，则只能换种方法
```CPP
public:
    bool isValidBST(TreeNode* root) {
        TreeNode *pre = NULL;
        return inorder(root, pre);
    }
private:
    bool inorder(TreeNode* node, TreeNode*& pre) {
        if (!node) return true;
        bool res = inorder(node->left, pre);
        if (!res) return false;
        if (pre) {
            if (node->val <= pre->val) return false;    //单独用这个条件来判断
        }
        pre = node;
        return inorder(node->right, pre);
    }
```

### 构造二叉搜索树

### 简单构造——将有序序列转换为二叉搜索树
**思路**  
- 使用二分法找到有序序列的中点，将该中点值设为root->val，递归构造左子树\[left,mid - 1]、右子树\[mid + 1,right]。  

以下两题思路一致，唯一区别是数组和链表二分法找中点的方式不同。  

#### leetcode 108. 将有序数组转换为二叉搜索树
```CPP
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums,0,nums.size() - 1);
    }

private:
    TreeNode* helper(vector<int>& nums,int left,int right){
        if(left > right) return nullptr;
        int mid = left + (right - left) / 2;
        TreeNode *p = new TreeNode(nums[mid]);
        p->left = helper(nums,left,mid - 1);
        p->right = helper(nums,mid + 1,right);
        return p;
    }
```
#### leetcode 109. 有序链表转换二叉搜索树
略。  

### 复杂构造——构造所有可能的二叉搜索树
#### leetcode 96. 不同的二叉搜索树
求以 1 ... n 为节点组成的二叉搜索树有多少种。  

这道题实际上是卡塔兰数，即存在通项式，找到通项式解法就很简单。  
 
#### leetcode 95. 不同的二叉搜索树 II
给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。  

**思路**  

- 将区间 \[1, n] 当作一个整体，然后需要将其中的每个数字都当作根结点，其划分开了左右两个子区间，分别调用递归函数
- 以上会得到两个结点数组，接下来要做的就是从这两个数组中每次各取一个结点，当作当前根结点的左右子结点，然后将根结点加入结果res数组中  
- 注意：递归返回的为子树数组  

```cpp
public:
    vector<TreeNode*> generateTrees(int n) {
        if (n == 0) return {};
        return helper(1, n);
    }
private:
    vector<TreeNode*> helper(int start, int end) {
        if (start > end) return {nullptr};
        vector<TreeNode*> res;
        for (int i = start; i <= end; ++i) {
            auto left = helper(start, i - 1), right = helper(i + 1, end);
            for (auto a : left) {
                for (auto b : right) {
                    TreeNode *node = new TreeNode(i);
                    node->left = a;
                    node->right = b;
                    res.push_back(node);
                }
            }
        }
        return res;
    }
```
此题还可用记忆数组（三维数组）中来记录中间结果，用空间换时间。  


### 修改二叉搜索树
#### leetcode 99. 恢复二叉搜索树
二叉搜索树中的两个节点被错误地交换。在不改变其结构的情况下，恢复这棵树。   
**思路** 
- 主要是找两个被错误交换的节点，找到pre > cur的第一个节点和最后一个节点即可
- 不过需要注意的是这两个节点可能不是相连的节点  

```CPP
public:
    void recoverTree(TreeNode* root) {
        if(!root) return;
        TreeNode* first = nullptr;
        TreeNode* second = nullptr;
        TreeNode* pre = nullptr;
        helper(root,pre,first,second);
        swap(first->val,second->val);
    }

private:
    void  helper(TreeNode* cur,TreeNode* &pre,TreeNode* &first,TreeNode* &second){
        if(!cur) return;
        helper(cur->left,pre,first,second);
        if(pre && pre->val > cur->val){
            if(!first) first = pre; //找到第一个pre->val > cur->val的节点first
            second = cur;   //找到第最后一个pre->val > cur->val的节点second
        }
        pre = cur;
        helper(cur->right,pre,first,second);
    }
```

## 构造二叉树
- leetcode 105. 从前序与中序遍历序列构造二叉树
- leetcode 106. 从中序与后序遍历序列构造二叉树
- leetcode 889. 根据前序和后序遍历构造二叉树


## 修改二叉树(涉及到节点指针的修改，最难)

### leetcode 114. 二叉树展开为链表
这一题的示例是将二叉树展开成先序顺序的链表，而且保留右指针，去掉左指针。  

【注意】以上要求非常重要，决定了后面代码的思路。  

#### 思路（按照上面的要求最容易找到的思路）
- 如果不存在左子节点，则满足题目要求，则继续访问右子节点
- 如果存在左子节点，那么此时找到左子树先序遍历的最后一个节点（即最右节点），将其右指针连到右子节点上
- 此时可以断开右指针，来指向左子节点，并将左指针置空

按此思路的递推写法（此思路最简单）
```CPP
void flatten(TreeNode *root) {
    TreeNode *cur = root;
    while (cur) {
        if (cur->left) {    //存在左子节点
            TreeNode *p = cur->left;    
            while (p->right) p = p->right;  //找到左子树先序遍历的最后一个节点
            p->right = cur->right;  //将其右指针连到左边子节点上
            cur->right = cur->left; //让cur的右指针指向左节点
            cur->left = NULL;   //此时左指针已没用，置为空
        }
        cur = cur->right;   //继续向右修改节点
    }
}
```

递归写法(和上面思路一样，只不过是从下往上修改节点)
```CPP
void flatten(TreeNode *root) {
    if (!root) return;
    if (root->left) flatten(root->left);
    if (root->right) flatten(root->right);
    TreeNode *tmp = root->right;    //记录root节点的右子节点
    root->right = root->left;   //让右指针指向左节点
    root->left = NULL;  //此时左指针已没用，置为空
    while (root->right) root = root->right; //找到左子树先序遍历的最后一个节点
    root->right = tmp;  //将最后一个节点的右指针指向tmp
}
```

神仙写法
```CPP
public:
    void flatten(TreeNode* root) {
        helper(root,NULL);
    }
private:
    TreeNode* helper(TreeNode* root,TreeNode* tail){    //从右下往左上修改，root为当前节点，tail为root先序遍历的下一个节点
        if(!root) return tail;
        root->right = helper(root->left,helper(root->right,tail));  //找到root先序遍历的下一个节点，并将其右指针指向它
        root-> left = NULL; //左指针置空
        return root;
    }
```

### 采用层次遍历进行节点修改的技巧

#### 链表修改的技巧
为了标准化对节点的修改动作，链表的通用方法是构建一个新的节点pre_head，指向head节点，然后从pre_head开始可以标准化修改流程，修改完毕后返回pre_head->next即可。  

#### 从链表引申到树节点的修改
树的层次遍历也可采用上述思路，因为层次遍历相当于横向修改多个链表。    

构建一个新的节点tmp，当每次访问到新的一层时，让tmp指向该层的第一个节点，后续修改操作标准化即可，会变得非常简单！  

下题就是一个很好的例子。  

#### leetcode 117. 填充每个节点的下一个右侧节点指针 II 
此题中树的节点增加了一个指向同一层下一个节点的next指针。  

```CPP
Node* connect(Node* root) {
    Node *tmp = new Node(0, NULL, NULL, NULL), *cur = tmp, *head = root;
    while (root) {
        if (root->left) {   //如果左子节点存在，那么让cur指针指向左子节点
            cur->next = root->left;
            cur = cur->next;
        }
        if (root->right) {  //如果右子节点存在，那么让cur指针指向右子节点
            cur->next = root->right;
            cur = cur->next;
        }
        root = root->next;  //找到该层的下一个节点
        if (!root) {    //如果该层不存在节点，那么再定位到下一层的第一个节点
            cur = tmp;  //此时的tmp的next指向的是root层下一层的第一个节点
            root = tmp->next;
            tmp->next = NULL;
        }
    }
    return head;
}
```

# 贪心
- 选取一个贪心策略，并利用此策略在解空间中直接找到一条最优解路径。 
- 选取的贪心策略需要额外的证明，来证实该策略能得到最优解。  
- 贪心策略的时间复杂度和空间复杂度一般来说是最低的。  

## 一维空间（数组）的贪心

### leetcode 55. 跳跃游戏
贪心策略：并不关心每一个位置上的剩余步数，而只希望知道能否到达末尾，也就是说只对最远能到达的位置感兴趣。  

空间复杂度为O(1)，而动态规划的空间复杂度为O(N)。  

```CPP
bool canJump(vector<int>& nums) {
    int max_step = 0,n = nums.size();
    for(int i = 0;i < n;i++){
        if(i > max_step || max_step >= n - 1) break;    //如果存在阻碍点or最大范围超过终点，直接退出循环
        max_step = max(max_step, i + nums[i]);
    }
    return max_step >= n - 1;
}
```
### leetcode 45. 跳跃游戏 II
贪心策略：根据当前位置，贪出一个最远的范围，在遍历这个范围的过程中，更新下一步跳跃的最远范围；一旦当这个范围到达末尾时，当前所用的步数一定是最小步数。  

空间复杂度为O(1)，而动态规划的空间复杂度为O(N)。 

代码略。  

### 买卖股票的最佳时机

# 动态规划
## 场景动态规划
### 剑指 Offer 60. n个骰子的点数
#### 解法1：二维动态规划
```CPP
vector<double> twoSum(int n) {
    int m = 6 * n;
    vector<vector<int>> dp(n,vector<int>(m + 1,0));
    vector<double> res;

    for(int i = 1;i <= 6;i++) dp[0][i] = 1; //初始化边界

    for(int i = 1;i < n;i++){   //双for循环构建dp数组
        for(int j = i + 1;j <= (i + 1) * 6;j++){    
            for(int k = 1;k <= 6;k++){
                if(j > k) dp[i][j] += dp[i - 1][j - k]; //动态转移方程
                else break;
            }
        }
    }

    int total = pow(6,n);
    for(int i = n;i <= m;i++){
        res.push_back(dp[n - 1][i] * 1.0 / total);  //得到结果
    }
    return res;
}
```
#### 解法2：将二维动态规划降维，降到一维动态规划
思路与上述基本一致，但有个地方需要注意：  
- 如果第i层的下标范围与第i+1层的下标范围有重叠，那么在更新第i+1层值的时候，必须要先将dp\[pos]的值先初始化，防止上一层的中间结果干扰
- 比如本题中第i层的下标范围为\[i,6 * i]，第i+1层的下标范围为\[i + 1,6 * (i + 1)]，下标范围有重叠
```CPP
vector<double> twoSum(int n) {
    int m = n * 6;
    vector<int> dp(m + 1,0);

    for(int i = 1;i <= 6;i++) dp[i] = 1;

    for(int i = 2;i <= n;i++){
        for(int j = i * 6;j >= i;j--){  //降维时，必须从右往左更新
            dp[j] = 0;  //下标范围重叠，因此需要初始化
            for(int k = 1;k <= 6;k++){
                if(j - k >= i - 1)  //在符合该层的下标范围内，才能进行动态转移
                    dp[j] += dp[j - k];
                else break;
            }
        }
    }

    int total = pow(6,n);
    vector<double> res;
    for(int i = n;i <= m;i++){ 
        res.push_back(dp[i] * 1.0 / total);
    }

    return res;
}
```

## 字符串类型动态规划
## 和字符串匹配类型思路一致的数组题（二维动态规划）
### leetcode 718. 最长重复子数组
标准二维动态规划写法：  
```CPP
int findLength(vector<int>& A, vector<int>& B) {
    int m = A.size(),n = B.size();
    int res = 0;
    vector<vector<int>> dp(m,vector<int>(n,0));
    
    //初始化
    for(int i = 0;i < m;i++)
        if(A[i] == B[0]) dp[i][0] = 1;
    for(int j = 0;j < n;j++) 
        if(A[0] == B[j]) dp[0][j] = 1;

    //双for循环
    for(int i = 1;i < m;i++){
        for(int j = 1;j < n;j++){
            if(A[i] == B[j]){
                dp[i][j] = 1 + dp[i - 1][j - 1];    //最简单的动态转移方程
                res = max(res,dp[i][j]);
            }
        }
    }
    return res;
    }
```

将二维动态规划降到一维（从右向左更新）：
```CPP
int findLength(vector<int>& A, vector<int>& B) {
    int m = A.size(),n = B.size();
    int res = 0;
    vector<int> dp(n,0);

    for(int i = 0;i < m;i++){
        for(int j = n - 1;0 <= j;j--){  //从右向左更新，防止之前的值被覆盖
            if(A[i] == B[j]){
                dp[j] =  j > 0 ? 1 + dp[j - 1] : 1; //动态转移方程
                res = max(res,dp[j]);
            }else dp[j] = 0;    //从二维降到一维，这一步必须更新
        }
    }
    return res;
}
```


## 两个字符串比较（匹配、查找）—二维动态规划
这类题目一般都可以用递归、动态规划来做，但是直接用递归相当于暴力解，一般这种情况会直接超时。因此需要对递归进行优化。  

其实递归和动态规划都是在暴力解的基础上进行了一定的优化，主要优化点在于使用一个一维/二维的数组存储中间过程的结果，以空间换时间。  



### leetcode 97. 交错字符串
#### 双for循环动态规划
标准的二维动态规划处理思路：
- 初始化以x = 0行的数组和y = 0列数组
- 2个for循环，循环内部是动态转移方程
- 返回结果
```CPP
bool isInterleave(string s1, string s2, string s3) {
    if (s1.size() + s2.size() != s3.size()) return false;
    int n1 = s1.size(), n2 = s2.size();

    vector<vector<bool>> dp(n1 + 1, vector<bool> (n2 + 1));     //创建二维dp数组

    //边界初始化
    dp[0][0] = true;

    for (int i = 1; i <= n1; ++i) {
        dp[i][0] = dp[i - 1][0] && (s1[i - 1] == s3[i - 1]);
    }
    for (int i = 1; i <= n2; ++i) {
        dp[0][i] = dp[0][i - 1] && (s2[i - 1] == s3[i - 1]);
    }

    //2个for循环，循环内部是动态转移方程

    for (int i = 1; i <= n1; ++i) {
        for (int j = 1; j <= n2; ++j) {
            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i - 1 + j]) || (dp[i][j - 1] && s2[j - 1] == s3[j - 1 + i]);
        }
    }

    return dp[n1][n2];  //返回结果
}
```

其实以上思路看下来，动态规划只是在暴力for循环基础上维护了一个二维数组，用来存储中间结果，剪枝而已。  

#### 优化后的递归
递归思路也很模板化：
- 定义一个数组/hashmap，用来保存中间计算结果，剪枝
- 递归
   - 先判断之前是否计算过，如果计算过直接返回之前计算的结果
   - 如果没有计算过，则进行递归计算
   - 递归计算完毕后，将当前递归计算的结果保存在数组/hashmap中，便于后续剪枝
- 返回结果

```CPP
bool isInterleave(string s1, string s2, string s3) {
    if (s1.size() + s2.size() != s3.size()) return false;
    unordered_set<int> s;   //定义一个hashmap，用来保存中间计算结果
    return helper(s1, 0, s2, 0, s3, 0, s);
}
bool helper(string& s1, int i, string& s2, int j, string& s3, int k, unordered_set<int>& s) {
    int key = i * s3.size() + j;
    if (s.count(key)) return false; //如果之前计算过，直接返回
    if (i == s1.size()) return s2.substr(j) == s3.substr(k);
    if (j == s2.size()) return s1.substr(i) == s3.substr(k);
    if ((s1[i] == s3[k] && helper(s1, i + 1, s2, j, s3, k + 1, s)) || 
        (s2[j] == s3[k] && helper(s1, i, s2, j + 1, s3, k + 1, s))) return true;
    s.insert(key);  //将上面步骤的中间计算结果保存在hashmap中
    return false;
}
```

递归也只是在暴力递归的基础上，使用了一个数组/hashmap来保存中间结果，进行剪枝。  


### leetcode 139. 单词拆分—判断是否匹配
#### trick：如果题目给出一个字符串字典，但是是用vector保存，可以先将其转移到hashmap中，这样后续的查找时间复杂度就为O(1)了
#### 双for循环动态规划
尽管给出的字符串是一维的，但是如果需要将字符串分解成两阶段，还是需要两个for循环：
- 第一个for用来遍历dp
- 第二个for循环遍历两阶段的中间边界，并且进行左右判断
```CPP
bool wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
    
    vector<bool> dp(s.size() + 1);  //定义dp数组
    dp[0] = true;   //一维dp数组直接初始化，而不用像二维那样还需要for循环进行初始化
    
    for (int i = 0; i < dp.size(); ++i) {   //dp数组从前往后循环   
        for (int j = 0; j < i; ++j) {   //j为两阶段边界，j以前是用dp[j]表示是否为word，j之后用字典判断是否为word
            if (dp[j] && wordSet.count(s.substr(j, i - j))) {   //动态转移方程
                dp[i] = true;   //保存中间结果
                break;
            }
        }
    }
    return dp.back();
}
```
#### 优化后的递归
- 定义一个数组，用来保存中间计算结果，剪枝
- 递归
   - 先判断之前是否计算过，如果计算过直接返回之前计算的结果
   - 如果没有计算过，则进行递归计算
   - 递归计算完毕后，将当前递归计算的结果保存在数组中，便于后续剪枝
- 返回结果
```CPP
bool wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
    vector<int> memo(s.size(), -1);
    return check(s, wordSet, 0, memo);
}
bool check(string s, unordered_set<string>& wordSet, int start, vector<int>& memo) {
    if (start >= s.size()) return true;
    if (memo[start] != -1) return memo[start];  //如果当前起始位置已经计算过，直接返回计算结果
    for (int i = start + 1; i <= s.size(); ++i) {   //循环计算
        if (wordSet.count(s.substr(start, i - start)) && check(s, wordSet, i, memo)) {  //递归和递推相反，得先一直递归下去，从后往前返回memo数组
            return memo[start] = 1; //返回当前计算结果
        }
    }
    return memo[start] = 0; //返回起始计算结果
}
```
### leetcode 140. 单词拆分 II—返回匹配的所有结果
#### trick：当题目要求最终返回一个二维数组/一维数组时，此时递归结果可以返回二维数组/一维数组，并在递归中接收该返回的数组，并进行进一步处理，这种思路适合那种要求返回所有结果的题目
以下整体思路和上面一样，只不过使用了上面的trick
```CPP
unordered_map<string, vector<string>> m;
vector<string> wordBreak(string s, vector<string>& wordDict) {
    if (m.count(s)) return m[s];    //递归到边界，直接返回
    if (s.empty()) return {""};
    
    vector<string> res;
    for (string word : wordDict) {
        if (s.substr(0, word.size()) != word) continue;
        
        vector<string> rem = wordBreak(s.substr(word.size()), wordDict);    //接收之前递归返回的结果数组
        
        for (string str : rem) {
            res.push_back(word + (str.empty() ? "" : " ") + str);   //对接收的结果数组进行进一步处理
        }
    }
    
    return m[s] = res;  //返回当前处理后的结果数组，并保存在动态数组中
}
```

## 回溯（面试官一般要求用递推求解！）
### leetcode 78. 子集
#### 递推写法
```CPP
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> res(1);
    for(auto num : nums){
        int size = res.size();
        for(int i = 0;i < size;i++){    //一边将之前的结果复制一份，一边更新复制出来新结果
            res.push_back(res[i]);  
            res.back().push_back(num);
        }
    }
    return res;
}
```

#### 递归写法
```CPP
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res(1); //初始化为1的目的是为了把空集也包含在其中，如果不需要空集，就不用初始化为1
        vector<int> vec;
        helper(nums,vec,res,0);
        return res;
    }

private:
    void helper(vector<int>& nums,vector<int>& vec,vector<vector<int>>& res,int start){
        if(start >= nums.size()) return;
        for(int i = start;i < nums.size();i++){ //递归所有情况，需要将插入和删除动作全放在for循环中
            vec.push_back(nums[i]);
            res.push_back(vec);
            helper(nums,vec,res,i + 1);
            vec.pop_back();
        } 
    }
```

### 上一题升级版
给定一个数组的数组，将其展开。换句话说，要求在每个数组里选择一个元素，n 个数组一共选择 n 个元素，找出所有的这种组合情况。 

```
举例：
    输入：
    [
        [1,3,4],
        [1],
        [2,4,5],
    ]

    输出：
    [
        [1,1,2],
        [1,1,4],
        [1,1,5],
        [3,1,2],
        [3,1,4],
        [3,1,5],
        [4,1,2],
        [4,1,4],
        [4,1,5],
    ]

要求：
不可以使用递归
仅可使用 O(n) 空间，n 为数组个数
只需要打印每种组合即可，不需要把所有结果返回
这道题主要考察「用迭代实现回溯法」，代码类似于迭代求解八皇后问题。
```

#### 递归写法（非常简单）
```CPP
void helper(vector<vector<int>>& nums,vector<int>& vec,int start);

int main(){
    vector<vector<int>> nums = {{1,3,4},{1},{2,4,5}};
    int n = nums.size();
    vector<int> vec(n);
    helper(nums,vec,0);
    return 0;
}

void helper(vector<vector<int>>& nums,vector<int>& vec,int start){
    if(start >= nums.size()){   //递归边界，打印结果
        int n = vec.size();
        for(int i = 0;i < n;i++){
            if(i == n - 1) cout << vec[i] << endl;
            else cout << vec[i] << ",";
        }
        return;
    }
    for(auto num : nums[start]){    //递归核心，一个for循环搞定
        int tmp = vec[num]; //保存变量，方便后续回溯
        vec[start] = num;
        helper(nums,vec,start + 1);
        vec[start] = tmp;
    }
}
```

#### 递推写法
```CPP
void permutations(vector<vector<int>>& nums,vector<vector<int>>& res,int total_size);

int main(){
        vector<vector<int>> nums = {{1,3,4},{1},{2,4,5}};
        int total_size = nums.size();
        vector<vector<int>> res(1,vector<int>(total_size,0));
        
        permutations(nums,res,total_size);
        
        for(auto num : res){
            for(int i = 0;i < num.size();i++){
                if(i == num.size() - 1) cout << num[i] << endl;
                else cout << num[i] << ",";
            }
        }
        return 0;
    }

void permutations(vector<vector<int>>& nums,vector<vector<int>>& res,int total_size) {
    for(int i = 0;i < total_size;i++){  //逐层递推
        int n = nums[i].size();
        int size = res.size();

        for(int k = 0;k < size;k++){    //逐层初始化第一个元素，直接利用之前的中间数组，而不需要新建额外的数组
                res[k][i] = nums[i][0];
            }

        for(int j = 1;j < n;j++){
            for(int k = 0;k < size;k++){    //（新建）复制之前的中间数组，再更新相应位置的元素
                res.push_back(res[k]);  
                res.back()[i] = nums[i][j];
            }  
        }
    }
}
```
### N皇后问题—LeetCode 51. N皇后
#### 递归解法（非常简单）
```CPP
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> res;
        vector<string> vec(n,string(n,'.'));
        helper(res,vec,n,0);
        return res;
    }

private:
    void helper(vector<vector<string>>& res,vector<string>& vec,int n,int start){
        if(start >= n){
            res.push_back(vec);
            return;
        }

        for(int i = 0;i < n;i++){   //逐层遍历
            if(is_correct(vec,n,start,i)){  //找到该层满足N皇后条件的位置，将该字符调为'Q'，并进行下一层的遍历
                vec[start][i] = 'Q';
                helper(res,vec,n,start + 1);
                vec[start][i] = '.';    //返回该层后，将该位置元素还原
            }
        }
    }

    bool is_correct(vector<string>& vec,int n, int x, int y){   //每行只会有一个位置被置为Q，因此不需要行判断
        for(int i = 0;i < n;i++){   //因为是按层从上往下遍历，所以只用判断该层上面的节点即可（层下节点全为空）
            if(i < x && vec[i][y] == 'Q') return false;     //判断列

            if(i <= x && i <= y && vec[x - i][y - i] == 'Q') return false;  //判断左上-右下的斜线

            if(i <= x && i + y <= n && vec[x - i][y + i] == 'Q') return false;  //判断左下-右上的斜线
        }
        return true;
    }
```
