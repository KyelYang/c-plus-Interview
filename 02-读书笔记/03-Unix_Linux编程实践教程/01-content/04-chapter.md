# 第四章 文件系统：编写pwd

## 从用户的角度看文件系统

### ln命令
生成对一个已存在文件的一个硬链接（一个连接是指向该文件的一个指针），并且该文件的链接数加一  

### 针对目录树的命令
#### ls -R
ls命令用来列出目录的内容，选项-R要求列出指定目录及其子目录的所有内容。但没有tree命令直观  

#### chmod -R
chmod命令用来修改文件的许可权限位，选项-R求修改子目录中所有文件的许可权限。

#### du
du是disk usage（硬盘使用）的缩写，该命令给出指定目录及其子目录下所有文件占用硬盘中数据块的总数。

### 目录树的深度几乎没有限制
目录能够包含多个文件和子目录。系统并未对目录树的深度加以限制。但是，有可能所建的目录树太深以至超过许多命令允许的范围。  


## Unix文件系统的内部结构
硬盘实际上是由一些磁性盘片组成的计算机系统的一个设备。文件系统是对该设备的一种多层次的抽象。
### 第一层抽象：从磁盘到分区
一个磁盘能够存储大量的数据。就像一个国家能被划分成州或县，一个磁盘可被划分成分区，以便在一个大的实体内创建独立的区域。每个分区都可以看作是一个独立的磁盘。  
### 第二层抽象：从磁盘（分区）到块序列
一个硬盘由一些磁性盘片组成。每个盘片的表面都被划分为很多同心圆，这些同心圆称作磁道，每个磁道又进一步被划分成扇区，就像郊外的街道被划分成居住单元。每个扇区可以存储一定字节数的数据，例如每个扇区有512字节。扇区是磁盘上的基本存储单元，现在的磁盘包含大量的扇区。  

一个将磁盘扇区编号的系统使得我们可以把磁盘视为一系列块的组合。  

### 第三层抽象：从块序列到三个区域的划分
Unix使用了一个简单的方法。它将这些磁盘块分成了3部分。
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/23.jpg" width = 60% height = 60% /></div> 

#### 超级块
文件系统中的第一个块被称为超级块。这个块存放文件系统本身的结构信息。例如，超级块记录了每个区域的大小。超级块也存放未被使用的磁盘块的信息。不同版本Unix的超级块的内容和结构稍有不同。  

#### i-节点表
文件系统的下一个部分被称为i-节点表。每个文件都有一些属性，如大小、文件所有者和最近修改时间等。这些性质被记录在一个称为i-节点的结构中。所有的i-节点都有相同的大小，并且i-节点表是这些结构的一个列表。  

系统中的每个文件在该表中都有一个i-节点。  

以下这一点很重要：表中的每个i-节点都通过位置来标识。例如，标识为2的i-节点(inode 2)位于文件系统i-节点表中的第3个位置。（和数组下标从0开始一样）

#### 数据区
文件系统的第3个部分是数据区。文件的内容保存在这个区域。磁盘上所有块的大小都是一样的。如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中。一个较大的文件很容易分布在上千个独立的磁盘块中。


### 文件系统的实现：创建一个文件的过程
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/24.jpg" width = 60% height = 60% /></div>  

#### 1.存储属性
文件属性的存储：内核先找到一个空的i-节点。图中，内核找到i-节点47。然后内核把文件的信息记录其中。  

#### 2.存储数据
文件内容的存储：该新文件需要3个存储磁盘块，因此内核从自由块的列表中找出3个自由块。它找到块627、200和992。内核缓冲区的第一块数据复制到块627,下一块数据复制到块200,最后一块数据复制到块992。  

#### 3.记录分配情况
文件内容按顺序存放在块627、200和992中。内核在i-节点的磁盘分布区记录了上述的块序列。磁盘分布区是一个磁盘块序号的列表，这3个编号放在最开始的3个位置。  

#### 4.添加文件名到目录
新文件的名字是userlist。Unix如何在当前的目录中记录这个文件？  

答案很简单。内核将入口（47,userlist）添加到目录文件。文件名和i-节点号之间的对应关系将文件名和文件的内容及属性连接了起来。  

### 文件系统的实现：目录的工作过程
目录是一种包含了文件名字列表的特殊文件。不同版本的Unix目录的内部结构不同，但是它们的抽象模型总是一致的——一个包含i
-节点号和文件名的表。  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/25.jpg" width = 60% height = 60% /></div>  

#### 探讨目录内部  
可以通过命令ls -1ia（选项第一位是数字1）来查看目录的内容。  
- 选项-i告诉ls在列表中包含i-节点号  
- 选项-1要求每行列出一个文件  
- 选项-a要求列出隐藏文件  

#### 指向同一文件的多重链接  
- 若两个不同的文件名拥有相同的i-节点号，则两个文件都指向同一个i-节点。i-节点实际上代表了一个文件，i-节点包含了文件的属性和数据块的列表。因此，它们为同一文件的两个不同名字。  
- 在根目录中"."和".."的i-节点相同。当前目录怎么会和父目录相同呢？实际上在大多数情况下，它们是不同的，但根目录比较特别，当用Unix命令mkfs创建了一个文件系统，mkfs将根目录的父目录指向自己。  

### 文件系统的实现：cat命令的工作原理
#### 在目录中寻找文件名
文件名存储在目录文件中。内核在目录文件中（数据区域）寻找包含字符串userlist的记录，并读取i-节点值。 
#### 定位i-节点47并读取其内容
内核在文件系统中的i-节点区域找到i-节点47。定位一个i-节点可能需要一些简单的计算，所有的i-节点大小相同，每个磁盘块都包含相同数量的i-节点。为了提髙访问效率，内核有可能将i-节点置于缓冲区中。i-节点47包含数据块编号的列表。
#### 访问存储文件内容的数据块
通过以上过程，内核已经可以知道文件内容存放在哪些数据块上，以及它们的顺序。由于cat不断地调用read函数，使得内核不断将字节从磁盘复制到内核缓冲区，进而到达用户空间。  

### open调用的具体过程
所有从文件读取数据的命令，例如cat、cp、more、who等，都是将文件名传给open来访问文件内容。对open的每次调用都是先在目录中寻找文件名，然后根据目录中的i-节点号获得文件的属性，最终找到文件的内容。  

#### 如果在open一个没有读或写权限的文件时将发生什么情况
内核首先根据文件名找到i-节点号，然后根据i-节点号找到i-节点。在i-节点中，内核找到文件的权限位和拥有者的用户ID。如果权限位设置你的用户ID对文件没有访问权限，则open返回-1并且将全局变量errno的值设为EPERM。  

### 一个固定大小的i-节点如何存储较长的分配列表?
解决方案：将分配列表的大部分存储在数据块，在i-节点中存放指向那些块的指针。（和多级页表一样的思路）  

由于大文件的存储管理需要更多的开销，因此这样的磁盘分配系统对小文件来说是快捷髙效的。当文件大小逐步增长时，内核使用更多的磁盘空间去维护越来越长的分配列表。在文件中定位一个特定的位置可能需要获取若干个间接块以得到数据块的编号。

## Unix文件系统的问题和改进
### 超级块问题
如果某个超级块损坏了，则整个文件系统的结构信息就没有了。  

解决办法：新版本的Unix在文件系统中备份了这个块的副本。

### 分块问题
由于文件的创建和删除，自由块将遍布磁盘。  

解决办法：一种方案是在文件系统中创建被称为柱面组(cylinder group)的微文件系统。  

### 但是这个经典的模型并未过时  
文件仍旧存储在数据区的块中，文件属性仍旧存储在i-节点表中的i-节点中，i-节点包含着磁盘的分配列表。  

## 理解目录结构
在文件系统内部，目录是一个包含文件名与i-节点对的列表的文件。从用户的角度看到的是一个文件名的列表，而从Unix的角度看到的是一个被命名的指针的列表。  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/26.jpg" width = 60% height = 60% /></div>

### “文件在目录中”的真正含义
从用户的角度来看，文件y在目录demodir中；而从系统角度来看，看到的则是目录中有一个包含文件名y和i-节点号为491的入口。  
类似地，“文件x在目录a中”意味着在目录a中有一个指向i-节点402的链接，这个链接所附加的文件名为x。  

简短地说，目录包含的是文件的引用，每个引用被称为链接。  

### “目录包含子目录”的真正含义
从用户的角度来看，目录a是目录demodir的一个子目录，那么在系统内部究竟是如何运作的呢？  实际上demodir包含一个指向那个子目录i-节点的链接。  

从系统角度来看，最上面一个表包含一个指向i-节点277的链接，称为a。如何知道277是左边那个目录的i-节点号呢？  

每个目录都有一个i-节点，内核在每个目录都设置一个指向目录本身的i-节点的入口；这个人口被称为"."。在左边的小方框中，点表示i-节点277,因此左边的目录表示i-节点277。  

### “目录有一个父目录”的真正含义
同上同理，".."是父目录保留的名字。  

### 多重链接及链接数
在demodir目录树中，i-节点402有两个链接。一个是在目录a中，称为x,另一个在目录dl中，称为xlink。那么哪个是原始文件？哪个是指向它的链接呢？  

在Unix的目录结构中，这两个链接的状态完全相同；它们被称为指向文件的硬链接。文件是一个i-节点和一些数据块的结合；链接是对i-节点的引用。可以对一个文件创建任意多的链接。  

内核记录了一个文件的链接数。就i-节点402来说,链接数至少是2。因为在文件系统的其他部分或许还存在着i-节点402的其他链接。链接数被记录在i-节点中，同时是系统调用stat返回值stat结构中的一个成员。  

### 文件名
在Unix的文件系统中，文件没有文件名，但是链接具有名字。文件仅仅拥有i-节点号。在后面的章节中，可看到这种方法的便利之处。  

## 与目录树相关的命令和系统调用
Unix文件系统的内部结构比较简单，仅仅是一些相互链接的数据结构。节点被称为i-节点，指针的集合被称为目录，叶子节点被称为链接。  

### mkdir
命令mkdir用来创建新的目录。它接受命令行上的一个或多个目录名，使用mkdir系统调用。  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/27.jpg" width = 60% height = 60% /></div>
mkdir创建一个新的目录节点并把它链接至文件系统树。即mkdir创建了这个目录的i-节点；分配了一个磁盘块用以存储它的内容；在目录中设置两个入口："."和".."并正确配置了它们的i-节点号；在它的父目录中增加一个该节点的链接。  

### rmdir
命令rmdir用来删除一个目录。它接受命令行上一个或多个目录名，使用rmdir系统调用。 
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/28.jpg" width = 60% height = 60% /></div>  

rmdir从目录树中删除一个目录节点。这个目录必须是空的。即除了"."和".."的入口，这个目录不能包含其他任何的文件和子目录。同时在父目录中删除这个目录的链接。如果这个目录本身并未被其他的进程占用，它的卜节点和数据块将被释放。  

### rm
命令rm用来从一个目录文件中删除一个记录，它接受命令行上一个或多个文件名，使用unlink系统调用。  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/29.jpg" width = 60% height = 60% /></div>  

unlink用来删除目录文件中的一个记录，减少相应i-节点的链接数。如果该i-节点的链接数减为0,数据块和i-节点将被释放。如果该i-节点有其他的链接，则数据块和i-节点将不受影响。unlink不能被用来删除目录。  

### ln
命令ln用来创建一个文件的链接，使用系统调用link。  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/30.jpg" width = 60% height = 60% /></div>  

link生成一个i-节点的链接。新链接包含原始链接的i-节点号并且具有特定的名字。如果已经存在一个和新链接名相同的链接，则link将失败。link不能被用来生成目录的新链接。  

### mv
命令mv用来改变文件和目录的名字或位置，是这小节中所讲述的最为灵活的一个命令。在很多情况下，mv 仅仅使用系统调用rename。  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/31.jpg" width = 60% height = 60% /></div>  

rename用来改变文件或目录的名字或位置。例如,rename("y","y.old")用来改变文件的名字，而rename("y","c/d2/y.old")用来改变文件的名字和位置。rename适用于文件和目录，但是在进行目录移动时有些限制。例如，不能将一个目录移动到它的子目录中去。和link不同，rename将删除第一个参数所指定的已存在的文件或空目录。  

rename是如何将一个文件移动到另一个目录的呢？  

文件实际上并不存在于目录中，目录中存放的仅仅是它的链接。因此rename将链接从一个目录移动到另一个目录。  

在Linux内核,rename的基本逻辑是：  
- 复制链接至新的名字/位置
- 删除原来的链接
因此，rename("x"，"z")是这样运作的
```CPP
if(link("x","z") != -1)
  unlink("x");
```

### cd
cd用来改变进程的当前目录。cd对进程产生影响，但是并不影响目录。 
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/32.jpg" width = 60% height = 60% /></div>  

Unix上的每个运行程序都有一个当前目录，chdir系统调用改变进程的当前目录。在系统内部，进程有一个存放当前目录i-节点号的变量。从一个目录进人另一个目录只是改变那个变量的值。  

## 编写pwd思路
- 得到当前路径的i-节点号，调用stat(cur_filename,&info)，返回的i-节点（info.st_ino）称其为node
- 使用chdir("..")改变当前目录至父目录中
- 找到i-节点node链接的名字（调用opendir、readdir、closedir）
- 重复以上过程（使用递归），直到到达树的顶端（当"."和".."指向同一个i-节点时），再逐个将i-节点node链接的名字打印出来

## 符号链接（了解即可）
硬链接(hard links)是将目录链接到树的指针，硬链接同时也是将文件名和文件本身链接起来的指针。  

硬链接不能指向其他系统中的i-节点，即使根也不能生成到目录的链接。也许有支持这种跨系统链接的理由，但Unix支持另一种形式的链接：符号链接。  

符号链接通过名字引用文件，而不是i-节点号。具体介绍见P119


