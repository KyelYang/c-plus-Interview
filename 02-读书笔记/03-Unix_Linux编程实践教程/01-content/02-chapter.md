# 第二章 用户、文件操作与联机帮助：编写who命令

### who命令工作流程  
- 调用open，打开头文件/usr/include/utmp.h
- 调用read，读取utmp.h文件中的登录用户的用户信息
  - utbufp->ut_name：登录名
  - utbufp->ut_line：tty
  - utbufp->ut_time：登录时间
- 调用ctime函数将time_t格式的时间data改成符合要求的时间格式

### cp命令工作流程：cp file_in file_out
- 调用open，打开待复制文件file_in
- 调用creat，创建复制后的目的文件file_out
- 调用read命令读取file_in文件中的内容（内核缓冲区从file_in文件中读取内容），并将数据暂存在内核缓冲区中
- 调用write命令将内核缓冲区的内容读到用户缓冲区中，然后将用户缓冲区中的暂存数据写到file_out文件中  


### Unix命令的阅读手册
Unix的联机帮助分为很多节，如第1小节中是关于用户命令的帮助，第2小节中是关于系统调用的帮助，第5小节是关于配置文件的帮助  

可以通过查看Unix系统的联机帮助，了解其他节讲述的内容  

```
man who  //查看联机帮助的命令是man，如要查看who的帮助，输入以上命令
```
###  编写命令程序的思路（比如现要找一个效率较高的读数据结构的方法）
- 阅读联机帮助  
- 搜索联机帮助  
- 阅读.h文件  
- 从参阅部分（SEE ALSE）得到启示  

```
$ man -k file | grep read  //查找和file有关的read调用接口
$ man 2 read  //其中最有可能的是read(2)，其他的看起来都不像，所以进一步地看read(2)的帮助
$ man 2 open  //查看read(2)帮助文档时，了解到read接口得传入一个文件描述符，但是如何获取文件描述符不太清楚，这时候可能需要用到open(2)接口
//把相关接口都了解清楚以后，就可以开始编写命令程序了
```
### Unix命令的执行文件和头文件
Unix命令的执行文件多大放在/bin，/usr/bin，/usr/local/bin目录下  

在Unix系统中，大多数的头文件都存放在/usr/include这个目录里  

#### 登录信息会被记录在utmp文件中

#### /bin/tty 是终端文件，对终端的读写操作和对一个普通文件的读写是一样的
```
cp filename /bin/tty  //该命令最终的效果是将filename文件的内容打印到终端
cp /bin/tty filename  //该命令最终的效果是将用户输入在终端的信息写到filename文件中
```

### 缓冲区的大小对性能有影响吗？为什么系统调用需要很多时间？
缓冲区的大小对性能有很大的影响，因为如果缓冲区很小，就会显著增加系统调用的次数。但系统调用是需要时间的，程序中频繁的系统调用会降低程序的运行效率。  

应用缓冲技术对提高系统的效率是很明显的，它的主要思想是一次读入大量的数据放入缓冲区，需要的时候从缓冲区取得数据。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/08.jpg" width = 50% height = 50% /></div> 

图中用户进程位于用户空间，内核位于系统空间，磁盘只能被内核直接访问。程序cpl要读取磁盘上的数据只能通过系统调用read，而read的代码在内核中，所以当read调用发生时，执行权会从用户代码转移到内核代码，执行内核代码是需要时间的。  

系统调用的开销大不仅仅是因为要传输数据，当运行内核代码时，CPU工作在管理员（supervisor,又称超级用户）模式，这对应于一些特殊的堆栈和内存环境，必须在系统调用发生时建立好。系统调用结束后（read返回时）,CPU要切换到用户模式，必须把堆栈和内存环境恢复成用户程序运行时的状态，这种运行环境的切换要消耗很多时间。  

当工作在管理员模式下，程序可以直接访问磁盘、终端、打印机等设备，还可以访问全部的内存空间，而在用户模式，程序不能直接访问设备，也只能访问特定部分的内存空间。在运行时刻，系统会根据需要不断地在两种模式间切换。管理员模式和用户模式的切换与CPU关系很大，CPU中有特定的标记来区分当前的工作模式，而Unix系统的设计必须考虑到CPU的这种特点，才能够实现不同工作模式间的良好切换。  

举个影片超人的例子，当肯特（生活中的超人）要从用户模式（普通人）切换到管理员模式（超人）时，他得先找个地方，比如电话亭，脱下西装，摘掉眼镜，再改变发型，变成超人后才能去拯救别人，事情完了以后，还得找个地方变回普通人。变来变去是需要时间的，要是肯特整天忙于变来变去，就不会有太多的时间来拯救人类了。  

在计算机的世界中也是一样，要是CPU把太多的时间消耗在执行内核代码和模式切换上，就不可能有很多时间来执行程序中业务逻辑的代码或提供系统服务，所以要尽可能地减少模式间的切换。  

### 同样，内核也要使用缓冲  

管理员模式和用户模式之间的切换需要消耗时间，相比之下，磁盘的I/O操作消耗的时间更多，为了提髙效率，内核也使用缓冲技术来提高对磁盘的访问速度。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/09.jpg" width = 50% height = 50% /></div> 


内核将磁盘上的数据块复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程的缓冲区中。 

当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加人到请求数据列表中，然后把该进程挂起，接着为其他进程服务。  

一段时间之后（很短），内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程的缓冲区中，最后唤醒被挂起的进程。  

理解内核缓冲技术的原理有助于更好地掌握系统调用read和write,read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们并不等价于数据在内核缓冲和磁盘之间的交换。  

从理论上讲，内核可以在任何时候写磁盘，但并不是所有的write操作都会导致内核的写动作。内核会把要写的数据暂时存在缓冲区中，积累到一定数量后再一次写人。有时会导致意外情况，比如突然断电，内核还来不及把内核缓冲区中的数据写到磁盘上，这些更新的数据就会丢失。  

应用内核缓冲技术导致的结果： 
- 提高磁盘I/O效率 
- 优化磁盘的写操作 
- 需要及时地将缓冲数据写人磁盘

#### 将缓冲区的数据同步到磁盘中的系统调用函数，防止异常产生导致缓冲区的数据没有写到文件中
```C
int fsync(int fd);
```

### 在文件操作中，如何改变一个文件的当前读/写位置？
使用系统调用lseek。  

当同时读写文件的时候，为了确保读写正常，往往需要用到lseek。

> 当需要替换文件中的部分内容时，先通过read搜索到匹配内容。当匹配完成时，指针会移动到当前匹配字符串的下一个位置，因此如果想要再调用write覆盖匹配的字符串时，需要将指针移动到该字符串的起始位置，因此必须得调用lseek。  

### 处理系统调用中的错误

#### 如果只需要显示错误信息，推荐使用perror(3)
perror(string)这个函数，它会自动查找错误代码，在标准错误输入中显示出相应的错误信息，参数string时要同时显示出描述性信息。  

显示的第一部分是用户传递进去的描述性信息，第二部分是根据错误代码查到的错误 提示。 

```C
perror("Cannot open file"); //报错信息：Cannot open file: Not such file or directory
```

#### 如果需要根据不同的错误做不同的处理，则推荐使用errno

内核通过全局变量errno来指明错误的类型，每个程序都可以访问到这个变量。在error(3)的联机帮助和errno.h中包含错误代码和相应的说明。  

当系统调用出错时，会把全局变量errno的值设位相应的错误代码，然后返回-1.程序可以通过检查errno来确定错误的类型，并采取相应的措施。
