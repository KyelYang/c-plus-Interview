# 第六章为用户编程：终端控制和信号

## 主要内容
- 有些程序处理从特定设备来的数据。这些与特定设备相关的程序必须控制与设备的连接。Unix系统中最常见的设备是终端。
- 终端驱动程序有很多设置。各个设置的特定值决定了终端驱动程序的模式。为用户编写的程序通常需要设置终端驱动程序为特定的模式。
- 键盘输入分为3类，终端驱动程序对这些输人做不同的处理。  
  - 大多数键代表常规数据，它们从驱动程序传输到程序。  
  - 有些键调用驱动程序中的编辑函数。如果按下删除键，驱动程序将前一个字符从它的行缓冲中删除，并将命令发送到终端屏幕，使之从显示器中删除字符。  
  - 有些键调用处理控制函数。Ctrl-C键告诉驱动程序调用内核中某个函数，这个函数给进程发送一个信号。终端驱动程序支持若干种处理 
控制函数，它们都通过发送信号到进程来实现控制。  

信号是从内核发送给进程的一种简短消息。信号可能来自用户、其他进程或内核本身。进程可以告诉内核，在它收到信号时需要做出怎样的响应。  

## 软件工具与针对特定设备编写的程序
### 软件工具：从stdin或文件读入，写到stdout  
对磁盘文件和设备文件不加以区分的程序被称为软件工具。Unix系统有好几百个软件工具，包括who、ls、sort、uniq、grep、tr和du。软件工具使用下图所示的模型。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/49.jpg" width = 60% height = 60% /></div>

软件工具从标准输人读取字节，进行一些处理，然后将包含结果的字节流写到标准输出。工具发送错误消息到标准错误输出，它们也被当做简单的字节流来处理。这些文件描述符能够连接到文件、终端、鼠标、光电管、打印机和管乐器；工具对所处理的数据的源和目的地不做任何假设。其他很多程序也能从命令行所指定的文件中读取数据。  

这些程序的输入和输出能够被重定向到任何类型的连接上：
```
$ sort > outputfile
$ sort x > /dev/lp
$ who | tr '[a-z]' '[A-Z]'
```

### 特定设备程序：为特定应用控制设备
其它程序（如控制扫描仪、记录压缩盘、操作磁带驱动程序和拍摄数码相片的程序）也能同特定设备进行交互。在本章中将通过了解最常见的与特定设备相关的程序（通过终端与人交互的程序）来探讨在写这些程序时用到的概念和技术。将这些面向终端的程序称为用户程序。  

### 用户程序：一种常见的设备相关程序
用户程序的例子有vi、emacs、pine、more、lynx、hangman、robots和许多的游戏程序。这些程序设置终端驱动程序的击键和输出处理方式。驱动程序有很多设置，但是用户程序常用到的有：
- 立即响应击键事件
- 有限的输入集
- 输入的超时
- 屏蔽 Ctrl-C

## 终端驱动程序的模式
当为Unix设计用户程序时，需要决定哪种终端模式适合这个应用。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/51.jpg" width = 60% height = 60% /></div>

### 规范模式
规范模式，也被称为cooked模式，是用户常见的模式。  

驱动程序输入的字符保存在缓冲区，并且仅在接收到回车键时才将这些缓冲的字符发送到程序。  

缓冲数据使驱动程序可以实现最基本的编辑功能，如删除字符、单词或整行。当用户分别按下删除键、单词删除键或是终止键时，这些功能就会被调用。被指派到这些功能的特定键在驱动程序里设置，可通过命令stty或系统调用tcsetattr来修改。

缓冲和编辑包含规范处理(canonical processing)。当这些特征被启动，终端连接被称为处于规范模式。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/50.jpg" width = 60% height = 60% /></div>

### 非规范模式
当缓冲和编辑功能被关闭时，连接被称为处于非规范模式。  

终端处理器仍旧进行特定的字符处理，例如，处理Ctrl-C及换行符和回车符之间的转换。但是，用于删除、单词删除和终止的编辑键没有特殊的意义，因此相应的输人被视作常规的数据输入。  

如果用非规范模式编写程序，并且希望用户能够编辑他们的输入，需要在你的程序中实现编辑功能。  

### raw模式
每个处理步骤都被一个独立的位控制。例如，ISIG位控制Ctrl-C键是否用于终止一个程序。程序可随意关闭所有这些处理步骤。  

当所有处理都被关闭后，驱动程序将输入直接传递给程序。在这种情况下，驱动程序被称为处于raw模式。在终端驱动程序更为简单的老版本系统中，有个特定的模式被称为raw模式。命令stty支持raw模式，将它作为命令行的一个选项。联机帮助上有关stty的部分解释了raw模式的含义。  

## 编写一个用户程序：play_again.c  
play_again.c的逻辑很简单：  
- 对用户显示提示问题
- 接受输入
- 如果是"y"，返回0
- 如果是"n"，返回1

### 1.例子：play_again0.c——完成上述功能
### 2.例子：play_again1.c——即时响应
### 3.例子：play_again2.c——忽略非法字符
### 4.例子：play_again3.c——使用非阻塞模式实现超时响应
#### 阻塞与非阻塞输入
当调用getchar或read从文件描述符读取输入时，这些调用通常会等待输人。程序被阻塞，直到能获得某些字符或是检测到了文件的末尾。那么如何关闭输人阻塞呢？  

阻塞不仅仅是终端连接的属性，而是任何一个打开的文件的属性。程序可以使用fcntl或open为文件描述符启动非阻塞输入。  

play_again3使用fcntl为文件描述符开启O_NDELAY标志。  

关闭一个文件描述符的阻塞状态并调用read。结果如何呢？如果能够获得输入，read获得输人并返回所获得的字符个数。如果没有输入字符，read返回0,这就像遇到文件末尾一样。如果有错误，read返回-1。  

非阻塞操作的内部实现相当简单。每个文件都有一块保存未读取数据的地方，如图6.4所示的驱动程序里最顶端的存储方块。如果文件描述符置了 O.NDELAY位，并且那块空间是空的，read调用返回0。如果能阅读与O.NDELAY有关的的Linux源代码，就可以了解到实现的细节。  

#### 实现超时的其他方法
Unix提供更好的方法来实现超时功能，在驱动程序中设置数组c_cc\[]中的元素VTIME将超时功能的实现移至终端驱动程序。本章的一个练习提供了相关细节。系统调用select包含一个超时参数。  

#### play_again3的一个大问题
当按下Ctrl-C终止程序play.again,不但终止了这个程序，同时也终止了整个登录会话。  

而不执行重置驱动程序的代码。当返回shell显示提示符并从用户处获得命令行时，终端仍旧处于非阻塞模式。shell调用read获取命令行，但是因为处于非阻塞状态，read立即返回0。总之，程序结束时文件描述符处于一个错误的状态。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/52.jpg" width = 60% height = 60% /></div>

## 信号
Ctrl-C中断当前运行的程序。这个中断由一个称为信号的内核机制产生。信号是一个简单而重要的概念。  

### Ctrl-C做什么  

输入Ctrl-C,程序便被终止了。一个单一的击键是如何杀死一个进程的呢？终端驱动程序在这里起了相应的作用，下图显示了相应的事件链。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/53.jpg" width = 60% height = 60% /></div>

中断信号的击键组合不一定非是Ctrl-C,可以使用stty（或者tcsetattr）将当前的VINTR控制字符替换成另一种键。  

### 信号是什么
当按Ctrl-C时，内核向当前正在运行的进程发送中断信号。每个信号都有一个数字编码。中断信号通常是编码2。  

### 信号从哪里来？
信号来自内核，生成信号的请求来自3个地方：  
- 用户
> 用户能够通过输入Ctrl-C、Ctrl-\，或是终端驱动程序分配给信号控制字符的其他任何键来请求内核产生信号。
- 内核
> 当进程执行出错时，内核给进程发送一个信号，例如，非法段存取、浮点数溢出，或是一个非法的机器指令。内核也利用信号通知进程特定事件的发生。
- 进程
> 一个进程可以通过系统调用kill给另一个进程发送信号。一个进程可以和另一个进程通过信号通信。

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/54.jpg" width = 60% height = 60% /></div>

#### 同步信号
由进程的某个操作产生的信号被称为同步信号(synchronous signals)，例如被零除。
#### 异步信号
由像用户击键这样的进程外的事件引起的信号被称为异步信号(asynchronous signals)。  

### 哪里可以找到信号的列表？
信号编号以及它们的名字通常出现在/usr/include/signal.h文件中。这里是这个文件的一部分

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/55.jpg" width = 60% height = 60% /></div>

### 信号做什么？
这要视情况而定。很多信号杀死进程。某时刻进程还在运行，下一秒它就消亡了，从内存中被删除，相应的所有的文件描述符被关闭，并且从进程表中被删除。使用SIGINT消灭一个进程，但是进程也有办法保护自己不被杀死。  

## 进程该如何处理信号
当进程接收到SIGINT时，并不一定非要消亡。进程能够通过系统调用signal告诉内核，它要如何处理信号。进程有3个选择。  

### 接受默认处理(通常是消亡)
手册上列出了对每个信号的默认处理。SIGINT的默认处理是消亡。进程并不一定要使用signal接受默认处理，但是进程能够通过以下调用来恢复默认处理：  
```C
signal (SIGINT, SIG_DFL);
```
### 忽略信号
程序可以通过以下调用来告诉内核，它需要忽略SIGINT信号:  
```C
signal (SIGINT, SIG_IGN);
```

### 调用一个函数
第3种选择是3个当中最强大的一种。考虑play_again3这个例子。当用户输人Ctrl-C，当前运行的程序立即退出，而不调用恢复驱动程序设置的函数。更好的做法是，程序在接收到SIGINT后，调用一个恢复设置的函数，然后再退出。  

调用signal的第3种选择允许这种类型的响应。程序能够告诉内核，当信号到来时应该调用哪个函数。在信号到来时被调用的函数被称为信号处理函数。为安装信号处理函数，程序调用：
```C
signal (signum,functionname);
```

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/56.jpg" width = 60% height = 60% /></div>

调用signal为编码是signum的信号安装新的信号处理函数。action可以是函数名或以下两个特殊值之一。  
- SIG_IGN，忽略信号
- SIG_DFL，将信号恢复为默认处理  
signal返回前一个处理函数。值是指向函数的指针  

### 捕捉信号
下图显示了两个独立的控制流：一个是正常的路径，进人main,执行循环，然后从main返回；另一个是由信号引起的路径，进人f，然后返回。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/57.jpg" width = 60% height = 60% /></div>  

### 为处理信号做准备：play_again4.c

## 进程终止
程序使用signal来告诉内核它需要忽略哪些信号。如果有人编写了一个将所有类型的信号设置为SIG_IGN的程序，然后执行一个无限循环将会如何呢？  

幸好，对系统管理员(和程序员)来说，Unix不可能让一个程序永不停止。有两个信号是不能被忽略和捕捉的。阅读手册或头文件中的信号列表，看看哪些信号是不可阻挡的。  

## 为设备编程
现在已经了解了编写终端控制程序的三个方面：  
- 首先，学习了驱动程序的属性和如何控制连接  
- 然后，学习了应用程序的特定需求，并调整驱动程序以满足这些需求
- 最后，学习了如何处理信号中断的一种形式

这三个方面对所有的设备都适用。  

考虑一块声卡或一个磁盘驱动程序：  
- 设备有许多种由设备驱动程序控制的设置，需要了解这些设置
- 同样，程序必须实现特定的功能，调整驱动程序以满足这些需求
- 最后，很多设备驱动程序会产生信号报告错误或特定事件。磁盘驱动程序可能在它结束从磁盘到内存数据块的复制时发送一个信号，程序必须能够对这些信号做出响应  
