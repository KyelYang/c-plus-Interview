# 第二章 变量和基本类型
- 一个char的大小和一个机器字节一样，即1byte
> 因为一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值
- C++语言规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。其中数据类型long long是在C++11中新定义的
- 建议：如何选择类型
   1. 当明确知道数值不可能为负时，选用无符号类型
   2. 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long
   3. 执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度运算还要快。a
long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视
- 建议：避免无法预知的行为、依赖于实现环境的行为
> 无法预知的行为源于编译器无须or有时不能检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误
> 程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称为不可移植的。当程序移植到别的机器上后，
依赖于实现环境的程序就可能发生错误。而且要定位这类错误可不是一件轻松愉快的事情
```
//比如隐式的类型转换就容易出错
bool b = 42;
int i = b;
i = 3.14;
double pi = i;
unsigned char c = -1;
signed char c2 = 256;
```
- 切勿混用带符号类型和无符号类型
    1. 当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。因此导致错误
    2. 同理，当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值

- 字符串字面值的类型实际上是由常量字符构成的数组array
> 例如，字面值'A'表示的就是单独的字符A，而字符串"A"则表示了一个字符的数组，该数组包含两个字符：一个是字母A、另一个是空字符'\0'
- 特殊字符，比如单引号、双引号、问好、反斜线等如果要打印需要用到转义

- 何为对象：通常情况下，对象是指一块能存储数据并具有某种类型的内存空间
-初始化与赋值
> 在C++语言中，初始化和赋值是两个完全不同的操作  
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代

- 默认初始化：如果是内置类型的变量未被显式初始化，它的值由定义的位置决定
> 定义于任何函数体之外的变量将被初始化为0  
定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值时未定义的，如果试图拷贝或以其他形式访问此类值将引发错误  
绝大多数类都支持无须显示初始化而定义对象，这样的类提供了一个合适的默认值；一些类要求每个对象都显式初始化，
此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误  
建议初始化每一个内置类型的变量

- 声明与定义
> 声明使得名字为程序所指，一个文件如果想使用别处定义的名字则必须包含对哪个名字的声明；而定义负责创建与名字关联的实体  
声明规定了变量的类型和名字，在这一点上定义于之相同；但除此之外，定义还申请存储空间，也可能会为变量赋一个初始值  
如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量
```
extern int i;  //声明i而非定义i
int j;  //声明并定义j
extern double pi = 3.14;  //定义；抵消了extern的作用
```
> 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误  
变量能且只能被定义一次，但可以被多次声明

- 用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头；此外，定义在函数体外的标识符不能以下划线开头
- 关于引用一个很好理解的思路
> 引用即别名。**引用并非对象**，相反的，它只是为一个已经存在的对象所起的另外一个名字  
引用只能绑定在对象上，而不能与字面值or某个表达式的计算结果绑定在一起  
引用本身不是一个对象，所以不能定义引用的引用  
- 指针与引用的不同点
   1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象
   2. 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值

- 在给指针初始化时，在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL

- void\*指针
> void\*指针是一种特殊的指针类型，可用于存放任意对象的地址
```
double obj = 3.14,*pd = &bbj;  
void *pv = &obj;  //obj可以是任意类型的对象
pv = pd;  //pv可以存放任意类型的指针
```
> 利用void\*指针能做的事情有限：拿它和别的指针比较、作为函数的输入or输出，或者赋给另外一个void\*指针  
不能直接操作void\*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作  

- 定义多个变量
```
int* p;  //合法但是容易产生误导
int* p1,p2;  //p1是指向int的指针，p2是int
```
> 第一种写法容易产生误导是因为int\*放在一起好像是这条语句中所有变量共同的类型一样。其实恰恰相反，基本数据类型是int而非int\*。
\*仅仅是修饰了p而已，对该声明语句中的其他变量，它不会产生任何作用  

- 顶层const与底层const
> 顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等
> 底层const则与指针和引用等复合类型的基本类型部分有关

- const限定符
   1. 默认状态下，const对象被设定为仅在当前文件内有效，当多个文件中出现同名的const变量时，其实等同于在不同文件中分别定义了独立的变量  
   2. 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字
```
//file1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
//file2.cc
extern const int bufSize;  //与file1.cc中定义的bufSize是同一个
```
- 引用的类型必须与其所引用对象的类型一致（但是有两个例外，详见P55）
- 指针和const
> 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量  
所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变
- const指针
> 指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量  
常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了

- 普通指针不能指向常量/普通指针不能被常量指针初始化，这是出于安全的考虑，否则你就可以通过a指针来间接改变常量b了
- 而常量指针可以指向变量/常量指针可以被普通指针初始化。详见P57练习题

- 常量表达式
> 是指值不会改变并且在编译过程就能得到计算结果的表达式
- constexpr
> 一般来说，如果你认定变量是一个常量表达式，那么就把它声明为constexpr类型  
> c++11新标准规定，允许将变量申明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，
而且必须由常量表达式初始化
```
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();
```
- 常量指针和指针常量
> **常量指针**是指指向常量的指针，顾名思义，就是指针指向的是常量，即，它不能指向变量，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而指向另一个常量  
> **指针常量**是指指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。它指向的地址将伴其一生，直到生命周期结束。有一点需要注意的是，指针常量在定义时必须同时赋初值
```
int const *p1 = &b;  //const 在前，定义为常量指针
int *const p2 = &c;  // *在前，定义为指针常量
```
> 加深记忆记住三句话  
>> 指针和 const 谁在前先读谁  
\*象征着地址，const象征着内容  
谁在前面谁就不允许改变  


# 第三章 字符串、向量和数组

## 3.1 命名空间的using声明

- 类型别名  
> 1.typedef
```
typedef double wages;   //wages是double的别名
```  
> 2.using
```
using wages = double;   //这是新标准规定的一种新的别名声明的方法
```
- auto
> auto一般会忽略掉顶层const，同时底层const则会保留下来  
如果希望推断出的auto类型是一个顶层const，需要明确指出
```
const auto f = ci;
```
> 还可以将应用的类型设为auto，此时原来的初始化规则仍然适用

- decltype类型指示符
> 有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量  
为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，
编译器分析表达式并得到它的类型，缺不实际计算表达式的值
```
decltype(f()) sum = x;  //sum的类型就是函数f的返回类型，但编译器并不实际调用f，而是使用当调用发生时f的返回值类型作为sum的类型
```
- decltype与auto的区别
> 1. 除了功能上的区别，decltype 处理顶层const和引用的方式与 auto不同，decltype会将顶层const和引用保留起来
```
const int ci = 0;
decltype(ci) x = 0;  //x的类型是const int
```
> 2. decltype的结果类型与表达式形式密切相关  
如果使用的是一个不加括号的变量，则得到的结果是该变量的类型  
如果给变量加上了一层或多层括号，编译器就会把它当成一个表达式，因此结果是一个引用
```
int i = 0;
decltype(i) a = i;   //a为int
decltype((i)) b = i;   //b为int&
```
> 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果i是int，则表达式i = x的类型就是int&

- 从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法
- 为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的文明应与类的名字一样
- 当头文件被多次包含的时候，为了确保只被编译一次，且能够安全工作，C++程序会用到一项预处理功能——头文件保护符
> 头文件保护符依赖于预处理变量，预处理变量有两种状态：已定义和未定义  
#define指令把一个名字设为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义
>> #ifdef 当变量已定义时为真  
#ifndef 当变量未定义时为真  
一旦检查结果为真，则执行后续操作直至遇到#endif为止
```
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include<string>
struct Sales_data{
   std::string bookNo;
   unsigned units_sold = 0;
   double revenue = 0.0;
};
#endif
```
> 预处理变量无视C++语言中关于作用域的规则  
整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一  
为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写
> 头文件保护符应该习惯性的加上，而不要太在乎程序到底需不需要

- 头文件不应包含using声明
> 位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件李有某个using声明，
那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突

## 3.2 标准库类型string

- 定义和初始化string对象
> 一个类可以定义很多种初始化对象的方式，只不过这些方式之间有所区别：或者是初始值的数量不同，或者是初始值的类型不同
```
string s(5,'c');  //s的内容是ccccc
```
- 读取string对象
> 1. 一个词一个词读取，中间的空白符不保留
```
string word;
while(cin >> word) ...; //反复读取，直到到达文件末尾
```
> 2. 一次读取一整行，同时保留字符串中输入的空白符，但不保留换行符
```
string line;
while(getline(cin,line)) ...; //每次读入一整行，直到到达文件末尾
```
- string::size_type类型
> size()函数返回的是一个string::size_type类型的值  
它是一个无符号类型的值，而且能足够存放下任何string对象的大小，所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型  
由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果  
>> 例如，假设n是一个具有负值的int，则表达式s.size()<n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值
> 如果一条表达式中已经有了size()函数，就不要再使用int了，这样几乎可以避免混用int和unsigned可能带来的问题
```
size_type i = 0;  //错误
string::size_type i = 0;   //正确
vector<int>::size_type i = 0; //正确
vector::size_type i = 0;   //错误
```
> 要使用size_type，需首先指定它是由哪种类型定义的，vector对象的类型总是包含着元素的类型

- 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型

- 字符处理函数  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/01.png" width = 70% height = 70% /></div>

- 建议使用C++版本的C标准库头文件  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/02.png" width = 70% height = 70% /></div>

- 如果想要该变string对象中字符的值，必须把循环变量定义成引用类型
```
string s("hello world!");
for(auto &c : s)  c = toupper(c);   //将字符全部转为大写
```
- 下标运算符\[]
> 下标运算符接收的输入参数时string::size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用  

## 3.3 标准库类型vector

- 在早期版本的C++标准中若果vector的元素还是vector，则其定义的形式与现在的C++11新标准略有不同
> 过去，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格
```
vector<vector<int>> ...    //错误
vector<vector<int> > ...    //正确
```
> 某些编译器可能仍需以老式的声明语句来处理元素为vector的vecotr对象，如 vector<vector<int> >

- vector动态添加元素
> 开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同  
特别是如果用惯了C或者Java，可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况恰恰相反

- size_t 和 size_type的区别  
> 不同平台的size_t会用不同的类型实现，使用size_t而非int或unsigned可以写出扩展行更好的代码
> 为了使自己的程序有很好的移植性，c++程序员应该尽量使用size_t和size_type而不是int, unsigned
> 1. size_t是全局定义的类型；size_type是STL类中定义的类型属性，用以保存任意string和vector类对象的长度
> 2. string::size_type 制类型一般就是unsigned int, 但是不同机器环境长度可能不同 win32 和win64上长度差别;size_type一般也是unsigned int
> 3. size_t 使用的时候头文件需要 <cstddef> ；size_type 使用的时候需要<string>或者<vector>
> 4. 长度均相等，长度为win32:4 win64:8
```
sizeof(string::size_type) 
sizeof(vector<bool>::size_type) 
sizeof(vector<char>::size_type)  
sizeof(size_t) 
```     
> 5. 二者联系：在用下标访问元素时，vector使用vector::size_type作为下标类型，而数组下标的正确类型则是size_t
   
## 3.4 迭代器介绍

- 迭代器支持的一些运算  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/03.png" width = 70% height = 70% /></div>

- const_iterator
> const_iterator和常量指针差不多，能读取但不能修改它所指的元素值，相反，iterator的对象可读可写  
如果vector对象或string对象是一个常量，只能使用const_iterator  
如果vector对象或string对象不是一个常量，那么既能使用const_iterator也能使用iterator

- cbegin()和cend()
> 为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend
```
const vector<int> v;
auto it = v.cbegin();   //it的类型为vector<int>::const_iterator
```
> 不论vector对象本身是否是常量，返回值都是const_iterator

- 迭代器运算
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/04.png" width = 70% height = 70% /></div>  

> 【注】迭代器只支持两个迭代器相减（结果为距离），不支持相加  

- difference_type
> 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一个位置，就能将其相减，所得结果是两个迭代器的距离  
所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型，
因为这个距离是可正可负，所以difference_type是带符号的类型

- 使用迭代器实现二分搜索
```
int main(){
    vector<int> vec = {5,2,3,1,6,9,8};
    sort(vec.begin(),vec.end());
    auto begin = vec.begin();
    auto end = vec.end();
    auto mid = begin + (end - begin) / 2;
    int value = 7;
    while(mid != end && *mid != value){
        if(*mid < value) begin = mid + 1;
        else end = mid;
        mid = begin + (end - begin) / 2;
    }
    cout << (mid == end ? "not found!" : "founded!") << endl;
    return 1;
}
```

## 3.5 数组
- 数组与vector的区别
> 数组的大小确定不变，不能随意向数组中增加元素  
因为数组的大小固定，因此对某些特殊的应用来说程序的运行性能较好，但是相应地也损失了一些灵活性  
如果不清楚元素的确切个数，请使用vector  
- 数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的；同时，维度必须是一个常量表达式  
```
unsigned cnt = 42;   //不是常量表达式
constexpr unsigned sz = 42;   //常量表达式
int arr[10];   //正确
int *parr[sz]; //正确
string bad[cnt];  //错误，cnt不是常量表达式
string strs[get_size()];   //当get_size是constexpr时正确，否则错误
```
> 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值  

- 字符数组的特殊性
> 字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，
这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去
```
char a1[] = {'C','+','+'};
char a2[] = {'C','+','+','\0'};
char a3[] = "C++";
const char a4[6] = "Daniel";  //错误，没有空间存放空字符！
```

- 不允许拷贝和赋值
> 不能将数组的内容拷贝给其他数组最为初始值，也不能用数组为其他数组赋值  
一些编译器支持数组的复制，这就是所谓的遍历器拓展。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作

- 理解复杂的数组声明
> 和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组；又因为数组本身就是对象，所以允许定义数组的指针及数组的引用
```
int (*Parray)[10] = &arr;  //Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr;   //arrRef引用一个含有10个整数的数组
int *(&array)[10] = ptrs;  //array是数组的引用，该数组含有10个指针
```

- 相比于vector，数组含有以下缺点
> 1. 数组的大小是确定的  
> 2. 不能随意增加元素
> 3. 使用前必须知道其大小
> 4. 不允许拷贝和赋值

- 访问数组元素
> 在使用数组下标时，通常将其定义为size_t类型
>> size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，
这个文件时C标准库stddef.h头文件的C++语言版本
> 数组下标与vector下标的区别
>> 数组的下标是由C++语言直接定义的，这个运算符能用在数组类型的运算对象上  
vector下标时库模板vector定义的，只能用在vector类型的运算对象上

- 指针和数组
> 在一些情况下，数组的操作实际上是指针的操作，这一结论有很多隐含的意思，其中一层意思是当使用数组作为一个auto变量的初始值时，
推断得到的类型是指针而非数组
```
int ia[] = {1,2,3};
auto ia2(ia);  //ia2是一个整型指针，指向ia的第一个元素
auto ua2(&ia[0]); //与上面等价，是编译器实际执行的初始化过程
ia2 = 42;   //错误，ia2是一个指针，不能用int值给指针赋值
```
> 但是，当使用decltype关键字时，上述转换不会发生
```
decltype(ia) ia3 = {4,5,6};   
ia3 = p; //错误，不能用整型指针给数组赋值
ia3[4] = i; //正确
```
- 指针也是迭代器
> 迭代器支持的运算，数组的指针全都支持
```
int arr[] = {1,2,3};
int *p = arr;
++p;  //p指向arr[1]
int *begin = arr;    //指向arr首元素的指针
int *last = &arr[3]; //指向arr尾元素的下一个位置的指针
for(int *p = begin;p != last; ++p) ...;   //利用指针遍历arr数组
```
- 标准库函数begin和end
> 尽管能计算得到尾后指针（如上），但这种用法极易出错，为了能让指针的使用更简单、更安全，C++11新标准引入了两个名为begin和end的函数
>> 这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数  
正确的使用方式是将数组作为它们的参数  
这两个函数定义在iterator头文件中
```
int arr[] = {1,2,3};
int *begin = begin(arr);    //指向arr首元素的指针
int *last = end(arr); //指向arr尾元素的下一个位置的指针
```
>> 特别要注意，尾后指针不能执行解引用和递增操作

- 指针运算
> 指向数组元素的指针可以执行所有迭代器运算。这些运算包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致
>> 给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置  
```
int arr[] = {1,2,3};
int *p = arr + 3; //正确，p指向arr尾元素的下一位置
int *p2 = arr + 5;   //错误，arr只有3个元素，超出数组范围，而且这种错误编译器一般发现不了
```
>> 和迭代器一样，两个指针相减的结果是它们之间的距离，参与运算的两个指针必须指向同一个数组当中的元素
```
auto n = end(arr) - begin(arr);  //n的值时3，也就是arr中元素的个数
```
- ptrdiff_t
> 两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关类型。
因为差值可能为负值，所以ptrdiff_t是一种带符号类型
> 只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利用关系运算符对其进行比较
> 允许给p指针加上或减去一个值为0的整型常量表达式
> 两个空指针也允许彼此相减，结果当然是0

- 下标和指针
> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样
```
int arr[] = {1,2,3};
int *p = &arr[1]; //p指向索引为1的元素
int j = p[1];  //p[1]等价于*（p + 1），就是arr[2]表示的那个元素
int k = p[-1]; //p[-1]等价于*（p - 1），就是arr[0]表示的那个元素
```

## 3.6 多维数组
- 多维数组的初始化
```
int ia[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
int ia[3][3] = {1,2,3,4,5,6,7,8,9}; //与上面等价
int ia[3][3] = {{1},{4},{7}}; //显式地初始化每行的首元素，其他伟略出的元素执行默认初始化，这个过程和一维数组一样
```

- 多维数组的遍历
> 1. 下标访问
```
constexpr size_t row = 3,col = 4;
for(size_t i = 0; i < row; ++i){
   for(size_t j = 0; j < col; ++j) ...;
```
> 2. auto
```
//原型
for(int (&row)[3] : ia){
   for(int col : row) ...;
   
//auto
for(auto &row : ia){
   for(auto col : row) ...;
```
>> 注意：要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型  
这是因为如果没有声明成引用，编译器初始化row时会自动将这些数组形式的元素转换成指向该数组内首元素的指针，即得到int \*，这样内存的循环就不合法了

> 3. 指针
```
for(int (*p)[3] = begin(ia);p != end(ia);++p){
  for(int *q = begin(*p);q != end(*p);++q) ...;
```

# 第八章 IO库

## 8.1 IO类
- IO库类型和头文件
> 以下列出了IO类型，分别定义在三个头文件中
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/05.png" width = 70% height = 70% /></div>  

> 为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始  

- IO类型间的关系
> 类型ifstream和istringstream都继承自istream。因此，我们可以像使用istream对象一样来使用ifstream和istringstream对象。
也就是说，我们是如何使用cin的，就可以同样地使用这些类型的对象  
> 本节剩下部分介绍的标准库流特性都可以无差别地应用于普通流、文件流和string流、以及char或宽字符流版本  

### 8.1.1  IO对象无拷贝or赋值
- 只能将IO对象的引用作为参数传递给函数，且不能是const的  
> 由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，
因此传递和返回的引用不能是const的  

### 8.1.2  条件状态  
- IO库条件状态  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/06_1.png" width = 70% height = 70% /></div>  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/06_2.png" width = 70% height = 70% /></div>  

> 一个流一旦发生错误，其后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，
因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象状态的最简单的办法是将它作为一个条件来使用  
```
while(cin >> word)
   ...   //ok,读操作成功...
```
- 查询流的状态
> 1. badbit表示系统级错误，如不可恢复的读写错误  
> 2. failbit表示发生了可恢复的错误，如期望读取数值却读出一个字符等错误；这种问题通常是可以修正的，流还可以继续使用  
> 3. 如果到达文件结束位置，eofbit和failbit都会被置位  
> 4. goodbit的值为0，表示流发生未知错误  
> 5. 如果badbit、failbit和eofbit任一个被置位，则检测流状态的条件会失败  
> 标准库还定义了一组函数来查询这些标志位的状态  
>> 操作good在所有错误为均置位的情况下返回true，而bad、fail和eof则在对应错误位被置位时返回true。此外，在badbit被置位时，fail也会返回true。
这意味着，使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当做条件使用的代码就等价于!fail()。而eof和bad操作只能表示特定的错误  

- 管理条件状态
> clear不接受参数的版本清除（复位）所有错误标志位。执行clear()后，调用good会返回true  
> 带参数的clear版本接收一个iostate值，表示流的新状态，即可以更新流的状态  

### 8.1.3  管理输出缓冲
- 管理输出缓冲  
> 有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，
允许操作系统将多个输出操作组合成单一的设备写操作可以带来很大的性能提升  
> 导致缓冲刷新（即数据真正写到输出设备或文件中）的原因很多
>> 1. 程序正常结束  
>> 2. 缓冲区满  
>> 3. endl  
>> 4. unitbuf  
>> 5. 一个输出流可能被关联到另一个流  

- 刷新输出缓冲区 endl、flush、ends、unitbuf、nounitbuf
```
cout << "hi" << endl;   //输出hi后换行，然后刷新缓冲区
cout << "hi" << flush;  //输出hi，然后刷新缓冲区
cout << "hi" << ends;   //输出hi和一个空字符，然后刷新缓冲区
cout << unitbuf;   //之后的每次输出操作都会立即刷新缓冲区
cout << nounitbuf;   //回到正常的缓冲方式
``` 

- 警告：如果程序崩溃，输出缓冲区不会被刷新  
> 当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能大量时间浪费在追踪代码为什么没有执行上，
而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起而没有打印而已  

- 关联输入和输出流  
> 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会被先刷新关联的输出流，标准库将cout和cin关联在一起
```
cin >> ival;   //导致cout的缓冲区被刷新
```
> Note：交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作前被打印出来  

- 关于关联流：tie函数的具体使用见P283

## 8.2 文件输入输出
- 头文件fstream定义了三种类型来支持文件IO
> 1. ifstream：从一个给定文件读取数据  
> 2. ofstream：向一个给定文件写入数据  
> 3. fstream：读写给定文件  

- 除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件，我们可以对fstream对象调用这些操作，
但不能对其他IO类型调用这些操作  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/07.png" width = 70% height = 70% /></div>  

### 8.2.1  使用文件流对象
- 在要求使用父类对象的地方，我们可以用继承类型的对象来替代。也就是说，如果有一个函数接收一个ostream&参数，我们在调用这个函数时，
可以传递给它一个ofstream对象  

- 成员函数open和close
> 对于一个已经打开的文件流调用open会失败，并导致fialbit被置位。随后的试图使用文件流的操作都会失败，为了将文件关联到意外一个文件，
必须首先管理已经关联的文件，一旦文件成功关闭，我们可以打开新的文件
```
ifstream in(file_01);
in.close(); //关闭文件
in.open(file_02); //打开另一个文件。如果open成功，则open会设置流的状态，使得good()为true
```

- 自动构造和析构
> 当一个流对象离开其作用于时，与之关联的文件会自动关闭。比如：当一个fstream对象离开作用域被销毁时，close会自动被调用  

### 8.2.2  文件模式
- 每一个流都有一个关联的文件模式，用来之处如何使用模式
> 每个文件流类型都定义了一个默认的文件模式  
>> 与ifstream关联的文件默认以in模式打开  
>> 与ofstream关联的文件默认以out模式打开  
>> 与fstream关联的文件默认以in和out模式打开  

- 以out模式打开文件会丢失已有数据
> 默认情况下，当我们打开一个ofstream时，文件的内容会被丢失。保留被ofstream打开文件中已有数据的唯一方法是显示指定app或in模式  

- 每次调用open时都会确定文件模式，可以是显式的设置，也可以使用默认值  
```
ofstream out;
out.open(file);   //以默认方式打开，文件内容会被清除
out.open(file,ofstream::app); //以追加的方式打开文件
out.close();
```

## 8.3 string流
- sstream定义了三种类型来支持内存IO
> 1. istringstream：从string读取数据  
> 2. ostringstream：向string写入数据  
> 3. stringstream：读写string  

- 除了继承自得来的操作之外，sstream中定义的类型还增加了一些新的成员来管理与流关联的string，我们可以对stringstream对象调用这些操作，
但不能对其他IO类型调用这些操作  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/04-C%2B%2B%20Primer/image/08.png" width = 70% height = 70% /></div>  
