# 网络编程
## 面试问题
- IO模型，Select、Epoll和Poll的区别
- epoll中ET模式与LT模式的区别
- epoll有个边沿触发和水平触发说一下？
- epoll与select的区别以及他们的优势？
- ET和LT的区别，需要注意什么
- 移动语义和完美转发介绍一下？
- 完美转发怎么实现的？什么原理？
- 多路IO复用？epoll和poll和select的区别？
- Epoll和poll以及select的区别（设计IO模型，腾讯）
- 同步IO和异步IO
- select 和 epoll 了解嘛？有什么区别，ET/LT模式？epoll 的一些实现？如果需要跨平台，你会用select还是epoll？
- 详细讲解select和epoll的底层实现，LT和ET模式的底层区别，ET模式下的读写注意事项
- Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）
- IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？
- Epoll的ET模式和LT模式（ET的非阻塞）

## Socket什么时候可读
- [socket 什么情况下可读](https://blog.csdn.net/libaineu2004/article/details/85764355)
- [Socket 读写就绪条件](https://murphypei.github.io/blog/2019/08/socket-ready)

## tcp怎么读取报文内数据，read函数怎么做的
- [【详解】换一个角度看Socket的数据读写](https://www.cnblogs.com/longfurcat/p/10349365.html)
- [read和write函数](https://www.cnblogs.com/tianzeng/p/9347612.html)
- [TCP 协议下 socket 有可能丢包吗？](https://www.zhihu.com/question/53960871)


## read/recv返回值为0是什么情况
- \>0 接收到数据大小
- =0 连接关闭
- <0 出错
当调用非阻塞read/recv时，会返回-1,errno = EWOUDLDBLOCK。  

当调用阻塞read/recv时，如果读缓冲区数据量小于缓冲区低水位（1byte）时候，此时会一直阻塞，没有返回值。  

## write、read和send、recv之间的区别
- [socket编程中write、read和send、recv之间的区别](https://blog.csdn.net/petershina/article/details/7946615)
- [socket编程中recv()和read()的使用与区别](https://blog.csdn.net/hhhlizhao/article/details/73912578?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param)


# select()、poll()、epoll()需要看源码才能将底层的逻辑盘清楚
# 面试问题整理
## epoll为什么用红黑树和双向链表，为什么不用单向链表而用双向链表
使用双向链表并不是说只能用双向链表，只是它性能和损耗权衡下比较符合。至于为什么不用单项链表，如果要删除单项链表中间的一个元素，效率比双向慢一些。
## 半同步/半异步网络并发模型
- [高山仰之可极，谈半同步/半异步网络并发模型](https://zhuanlan.zhihu.com/p/58860015)

## C10K问题
### 什么是C10K问题
「在同时连接到服务器的客户端数量超过 10000 个的环境中，即便硬件性能足够，依然无法正常提供服务」，简而言之，就是如何让单机具备处理 1 万个并发连接，且这些连接可能是保持存活状态。  

### 如何解决C10K问题
- [C10K 问题](https://swsmile.info/2019/01/20/%E3%80%90Network%E3%80%91%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-C10K%E9%97%AE%E9%A2%98%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/)
- [聊聊C10K问题及解决方案](https://blog.csdn.net/wangtaomtk/article/details/51811011)

## epoll中ET模式与LT模式的区别
### 水平触发
当采用水平触发通知时，我们可以在任意时刻检查文件描述符的就绪状态。这表示当我们确定了文件描述符处于就绪态时（比如存在有输入数据），就可以对其执行一些 I/O 操作，然后重复检查文件描述符，看看是否仍然处于就绪态（比如还有更多的输入数据），此时我们就能执行更多的 I/O，以此类准。  

换句话说，由于水平触发模式允许我们在任意时刻重复检查 I/O 状态，因此没有必要每次当文件描述符就绪后就一次将文件描述符中的内容读/写完，后续还可以继续操作。  

### 边缘触发
与之相反的是，当我们采用边缘触发时，只有当 I/O 事件发生时我们才会收到通知（只通知一次）。在另一个新的 I/O 事件到来前我们不会收到任何新的通知。另外，当文件描述符收到 I/O 事件通知时，通常我们并不知道要处理多少 I/O（例如有多少字节可读）。因此，采用边缘触发通知的程序通常要按照如下规则来设计。  

### 通过一个例子来说明 epoll 的水平触发和边缘触发通知之间的区别
假设我们使用epoll 来监视一个套接字上的输入（EPOLLIN），接下来会发生如下的事件。  

- 套接字上有输入到来。  
- 我们调用一次 epoll_wait()。无论我们采用的是水平触发还是边缘触发通知，该调用都会告诉我们套接字已经处于就绪态了。
- 再次调用 epoll_wait()。

如果我们采用的是水平触发通知，那么第二个 epoll_wait()调用将告诉我们套接字处于就绪态。  

而如果我们采用边缘触发通知，那么第二个 epoll_wait()调用将阻塞，因为自从上一次调用 epoll_wait()以来并没有新的输入到来。  

### 二者的差异  
二者的差异在于level-trigger模式下只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket。  

而edge-trigger模式下只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。

所以，在epoll的ET模式下，正确的读写方式为:  
- 只要可读，就一直读，直到返回0，或者 errno = EAGAIN
- 只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN

从 kernel 代码来看，ET/LT模式的处理逻辑几乎完全相同，差别仅在于 LT模式在 event 发生时不会将其从 ready list 中移除，略为增大了event 处理过程中 kernel space 中记录数据的大小。  

### 水平触发和边缘触发的应用场景
#### LT更加鲁棒性

用LT的话附带的代码写起来会比较简单，不容易有bug，ET模式的代价就是增加了网络层的逻辑处理复杂度。  

ET本身并不会造成饥饿，由于事件只通知一次，开发者一不小心就容易遗漏了待处理的数据，像是饥饿，实质是bug。  

#### ET在特定场景下性能比LT好
ET理论上可以比LT少带来一些系统调用。  

对于EPOLLOUT事件适合用ET，也就是fd可写事件(缓存满的时候要再等这个事件)，如果用LT会需要开关各一次此事件(否则只要fd可写，每次epoll_wait，可写事件会立刻触发)，所以EPOLLOUT事件更适合ET模式。  

所以,像nginx这样作为高性能服务器的，网络上传下载量大，很可能缓冲区被频繁写满，也就是会经常需要等待EPOLLOUT事件，于是就适合用ET；而Redis使用的是水平触发。  

- [epoll的边沿触发模式(ET)真的比水平触发模式(LT)快吗？(当然LT模式也使用非阻塞IO，重点是要求ET模式下的代码不能造成饥饿)](https://www.zhihu.com/question/20502870)

### 相关链接
- [epoll两种类型ET和LT区别(结合实际例子)](https://blog.csdn.net/cws1214/article/details/47662705)
- [Epoll之ET、LT模式](https://blog.csdn.net/feitianxuxue/article/details/17078179)
- [Nginx为啥使用ET模式Epoll？](https://www.zhihu.com/question/21202701)
## IO模型，Select、Epoll和Poll的区别
### select()和 poll()存在的问题
系统调用 select()和 poll()是用来同时检查多个文件描述符就绪状态的方法，它们是可移植的、长期存在且被广泛使用的。但是当检查大量的文件描述符时，这两个 API 都会遇到一些问题。  

- 每次调用 select()或 poll()，内核都必须检查所有被指定的文件描述符，看它们是否处于就绪态。当检查大量处于密集范围内的文件描述符时，该操作耗费的时间将大大超过接下来的操作。

- 每次调用 select()或 poll()时，程序都必须传递一个表示所有需要被检查的文件描述符的数据结构到内核，内核检查过描述符后，修改这个数据结构并返回给程序。（此外，对于 select()来说，我们还必须在每次调用前初始化这个数据结构。）对于 poll()来说，随着待检查的文件描述符数量的增加，传递给内核的数据结构大小也会随之增加。当检查大量文件描述符时，从用户空间到内核空间来回拷贝这个数据结构将占用大量的 CPU 时间。对于 select()来说，这个数据结构的大小固定为FD_SETSIZE，与待检查的文件描述符数量无关。

- select()或 poll()调用完成后，程序必须检查返回的数据结构中的每个元素，以此查明哪个文件描述符处于就绪态了。

上述要点产生的结果就是随着待检查的文件描述符数量的增加，select()和 poll()所占用的CPU 时间也会随之增加。对于需要检查大量文件描述符的程序来说，这就产生了问题。

select()和 poll()糟糕的性能延展性源自这些 API 的局限性：  

通常，程序重复调用这些系统调用所检查的文件描述符集合都是相同的，可是内核并不会在每次调用成功后就记录下它们。  

### epoll API 的主要优点
- 当检查大量的文件描述符时，epoll 的性能延展性比 select()和 poll()高很多。
- epoll API 既支持水平触发也支持边缘触发。与之相反，select()和 poll()只支持水平触发，而信号驱动 I/O 只支持边缘触发。 性能表现上，epoll 同信号驱动 I/O 相似。但是，epoll 有一些胜过信号驱动 I/O 的优点。
- 可以避免复杂的信号处理流程（比如信号队列溢出时的处理）。
- 灵活性高，可以指定我们希望检查的事件类型（例如，检查套接字文件描述符的读就绪、写就绪或者两者同时指定）。  

### 为什么epoll 的性能表现更好
- 每次调用 select()和 poll()时，内核必须检查所有在调用中指定的文件描述符。与之相反，当通过 epoll_ctl()指定了需要监视的文件描述符时，内核会在与打开的文件描述上下文相关联的列表中记录该描述符。之后每当执行 I/O 操作使得文件描述符成为就绪态时，内核就在 epoll 描述符的就绪列表中添加一个元素。（单个打开的文件描述上下文中的一次 I/O 事件可能导致与之相关的多个文件描述符成为就绪态。）之后的epoll_wait()调用从就绪列表中简单地取出这些元素。

- 每次调用 select()或 poll()时，我们传递一个标记了所有待监视的文件描述符的数据结构给内核，调用返回时，内核将所有标记为就绪态的文件描述符的数据结构再传回给我们。与之相反，在 epoll 中我们使用 epoll_ctl()在内核空间中建立一个数据结构，该数据结构会将待监视的文件描述符都记录下来。一旦这个数据结构建立完成，稍后每次调用 epoll_wait()时就不需要再传递任何与文件描述符有关的信息给内核了，而调用返回的信息中只包含那些已经处于就绪态的描述符。

- 除了以上几点外，对于 select()来说，我们必须在每次调用之前先初始化输入数据。而无论是 select()还是 poll()，我们必须对返回的数据结构做检查，以此找出 N 个文件描述符中有哪些是处于就绪态的。但是，通过一些测试得出的结果表明，这些额外的步骤所花费的时间同系统调用监视 N 个文件描述符所花费的时间相比就显得微不足道了。上表并没有包含这些检查步骤所用的时间。

### 选择哪种技术
- 系统调用select()和poll()在UNIX 统中已经存在了很长的时间。同其他技术相比，它们主要的优势在于可移植性，主要缺点在于当同时检查大量的（数百或数千个）文件描述符时性能延展性不佳。
- epoll API 的关键优势在于它能让应用程序高效地检查大量的文件描述符。其主要缺点在于它是专属于Linux 系统的API。
- 同epoll一样，信号驱动I/O可以让应用程序高效地检查大量的文件描述符。但是epoll有一些信号驱动 I/O 所没有的优点：  
  - 避免了处理信号的复杂性。
  - 我们可以指定想要检查的事件类型（即，读就绪或者写就绪）。
  - 我们可以选择以水平触发或边缘触发的形式来通知进程。  
  
因为从另一方面来说 select()和 poll()的可移植性更好，而信号驱动I/O和epoll 有着更好的性能表现。  

## 同步IO和异步IO
- [对比五种I/O模型](https://xiaoxiami.gitbook.io/linux-server/wu-zhong-i-o-mo-xing/dui-bi-wu-zhong-i-o-mo-xing)
- [Linux和Java的I/O模型](https://yasinshaw.com/articles/52)
- [深入理解JAVA I/O系列六：Linux中的IO模型](https://www.cnblogs.com/dongguacai/p/5770287.html)
- [Linux(UNIX)五种网络I/O模型与IO多路复用](https://blog.csdn.net/J080624/article/details/87172690)
## Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）
- [迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章](https://zhuanlan.zhihu.com/p/72781268)
- [怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473)
## 如果需要跨平台，你会用select还是epoll？
选择select。select的跨平台做的很好，几乎每个平台都支持。  

epoll的主要缺点在于它是专属于Linux 系统的API，因此其可移植性较差。  

## 底层实现
底层实现需要看源码。  

# Linux-Unix系统编程手册——该内容整理
# select()、poll()、epoll()的产生条件
## 传统阻塞式IO模型
传统I/O 模型都是单个进程每次只在一个文件描述符上执行I/O操作，每次I/O系统调用都会阻塞直到完成数据传输。  

比如，当从一个管道中读取数据时，如果管道中恰好没有数据，那么通常read()会阻塞。而如果管道中没有足够的空间保存待写入的数据时，write()也会阻塞。当在其他类型的文件如FIFO和套接字上执行I/O操作时，也会出现相似的行为。  

## 某些特定任务传统阻塞式IO模型无法满足
对于许多应用来说，传统的阻塞式 I/O 模型已经足够了，但这不代表所有的应用都能得到满足。特别的，有些应用需要处理以下某项任务，或者两者都需要兼顾。   
- 如果可能的话，以非阻塞的方式检查文件描述符上是否可进行 I/O 操作。
- 同时检查多个文件描述符，看它们中的任何一个是否可以执行 I/O 操作。 

## 非阻塞式IO以及轮询
如果在打开文件时设定了O_NONBLOCK 标志，会以非阻塞方式打开文件。如果I/O系统调用不能立刻完成，则会返回
错误而不是阻塞进程。非阻塞式I/O可以运用到管道、FIFO、套接字、终端、伪终端以及其他一些类型的设备上。  

非阻塞式I/O可以让我们周期性地检查（“轮询”）某个文件描述符上是否可执行I/O操作。  

比如，我们可以让一个输入文件描述符成为非阻塞式的，然后周期性地执行非阻塞式的读操作。如果我们需要同时检查多个文件描述符，那么就需要将它们都设为非阻塞，然后依次对它们轮询。  

但是，这种轮询通常是我们不希望看到的。如果轮询的频率不高，那么应用程序响应I/O事件的延时可能会达到无法接受的程度。换句话说，在一个紧凑的循环中做轮询就是在浪费CPU。  

## 多进程/多线程处理多IO问题
### 多进程
如果不希望进程在对文件描述符执行 I/O 操作时被阻塞，我们可以创建一个新的进程来执行 I/O。此时父进程就可以去处理其他的任务了，而子进程将阻塞直到 I/O 操作完成。如果我们需要处理多个文件描述符上的 I/O，此时可以为每个文件描述符创建一个子进程。这种方法的问题在于开销昂贵且复杂。创建及维护进程对系统来说都有开销，而且一般来说子进程需要使用某种 IPC 机制来通知父进程有关 I/O 操作的状态。  

### 多线程
使用多线程而不是多进程，这将占用较少的资源。但线程之间仍然需要通信，以告知其他线程有关 I/O 操作的状态，这将使编程工作变得复杂。尤其是如果我们使用线程池技术来最小化需要处理大量并发客户的线程数量时。  

多线程特别有用的一个地方是如果应用程序需要调用一个会执行阻塞式 I/O 操作的第三方库，那么可以通过在分离的线程中调用这个库从而避免应用被阻塞。  

## 由此引出select()、poll()、epoll()
由于非阻塞式 I/O 和多进（线）程都有各自的局限性，下列备选方案往往更可取。  

- I/O多路复用允许进程同时检查多个文件描述符以找出它们中的任何一个是否可执行I/O 操作。系统调用select()和poll()用来执行I/O多路复用。
- 信号驱动 I/O 是指当有输入或者数据可以写到指定的文件描述符上时，内核向请求数据的进程发送一个信号。进程可以处理其他的任务，当I/O操作可执行时通过接收信号来获得通知。当同时检查大量的文件描述符时，信号驱动I/O相比select()和 poll()有显著的性能提升。
- epoll API 是 Linux 专有的特性，首次出现是在Linux 2.6版中。同I/O多路复用API一样，epoll API允许进程同时检查多个文件描述符，看其中任意一个是否能执行I/O操作。同信号驱I/O一样，当同时检查大量文件描述符时，epoll能提供更好的性能。  

## 都为了实现一个共同的目标
实际上I/O多路复用、信号驱动I/O以及epoll都是用来实现同一个目标的技术：  

**同时检查多个文件描述符，看它们是否准备好了执行 I/O 操作。**  

准确地说，是看I/O系统调用是否可以非阻塞地执行。  

文件描述符就绪状态的转化是通过一些I/O事件来触发的，比如输入数据到达，套接字连接建立完成，或者是之前满载的套接字发送缓冲区在 TCP 将队列中的数据传送到对端之后有了剩余空间。  

需要注意的是这些技术都不会执行实际的I/O操作。它们只是告诉我们某个文件描述符已经处于就绪状态了。这时需要调用其他的系统调用来完成实际的I/O操作。  

## 选择哪种技术
- 系统调用select()和poll()在UNIX 统中已经存在了很长的时间。同其他技术相比，它们主要的优势在于可移植性，主要缺点在于当同时检查大量的（数百或数千个）文件描述符时性能延展性不佳。  
- epoll API 的关键优势在于它能让应用程序高效地检查大量的文件描述符。其主要缺点在于它是专属于Linux 系统的API。  
- 同epoll一样，信号驱动I/O可以让应用程序高效地检查大量的文件描述符。但是epoll有一些信号驱动 I/O 所没有的优点：
1. 避免了处理信号的复杂性。  
2. 我们可以指定想要检查的事件类型（即，读就绪或者写就绪）。  
3. 我们可以选择以水平触发或边缘触发的形式来通知进程。  

因为从另一方面来说 select()和 poll()的可移植性更好，而信号驱动I/O和epoll 有着更好的性能表现。  

# 水平触发和边缘触发
在深入讨论多种可选的 I/O 机制之前，我们需要先区分两种文件描述符准备就绪的通知模式：
- 水平触发通知：如果文件描述符上可以非阻塞地执行 I/O 系统调用，此时认为它已经就绪。
- 边缘触发通知：如果文件描述符自上次状态检查以来有了新的 I/O 活动（比如新的输入），此时需要触发通知。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/124.jpg" width = 60% height = 60% /></div>

## 水平触发
当采用水平触发通知时，我们可以在任意时刻检查文件描述符的就绪状态。这表示当我们确定了文件描述符处于就绪态时（比如存在有输入数据），就可以对其执行一些 I/O 操作，然后重复检查文件描述符，看看是否仍然处于就绪态（比如还有更多的输入数据），此时我们就能执行更多的 I/O，以此类准。  

换句话说，由于水平触发模式允许我们在任意时刻重复检查 I/O 状态，因此没有必要每次当文件描述符就绪后就一次将文件描述符中的内容读/写完，后续还可以继续操作。  

## 边缘触发
与之相反的是，当我们采用边缘触发时，只有当 I/O 事件发生时我们才会收到通知（只通知一次）。在另一个新的 I/O 事件到来前我们不会收到任何新的通知。另外，当文件描述符收到 I/O 事件通知时，通常我们并不知道要处理多少 I/O（例如有多少字节可读）。因此，采用边缘触发通知的程序通常要按照如下规则来设计。

### 在接收到一个 I/O 事件通知后，程序在某个时刻应该在相应的文件描述符上尽可能多地执行 I/O（比如尽可能多地读取字节）
如果程序没这么做，那么就可能失去执行 I/O 的机会。因为直到产生另一个 I/O 事件为止，在此之前程序都不会再接收到通知了，因此也就不知道此时应该执行 I/O 操作。这将导致数据丢失或者程序中出现阻塞。前面我们说“在某个时刻”，是因为有时候当我们确定了文件描述符是就绪态时，此时可能并不适合马上执行所有的 I/O 操作。问题的原因在于如果我们仅对一个文件描述
符执行大量的 I/O 操作，可能会让其他文件描述符处于饥饿状态。  

### 文件描述符通常都应该置为非阻塞模式
如果程序采用循环来对文件描述符执行尽可能多的 I/O，而文件描述符又被置为可阻塞的，那么最终当没有更多的 I/O 可执行时，I/O 系统调用就会阻塞。基于这个原因，每个被检查的文件描述符通常都应该置为非阻塞模式，在得到 I/O 事件通知后重复执行I/O 操作，直到相应的系统调用（比如 read()，write()）以错误码 EAGAIN 或 EWOULDBLOCK 的形式失败。

## 非阻塞 I/O（O_NONBLOCK 标志）常和本章中所描述的 I/O 模型一起使用  

# I/O 多路复用——select()和poll()  
## select()系统调用
系统调用 select()会一直阻塞，直到一个或多个文件描述符集合成为就绪态。  

Linux提供的select相关函数接口如下：
```C
#include <sys/select.h>
#include <sys/time.h>

int select(int max_fd,  //文件描述符最大值+1，主要是为了提供轮询范围，方便后续轮询
          fd_set *readset,  //readset是用来检测输入是否就绪的文件描述符集合
          fd_set *writeset, //writeset 是用来检测输出是否就绪的文件描述符集合
          fd_set *exceptset,  //exceptset 是用来检测异常情况是否发生的文件描述符集合
          struct timeval *timeout); //阻塞时长


FD_ZERO(int fd, fd_set* fds);   //fdset所指向的集合初始化为空
FD_SET(int fd, fd_set* fds);    //将文件描述符fd添加到由fdset所指向的集合中
FD_CLR(int fd, fd_set* fds);   //将文件描述符fd从fdset所指向的集合中移除
FD_ISSET(int fd, fd_set* fds);  //判断文件描述符fd是否在集合中
```
### 关于exceptset中的异常情况
术语“异常情况”常常被误解为在文件描述符上出现了一些错误，这并不正确。在 Linux 上，一个异常情况只会在下面两种情况下发生（其他的 UNIX 实现也类似）：
- 连接到处于信包模式下的伪终端主设备上的从设备状态发生了改变。
- 流式套接字上接收到了带外数据。  

### max_fd的最大值
文件描述符集合有一个最大容量限制，由常量 FD_SETSIZE 来决定。在 Linux 上，该常量的值为 1024。（其他 UNIX 实现对于该限制也有类似的常量值来限定。）  

### select()调用过程
参数 readfds、writefds 和 exceptfds 所指向的结构体都是保存结果值的地方。在调用 select()之前，这些参数指向的结构体必须初始化（通过 FD_ZERO()和 FD_SET()），以包含我们感兴趣的文件描述符集合。之后 select()调用会修改这些结构体，当 select()返回时，它们包含的就是已处于就绪态的文件描述符集合了。（由于这些结构体会在调用中被修改，如果要在循环中
重复调用 select()，我们必须保证每次都要重新初始化它们。）之后这些结构体可以通过FD_ISSET()来检查哪些文件描述符已就绪。  

如果我们对某一类型的事件不感兴趣，那么相应的 fd_set 参数可以指定为 NULL。  

参数 nfds 必须设为比 3 个文件描述符集合中所包含的最大文件描述符号还要大 1。该参数让 select()变得更有效率，因为此时内核就不用去检查大于这个值的文件描述符号是否属于这些文件描述符集合。  

### timeout 参数

```C
struct timeval
{
    time_t tv_sec;        //秒数
    suseconds_t tv_usec;       //微秒数(long int)
};
```
参数 timeout 控制着 select()的阻塞行为。该参数可指定为 NULL，此时 select()会一直阻塞。

如果结构体 timeval 的两个域都为 0 的话，此时 select()不会阻塞，它只是简单地轮询指定的文件描述符集合，看看其中是否有就绪的文件描述符并立刻返回。

如果结构体 timeval 不为0，timeout 将为 select()指定一个等待时间的上限值。  

### select()实现微秒sleep()功能
在缺少微秒级 sleep 调用的老式 UNIX 实现中，select()被用来模拟这个功能。这可以通过指定 nfds 为 0，readfds、writefds 以及 exceptfds 全设为 NULL，而期望的休眠时间在 timeout 中指定来完成。  

### select()的返回值
作为函数的返回值，select()会返回如下几种情况中的一种：
#### 返回−1表示有错误发生 
可能的错误码包括 EBADF 和 EINTR。  
EBADF 表示 readfds、writefds 或者 exceptfds 中有一个文件描述符是非法的（例如当前并没有打开）。  

EINTR表示该调用被信号处理例程中断了。如果被信号处理例程中断，select()是不会自动恢复的。
 
#### 返回 0 表示在任何文件描述符成为就绪态之前 select()调用已经超时 

在这种情况下，每个返回的文件描述符集合将被清空。  
 
#### 返回一个正整数表示有 1 个或多个文件描述符已达到就绪态
返回值表示处于就绪态的文件描述符个数。  

在这种情况下，每个返回的文件描述符集合都需要检查（通过 FD_ISSET()），以此找出发生的 I/O 事件是什么。如果同一个文件描述符在 readfds、writefds 和 exceptfds 中同时被指定，且它对于多个 I/O 事件都处于就绪态的话，那么就会被统计多次。换句话说，select()返回所有在 3 个集合中被标记为就绪态的文件描述符总数。  

# poll()系统调用  
系统调用 poll()执行的任务同 select()很相似。两者间主要的区别在于我们要如何指定待检查的文件描述符。  

在 select()中，我们提供三个集合，在每个集合中标明我们感兴趣的文件描述符。  

而在 poll()中我们提供一列文件描述符，并在每个文件描述符上标明我们感兴趣的事件。

```C
#include <poll.h>

int poll(struct pollfd *fds,  
         nfds_t nfds,         //指定了数组fds中元素的个数
         int timeout);        //超时时长

//参数 fds 列出了我们需要 poll()来检查的文件描述符。该参数为 pollfd 结构体数组，其定义如下。
struct pollfd
{
    int fd;             //指定要监听的文件描述符
    short events;       //指定请求被监听的事件(bit mask)
    short revents;      //返回实际发生的事件(bit mask)
};
```
pollfd 结构体中的 events 和 revents 字段都是位掩码。调用者初始化 events 来指定需要为描述符 fd 做检查的事件。当 poll()返回时，revents 被设定以此来表示该文件描述符上实际发生的事件。  

### 位掩码
下表列出了可能会出现在 events 和 revents 字段中的位掩码。  

该表中第一组位掩码（POLLIN、POLLRDNORM、POLLRDBAND、POLLPRI 以及 POLLRDHUP）同输入事件相关。  

下一组位掩码（POLLOUT、POLLWRNORM 以及 POLLWRBAND）同输出事件相关。  


第三组位掩码（POLLERR、POLLHUP 以及 POLLNVAL）是设定在 revents 字段中用来返回有关文件描述符的附加信息。如果在 events 字段中指定了这些位掩码，则这三位将被忽略。  

在 Linux 系统中，poll()不会用到最后一个位掩码 POLLMSG。

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/125.jpg" width = 60% height = 60% /></div>

如果我们对某个特定的文件描述符上的事件不感兴趣，可以将 events 设为 0。  

另外，给 fd字段指定一个负值（例如，如果值为非零，取它的相反数）将导致对应的 events 字段被忽略，且 revents 字段将总是返回 0。  

这两种方法都可以用来（也许只是暂时的）关闭对单个文件描述符的检查，而不需要重新建立整个 fds 列表。  

注意，下面进一步列出的要点主要是关于 poll()的 Linux 实现。
- 尽管被定义为不同的位掩码，POLLIN 和 POLLRDNORM 是同义词。
- 尽管被定义为不同的位掩码，POLLOUT 和 POLLWRNORM 是同义词。
- 一般来说 POLLRDBAND 是不被使用的，也就是说它在 events 字段中被忽略，也不会设定到 revents 中去。  
- 尽管在特定情形下可用于对套接字的设定，POLLWRBAND 并不会传达任何有用的信息。（不会出现当 POLLOUT 和 POLLWRNORM 没有设定，而设定了POLLWRBAND 的情况。）
- 必须定义_XOPEN_SOURCE 测试宏，这样才能在头文件<poll.h>中得到常量POLLRDNORM、POLLRDBAND、POLLWRNORM 以及 POLLWRBAND 的定义。
- POLLRDHUP 是 Linux 专有的标志位，从 2.6.17 版内核以来就一直存在。要在头文件<poll.h>中得到它的定义，必须定义_GNU_SOURCE 测试宏。
- 如果指定的文件描述符在调用 poll()时关闭了，则返回 POLLNVAL。

总结以上要点，poll()真正关心的标志位就是 POLLIN、POLLOUT、POLLPRI、POLLRDHUP、POLLHUP 以及 POLLERR。  

### timeout参数
参数 timeout 决定了 poll()的阻塞行为，具体如下：
- 如果 timeout 等于−1，poll()会一直阻塞直到 fds 数组中列出的文件描述符有一个达到就绪态（定义在对应的 events 字段中）或者捕获到一个信号。
- 如果 timeout 等于 0，poll()不会阻塞——只是执行一次检查看看哪个文件描述符处于就绪态。 
- 如果 timeout 大于 0，poll()至多阻塞 timeout 毫秒，直到 fds 列出的文件描述符中有一个达到就绪态，或者直到捕获到一个信号为止。

### poll()的返回值
作为函数的返回值，poll()会返回如下几种情况中的一种：

#### 返回−1 

表示有错误发生。一种可能的错误是 EINTR，表示该调用被一个信号处理例程中断。如果被信号处理例程中断，poll()绝不会自动恢复。

#### 返回 0 

表示该调用在任意一个文件描述符成为就绪态之前就超时了。

#### 返回正整数

表示有 1 个或多个文件描述符处于就绪态了。返回值表示数组 fds 中拥有非零 revents 字段的 pollfd 结构体数量。

### select()返回值与poll()的细微差别
注意 select()同 poll()返回正整数值时的细小差别。  

如果一个文件描述符在返回的描述符集合中出现了不止一次，系统调用 select()会将同一个文件描述符计数多次。  

而系统调用 poll()返回的是就绪态的文件描述符个数，且一个文件描述符只会统计一次，就算在相应的 revents 字段中设定了多个位掩码也是如此。  

## 文件描述符何时就绪

正确使用 select()和 poll()需要理解在什么情况下文件描述符会表示为就绪态。  

SUSv3中说：如果对 I/O 函数的调用不会阻塞，而不论该函数是否能够实际传输数据，此时文件描述符（未指定 O_NONBLOCK 标志）被认为是就绪的。  

select()和 poll()只会告诉我们 I/O操作是否会阻塞，而不是告诉我们到底能否成功传输数据。  

在各种类型的文件描述符上如何表示就绪，详见《Linux-Unix系统编程手册》P1101。  

## select()和 poll() 的异同点
### 实现细节
在 Linux 内核层面，select()和 poll()都使用了相同的内核 poll 例程集合（例程即函数）。这些 poll 例程有别于系统调用 poll()本身。每个例程都返回有关单个文件描述符就绪的信息。这个就绪信息以位掩码的形式返回，其值同 poll()系统调用中返回的 revents 字段中的比特值相关（见上表）。  

poll()系统调用的实现包括为每个文件描述符调用内核 poll 例程，并将结果信息填到对应的 revents字段中去。  

为了实现 select()，我们使用一组宏将内核 poll 例程返回的信息转化为由 select()返回的与之对应的事件类型。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/126.jpg" width = 60% height = 60% /></div>

这些宏定义展现了 select()和 poll()所返回的信息之间的语义关系。唯一一点我们需要额外增加的是，如果被检查的文件描述符当中有一个关闭了，poll()会在 revents 字段中返回 POLLNVAL，而 select()会返回−1 且将错误码设为 EBADF。

### API 之间的区别
以下是系统调用 select()和 poll()之间的一些区别。  

- select()所使用的数据类型 fd_set 对于被检查的文件描述符数量有一个上限限制（FD_SETSIZE）。在 Linux 下，这个上限值默认为 1024，修改这个上限需要重新编译应用程序。与之相反，poll()对于被检查的文件描述符数量本质上是没有限制的。
-由于 select()的参数 fd_set 同时也是保存调用结果的地方，如果要在循环中重复调用select()的话，我们必须每次都要重新初始化 fd_set。而 poll()通过独立的两个字段 events（针对输入）和 revents（针对输出）来处理，从而避免每次都要重新初始化参数。
- select()提供的超时精度（微秒）比 poll()提供的超时精度（毫秒）高。（这两个系统调用的超时精度都受软件时钟粒度的限制。）
- 如果其中一个被检查的文件描述符关闭了，通过在对应的 revents 字段中设定POLLNVAL 标记，poll()会准确告诉我们是哪一个文件描述符关闭了。与之相反，select()只会返回−1，并设错误码为 EBADF。通过在描述符上执行 I/O 系统调用并检查错误
码，让我们自己来判断哪个文件描述符关闭了。通常这些区别都不重要，因为应用程序一般都会自己跟踪已经关闭的文件描述符。  
### 可移植性
历史上，select()比 poll()使用得更加广泛。如今这两个接口都在 SUSv3 中标准化了，且都广泛存在于现代的 UNIX 实现中。   
同时poll()在不同的实现中行为上会有一些差别。  

### 性能
当如满足如下两条中任意一条时，poll()和 select()将具有相似的性能表现：  
- 待检查的文件描述符范围较小（即，最大的文件描述符号较低）。
- 有大量的文件描述符待检查，但是它们分布得很密集。（即，大部分或所有的文件描述符号都在 0 到某个上限之间）。

然而，如果被检查的文件描述符集合很稀疏的话，select()和 poll()的性能差异将变得非常明显。  

比如，最大文件描述符号 N 是个很大的整数，但在 0 到 N 之间只有 1 个或几个文件描述符要被检查。在这种情况下，poll()的性能表现将优于 select()。  

我们可以通过传递给这两个系统调用的参数来理解这其中的原因。  

在 select()中，我们传递一个或多个文件描述符集合，以及比待检查的集合中最大的文件描述符号还要大 1 的 nfds。不管我们是否要检查范围 0 到 nfds−1之间的所有文件描述符，nfds 的值都不变。无论哪种情况，内核都必须在每个集合中检查 nfds个元素，以此来查明到底需要检查哪个文件描述符。  

与之相反，当使用 poll()时，只需要指定我们感兴趣的文件描述符即可，内核只会去检查这些指定的文件描述符。  

【注】Linux 2.4 版中 poll()和 select()在稀疏的描述符集合中性能表现差异很大。在 2.6 版内核中通过一些优化手段，这个性能差异已经被极大地缩小了。  

## select()和 poll()存在的问题
系统调用 select()和 poll()是用来同时检查多个文件描述符就绪状态的方法，它们是可移植的、长期存在且被广泛使用的。但是当检查大量的文件描述符时，这两个 API 都会遇到一些问题。 

- 每次调用 select()或 poll()，内核都必须检查所有被指定的文件描述符，看它们是否处于就绪态。当检查大量处于密集范围内的文件描述符时，该操作耗费的时间将大大超过接下来的操作。  
- 每次调用 select()或 poll()时，程序都必须传递一个表示所有需要被检查的文件描述符的数据结构到内核，内核检查过描述符后，修改这个数据结构并返回给程序。（此外，对于 select()来说，我们还必须在每次调用前初始化这个数据结构。）对于 poll()来说，随着待检查的文件描述符数量的增加，传递给内核的数据结构大小也会随之增加。当检查大量文件描述符时，从用户空间到内核空间来回拷贝这个数据结构将占用大量的 CPU 时间。对于 select()来说，这个数据结构的大小固定为FD_SETSIZE，与待检查的文件描述符数量无关。  

- select()或 poll()调用完成后，程序必须检查返回的数据结构中的每个元素，以此查明哪个文件描述符处于就绪态了。

上述要点产生的结果就是随着待检查的文件描述符数量的增加，select()和 poll()所占用的CPU 时间也会随之增加。对于需要检查大量文件描述符的程序来说，这就产生了问题。  

select()和 poll()糟糕的性能延展性源自这些 API 的局限性：  
通常，程序重复调用这些系统调用所检查的文件描述符集合都是相同的，可是内核并不会在每次调用成功后就记录下它们。  

我们接下来要讨论的信号驱动 I/O 以及 epoll 都可以使内核记录下进程中感兴趣的文件描述符，通过这种机制消除了select()和 poll()的性能延展问题。这种解决方案可根据发生的 I/O事件来延展，而与被检查的文件描述符个数无关。结果就是，当需要检查大量的文件描述符时，信号驱动 I/O 和 epoll 能提供更好的性能表现。  

# 信号驱动 I/O 
在 I/O 多路复用中，进程是通过系统调用（select()或 poll()）来检查文件描述符上是否可以执行 I/O 操作。而在信号驱动 I/O 中，当文件描述符上可执行 I/O 操作时，进程请求内核为自己发送一个信号。之后进程就可以执行任何其他的任务直到 I/O 就绪为止，此时内核会发送信号给进程。  

## 要使用信号驱动 I/O，程序需要按照如下步骤来执行
- 为内核发送的通知信号安装一个信号处理例程。默认情况下，这个通知信号为 SIGIO。
- 设定文件描述符的属主，也就是当文件描述符上可执行 I/O 时会接收到通知信号的进程或进程组。通常我们让调用进程成为属主。设定属主可通过 fcntl()的 F_SETOWN 操作来完成：
```C
fcntl(fd,F_SETOWN,pid);
```
- 通过设定 O_NONBLOCK 标志使能非阻塞 I/O。
- 通过打开 O_ASYNC 标志使能信号驱动 I/O。这可以和上一步合并为一个操作，因为它们都需要用到 fcntl()的 F_SETFL 操作。
```C
flag = fcntl(fd,F_GETFL);
fcntl(fd,F_SETFL,FLAGS | O_ASYNC | O_NONBLOCK);
```
- 调用进程现在可以执行其他的任务了。当 I/O 操作就绪时，内核为进程发送一个信号，然后调用在第 1 步中安装好的信号处理例程。
- 信号驱动 I/O 提供的是边缘触发通知（见 63.1.1 节）。这表示一旦进程被通知 I/O 就绪，它就应该尽可能多地执行I/O（例如尽可能多地读取字节）。假设文件描述符是非阻塞式的，这表示需要在循环中执行 I/O 系统调用直到失败为止，此时错误码为 EAGAIN 或EWOULDBLOCK。

历史上，信号驱动 I/O 有时也被称为异步 I/O，这一点从相关的打开文件标志（O_ASYNC）中就能看出来。但是，如今术语异步 I/O 是用来表示由 POSIX AIO 规范所提供的功能。使用POSIX AIO 时，进程请求内核执行一次 I/O 操作，内核启动该操作之后立刻将控制权还给调用进程，稍后当 I/O 操作完成或有错误发生时，该进程会得到通知。  

## 在启动信号驱动 I/O 前安装信号处理例程
由于接收到 SIGIO 信号的默认行为是终止进程运行，因此我们应该在启动信号驱动 I/O 前先为 SIGIO 信号安装处理例程。如果我们在安装 SIGIO 信号处理例程之前先启动了信号驱动I/O，那么会存在一个时间间隙，此时如果 I/O 就绪的话内核发送过来的 SIGIO 信号就会使进程终止运行。  

## 设定文件描述符属主
我们使用 fcntl()来设定文件描述符的属主，方式如下：
```C
fcntl(fd,F_SETOWN,pid);
```
我们可以指定一个单独的进程或者是进程组中的所有进程在文件描述符 I/O 就绪时收到信号通知。如果参数 pid 为正整数，就解释为进程 ID 号。如果参数 pid 是负数，它的绝对值就指定了进程组 ID 号。   

通常会在 pid 中指定调用进程的进程 ID 号（这样信号就会发送给打开这个文件描述符的进程）。但是，也可以将其指定为另一个进程或进程组（例如，调用者进程组），而信号会发送给这个目标，取决于如 20.5 节中所述的权限检查，这里发送进程会作为完成 F_SETOWN操作的进程。  

当指定的文件描述符上可执行 I/O 时，fcntl()的 F_GETOWN 操作会返回接收到信号的进程或进程组 ID 号。
```C
id = fcntl(fd,F_GETOWN);
if(id == -1) errExit("fcntl");
```
进程组 ID 号以负数的形式由该调用返回。

## 何时发送“I/O 就绪”信号(详见书P1109)
### 终端和伪终端
### 管道和 FIFO 
### 套接字
### inotify 文件描述符

## 优化信号驱动 I/O 的使用
在需要同时检查大量文件描述符（比如数千个）的应用程序中—例如某种类型的网络服务端程序—同 select()和 poll()相比，信号驱动 I/O 能提供显著的性能优势。信号驱动 I/O能达到这么高的性能是因为内核可以“记住”要检查的文件描述符，且仅当 I/O 事件实际发生在这些文件描述符上时才会向程序发送信号。结果就是采用信号驱动 I/O 的程序性能可以根据发生的 I/O 事件的数量来扩展，而与被检查的文件描述符的数量无关。  

### 要想全部利用信号驱动 I/O 的优点，我们必须执行下面两个步骤
- 系统默认IO信号SIGIO存在问题——通过专属于 Linux 的 fcntl() F_SETSIG 操作来指定一个实时信号，当文件描述符上的I/O 就绪时，这个实时信号应该取代 SIGIO 被发送。
- 使用SA_SIGINFO可以返回I/O准备就绪的文件描述符信息——使用 sigaction()安装信号处理例程时，为前一步中使用的实时信号指定 SA_SIGINFO标记

fcntl()的 F_SETSIG 操作指定了一个可选的信号，当文件描述符上的 I/O 就绪时会取代SIGIO 信号被发送。  
```C
if(fcntl(fd,F_SETSIG,sig) == -1) errExit("fcntl");
```
F_GETSIG 操作完成的任务同 F_SETSIG 相反，它取回当前为文件描述符指定的信号。  
```C
sig = fcntl(fd,F_GETSIG);
if(sig == -1) errExit("fcntl");
```
为了在头文件<fcntl.h>中得到 F_SETSIG 和 F_GETSIG 的定义，我们必须定义测试宏_GNU_SOURCE。  

### 使用 F_SETSIG 来改变用于通知“I/O 就绪”信号的两个理由
使用 F_SETSIG 来改变用于通知“I/O 就绪”的信号有两个理由，如果我们需要在多个文件描述符上检查大量的 I/O 事件，这两个理由都是必须的。  
- 默认的“I/O 就绪”信号 SIGIO 是标准的非排队信号之一。如果有多个 I/O 事件发送了信号，而 SIGIO 被阻塞了—也许是因为 SIGIO 信号的处理例程已经被调用了—除了第一个通知外，其他后序的通知都会丢失。如果我们通过 F_SETSIG 来指定一个实时信号作为“I/O 就绪”的通知信号，那么多个通知就能排队处理。  

- 如果信号处理例程是通过 sigaction()来安装，且在 sa.sa_flags 字段中指定了 SA_ SIGINFO 标志，那么结构体siginfo_t 会作为第二个参数传递给信号处理例程。这个结构体包含的字段标识出了在哪个文件描述符上发生了事件，以及事件的类型。  

注意，需要同时使用 F_SETSIG 以及 SA_SIGINFO 才能将一个合法的 siginfo_t 结构体传递到信号处理例程中去。  

如果我们做 F_SETSIG 操作时将参数 sig 指定为 0，那么将导致退回到默认的行为：发送的信号仍然是 SIGIO，而且结构体 siginfo_t 将不会传递给信号处理例程。


### 对于“I/O 就绪”事件，传递给信号处理例程的结构体 siginfo_t 中与之相关的字段
- si_signo：引发信号处理例程得到调用的信号值。这个值同信号处理例程的第一个参数一致。
- si_fd：发生 I/O 事件的文件描述符。
- si_code：表示发生事件类型的代码。该字段中可出现的值以及它们的描述参见表。
- si_band：一个位掩码。其中包含的位和系统调用 poll()中返回的 revents 字段中的位相同。如表所示，si_code 中可出现的值同 si_band 中的位掩码有着一一对应的关系。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/127.jpg" width = 60% height = 60% /></div>

在一个纯输入驱动的应用程序中，我们可以进一步优化使用 F_SETSIG。  

我们可以阻塞待发出的“I/O 就绪”信号，然后通过 sigwaitinfo()或 sigtimedwait()来接收排队中的信号。这些系统调用返回的 siginfo_t 结构体所包含的信息同传递给信号处理例程的 siginfo_t结构体一样。以这种方式接收信号，我们实际是以同步的方式在处理事件，但同 select()和 poll()相比，这种方法能够高效地获知文件描述符上发生的 I/O 事件。  

## 信号队列溢出的处理
我们在之前已经知道，可以排队的实时信号的数量是有限的。如果达到这个上限，内核对于“I/O 就绪”的通知将恢复为默认的 SIGIO 信号。  

出现这种现象表示信号队列溢出了。当出现这种情况时，我们将失去有关文件描述符上发生 I/O 事件的信息，因为 SIGIO 信号是不会排队的。（此外，SIGIO 的信号处理例程不接受 siginfo_t 结构体参数，这意味着信号处理例程不能确定是哪一个文件描述符上产生了信号。）  

我们可以通过增加可排队的实时信号数量的限制来减小信号队列溢出的可能性。但是这并不能完全消除溢出的可能。一个设计良好的采用 F_SETSIG 来建立实时信号作为“I/O 就绪”通知的程序必须也要为信号 SIGIO 安装处理例程。如果发送了 SIGIO 信号，那么应用程序可以先通过 sigwaitinfo()将队列中的实时信号全部获取，然后临时切换到 select()或 poll()，通过它们获取剩余的发生 I/O 事件的文件描述符列表。  

## 在多线程程序中使用信号驱动 I/O 
从 2.6.32 版内核开始，Linux 提供了两个新的非标准的 fcntl()操作，可用于设定接收“I/O 就绪”信号的目标，它们是 F_SETOWN_EX 和 F_GETOWN_EX。  

F_SETOWN_EX 操作类似于 F_SETOWN，但除了允许指定进程或进程组作为接收信号的目标外，它还可以指定一个线程作为“I/O 就绪”信号的目标。对于这个操作，fcntl()的第三个参数为指向如下结构体的指针。  

```C
 struct f_owner_ex{
          int type;
          pid_t pid;
 };
```
结构体中 type 字段定义了 pid 的类型，它可以有如下几种值：

- F_OWNER_PGRP：字段 pid 指定了作为接收“I/O 就绪”信号的进程组 ID。与 F_SETOWN 不同的是，这里进程组 ID 指定为一个正整数。
- F_OWNER_PID：字段 pid 指定了作为接收“I/O 就绪”信号的进程 ID。
- F_OWNER_TID：字段 pid 指定了作为接收“I/O 就绪”信号的线程 ID。这里 pid 的值为 clone()或 getpid()的返回值。


F_GETOWN_EX 为 F_SETOWN_EX 的逆操作。它使用 fcntl()的第三个参数所指向的结构体 f_owner_ex 来返回之前由 F_SETOWN_EX 操作所定义的设置。  

因为 F_SETOWN_EX 和 F_GETOWN_EX 操作以正整数来代表进程组 ID，所以F_GETOWN_EX 将不会遇到之前在描述 F_GETOWN 操作时说到的进程组 ID 小于 4096 时会出现的问题。  

# epoll 编程接口
## epoll概述
同 I/O 多路复用和信号驱动 I/O 一样，Linux 的 epoll（event poll）API 可以检查多个文件描述符上的 I/O 就绪状态。  

epoll API 是 Linux 系统专有的，在 2.6 版中新增。  

epoll API 的核心数据结构称作 epoll 实例，它和一个打开的文件描述符相关联。这个文件描述符不是用来做 I/O 操作的，相反，它是内核数据结构的句柄，这些内核数据结构实现了两个目的。  
- 记录了在进程中声明过的感兴趣的文件描述符列表—interest list（兴趣列表）。
- 维护了处于 I/O 就绪态的文件描述符列表—ready list（就绪列表）。  

ready list 中的成员是 interest list 的子集。  

对于由 epoll 检查的每一个文件描述符，我们可以指定一个位掩码来表示我们感兴趣的事件。这些位掩码同 poll()所使用的位掩码有着紧密的关联。  

epoll API 由以下 3 个系统调用组成。
- 系统调用 epoll_create()创建一个 epoll 实例，返回代表该实例的文件描述符。
- 系统调用 epoll_ctl()操作同 epoll 实例相关联的兴趣列表。通过 epoll_ctl()，我们可以增加新的描述符到列表中，将已有的文件描述符从该列表中移除，以及修改代表文件描述符上事件类型的位掩码。
- 系统调用 epoll_wait()返回与 epoll 实例相关联的就绪列表中的成员。  

## epoll API 的主要优点
- 当检查大量的文件描述符时，epoll 的性能延展性比 select()和 poll()高很多。
- epoll API 既支持水平触发也支持边缘触发。与之相反，select()和 poll()只支持水平触发，而信号驱动 I/O 只支持边缘触发。
性能表现上，epoll 同信号驱动 I/O 相似。但是，epoll 有一些胜过信号驱动 I/O 的优点。  
- 可以避免复杂的信号处理流程（比如信号队列溢出时的处理）。
- 灵活性高，可以指定我们希望检查的事件类型（例如，检查套接字文件描述符的读就绪、写就绪或者两者同时指定）。  

## epoll系统调用
### 创建 epoll 实例：epoll_create() 
系统调用 epoll_create()创建了一个新的 epoll 实例，其对应的兴趣列表初始化为空。
```C
#include<sys/epoll.h>
int epoll_create(int size);
```
参数 size 指定了我们想要通过 epoll 实例来检查的文件描述符个数。该参数并不是一个上限，而是告诉内核应该如何为内部数据结构划分初始大小。（从 Linux 2.6.8 版以来，size 参数被忽略不用，因为内核实现做了修改意味着该参数之前提供的信息已经不再需
要了。）  

作为函数返回值，epoll_create()返回了代表新创建的 epoll 实例的文件描述符。这个文件描述符在其他几个 epoll 系统调用中用来表示 epoll 实例。当这个文件描述符不再需要时，应该通过 close()来关闭。当所有与 epoll 实例相关的文件描述符都被关闭时，实例被销毁，相关的资源都返还给系统。（多个文件描述符可能引用到相同的 epoll 实例，这是由于调用了 fork()或者 dup()这样类似的函数所致。）  

> 从 2.6.27 版内核以来，Linux 支持了一个新的系统调用 epoll_create1()。该系统调用执行的任务同 epoll_create()一样，但是去掉了无用的参数 size，并增加了一个可用来修改系统调用行为的 flags 参数。目前只支持一个 flag 标志：EPOLL_CLOEXEC，它使得内核在新的文件描述符上启动了执行即关闭（close-on-exec）标志（FD_CLOEXEC）。出于同样的原因，这个标志同 4.3.1 节中描述的 open()的 O_CLOEXEC 标志一样有用。  

### 修改 epoll 的兴趣列表：epoll_ctl() 
系统调用 epoll_ctl()能够修改由文件描述符 epfd 所代表的 epoll 实例中的兴趣列表。  

```C
#include<sys/epoll.h>
int epoll_ctl(int epfd,int op,int fd,struct epoll_event *ev);
```
参数 fd 指明了要修改兴趣列表中的哪一个文件描述符的设定。该参数可以是代表管道、FIFO、套接字、POSIX 消息队列、inotify 实例、终端、设备，甚至是另一个 epoll 实例的文件描述符（例如，我们可以为受检查的描述符建立起一种层次关系）。但是，这里 fd 不能作为普通文件或目录的文件描述符（会出现 EPERM 错误）。

#### 参数 op 用来指定需要执行的操作，它可以是如下几种值
- EPOLL_CTL_ADD 
将描述符 fd 添加到 epoll 实例 epfd 中的兴趣列表中去。对于 fd 上我们感兴趣的事件，都指定在 ev 所指向的结构体中，下面会详细介绍。如果我们试图向兴趣列表中添加一个已存在的文件描述符，epoll_ctl()将出现 EEXIST 错误。
- EPOLL_CTL_MOD 
修改描述符 fd 上设定的事件，需要用到由 ev 所指向的结构体中的信息。如果我们试图修改不在兴趣列表中的文件描述符，epoll_ctl()将出现 ENOENT 错误。
- EPOLL_CTL_DEL 
将文件描述符 fd 从 epfd 的兴趣列表中移除。该操作忽略参数 ev。如果我们试图移除一个不在 epfd 的兴趣列表中的文件描述符，epoll_ctl()将出现 ENOENT 错误。关闭一个文件描述符会自动将其从所有的 epoll 实例的兴趣列表中移除。

#### 参数 ev 是指向结构体 epoll_event 的指针，结构体的定义如下
```C
struct epoll_event{
          uint32_t events;    //epoll events(bit mask)
          epoll_data_t data;  //User data
}
```
#### 结构体 epoll_event 中的 data 字段的类型
```C
typedef union epoll_data{
          void *ptr;          //Pointer to user-defined data
          int fd;             //File descripter
          uint32_t u32;       //32-bit integer
          uint64_t u64;       //64-bit integer
} epoll_data_t;
```
#### 参数 ev 为文件描述符 fd 所做的设置如下。
- 结构体 epoll_event 中的 events 字段是一个位掩码，它指定了我们为待检查的描述符 fd 上所感兴趣的事件集合。
- data 字段是一个联合体，当描述符 fd 稍后成为就绪态时，联合体的成员可用来指定传回给调用进程的信息。  

#### max_user_watches 上限  
因为每个注册到 epoll 实例上的文件描述符需要占用一小段不能被交换的内核内存空间，因此内核提供了一个接口用来定义每个用户可以注册到 epoll 实例上的文件描述符总数。这个上限值可以通过 max_user_watches 来查看和修改。max_user_watches 是专属于Linux 系统的/proc/sys/fd/epoll 目录下的一个文件。默认的上限值根据可用的系统内存来计算得出（参见epoll(7)的用户手册页）。

### 事件等待：epoll_wait()
系统调用 epoll_wait()返回 epoll 实例中处于就绪态的文件描述符信息。单个 epoll_wait()调用能返回多个就绪态文件描述符的信息。

```C
#include<sys/epoll.h>
int epoll_wait(int epfd,struct epoll_event *evlist,int maxevents,int timeout);
```
参数 evlist 所指向的结构体数组中返回的是有关就绪态文件描述符的信息。（结构体epoll_event 已经在上一节中描述。）数组 evlist 的空间由调用者负责申请，所包含的元素个数在参数 maxevents 中指定。  

在数组 evlist 中，每个元素返回的都是单个就绪态文件描述符的信息。events 字段返回了在该描述符上已经发生的事件掩码。Data 字段返回的是我们在描述符上使用 cpoll_ctl()注册感兴趣的事件时在 ev.data 中所指定的值。注意，data 字段是唯一可获知同这个事件相关的文件描述符号的途径。因此，当我们调用 epoll_ctl()将文件描述符添加到兴趣列表中时，应该要么将 ev.data.fd 设为文件描述符号（如程序清单 63-4 中所示），要么将 ev.data.ptr 设为指向包含文件描述符号的结构体。  

调用成功后，epoll_wait()返回数组 evlist 中的元素个数。如果在 timeout 超时间隔内没有任何文件描述符处于就绪态的话，返回 0。出错时返回−1，并在 errno 中设定错误码以表示错误原因。  

在多线程程序中，可以在一个线程中使用 epoll_ctl()将文件描述符添加到另一个线程中由epoll_wait()所监视的 epoll 实例的兴趣列表中去。这些对兴趣列表的修改将立刻得到处理，而epoll_wait()调用将返回有关新添加的文件描述符的就绪信息。 

#### 参数 timeout 用来确定 epoll_wait()的阻塞行为
- 如果 timeout 等于−1，调用将一直阻塞，直到兴趣列表中的文件描述符上有事件产生，或者直到捕获到一个信号为止。
- 如果 timeout 等于 0，执行一次非阻塞式的检查，看兴趣列表中的文件描述符上产生了哪个事件。
- 如果 timeout 大于 0，调用将阻塞至多 timeout 毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止。  


#### epoll 事件
当我们调用 epoll_ctl()时可以在 ev.events 中指定的位掩码以及由 epoll_wait()返回的evlist\[].events 中的值在表中给出。  

除了有一个额外的前缀 E 外，大多数这些位掩码的名称同 poll()中对应的事件掩码名称相同。（例外情况是 EPOLLET 和 EPOLLONESHOT，下面我们会给出更详细的说明。）这种名称上有着对应关系的原因是当我们在 epoll_ctl()中指定输入，或通过 epoll_wait()得到输出时，这些比特位表达的意思同对应的 poll()的事件掩码所表达的意思一样。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/128.jpg" width = 60% height = 60% /></div>  


#### EPOLLONESHOT 标志
如果希望在某个文件描述符上只得到一次通知，可以使用EPOLLONESHOT 标志。  

默认情况下，一旦通过 epoll_ctl()的 EPOLL_CTL_ADD 操作将文件描述符添加到 epoll 实例的兴趣列表中后，它会保持激活状态（即，之后对 epoll_wait()的调用会在描述符处于就绪态时通知我们）直到我们显式地通过 epoll_ctl()的 EPOLL_CTL_DEL 操作将其从列表中移除。   

如果我们希望在某个特定的文件描述符上只得到一次通知，那么可以在传给 epoll_ctl()的ev.events 中指定 EPOLLONESHOT（从 Linux 2.6.2 版开始支持）标志。如果指定了这个标志，那么在下一个 epoll_wait()调用通知我们对应的文件描述符处于就绪态之后，这个描述符就会在兴趣列表中被标记为非激活态，之后的 epoll_wait()调用都不会再通知我们有关这个描述符的状态了。  

如果需要，我们可以稍后通过 epoll_ctl()的 EPOLL_CTL_ MOD 操作重新激活对这个文件描述符的检查。（这种情况下不能用 EPOLL_CTL_ADD 操作，因为非激活态的文件描述符仍然还在 epoll 实例的兴趣列表中。）  


## epoll程序示例
见P1117，例子非常清晰

## 深入探究 epoll 的语义——epoll更关注文件描述
### 文件描述
文件描述（file description）表示的是一个打开文件的上下文信息（大小、内容、编码等与文件有关的信息），可以比喻为一个抽屉，这部分内容实际上是由内核来管理的。  

而用户空间的应用程序如果要操作文件怎么办。就是通过open()这样的系统调用向内核请求，然后内核分配给用户空间一个文件描述符（file descriptor）。这个文件描述符可以比喻为抽屉的把手（handle之所以翻译为“句柄”，这就是原因），有了这个把手（文件描述符），用户就可以操作抽屉（文件描述）里的内容了。  

但是，一个抽屉可以有多个把手（即文件描述可以对应多个文件描述符），只有当所有的把手（文件描述符）都关闭了，内核就知道此时没有用户空间的程序要用这个抽屉了（文件描述），那么就把它回收。  

文件描述实际上是内核中的一个数据结构，而用户空间中的文件描述符只不过是一个整数，epoll 的兴趣列表实际关注的是内核中的数据结构。  

### epoll关注文件描述的过程
当我们通过 epoll_create()创建一个 epoll 实例时，内核在内存中创建了一个新的 i-node 并打开文件描述，随后在调用进程中为打开的这个文件描述分配一个新的文件描述符。同epoll 实例的兴趣列表相关联的是打开的文件描述，而不是 epoll 文件描述符。这将产生下列结果。  

- 如果我们使用 dup()（或类似的函数）复制一个 epoll 文件描述符，那么被复制的描述符所指代的 epoll 兴趣列表和就绪列表同原始的 epoll 文件描述符相同。若要修改兴趣列表，在 epoll_ctl()的参数 epfd 上设定文件描述符可以是原始的也可以是复制的。
- 上一条观点同样也适用于 fork()调用之后的情况。此时子进程通过继承复制了父进程的 epoll 文件描述符，而这个复制的文件描述符所指向的 epoll 数据结构同原始的描述符相同。

当我们执行 epoll_ctl()的 EPOLL_CTL_ADD 操作时，内核在 epoll 兴趣列表中添加了一个元素，这个元素同时记录了需要检查的文件描述符数量以及对应的打开文件描述的引用。  

epoll_wait()调用的目的就是让内核负责监视打开的文件描述。  

这表示我们必须对之前的观点做改进：如果一个文件描述符是 epoll 兴趣列表中的成员，当关闭它后会自动从列表中移除。  

改进版应该是这样的：一旦所有指向打开的文件描述的文件描述符都被关闭后，这个打开的文件描述将从 epoll 的兴趣列表中移除。  

这表示如果我们通过 dup()（或类似的函数）或者 fork()为打开的文件创建了描述符副本，那么这个打开的文件只会在原始的描述符以及所有其他的副本都被关闭时才会移除。  

## poll()、select()以及 epoll性能对比

下表展示了当我们使用 poll()、select()以及 epoll 监视 0 到 N−1 的 N 个连续文件描述符时的结果（在 2.6.25 版内核上）。  

该测试设定为在每次监视中，只有一个随机选择的
文件描述符处于就绪态。  

从这个表格中，我们发现随着被监视的文件描述符数量的上升，poll()和 select()的性能表现越来越差。  

与之相反，当 N 增长到很大的值时，epoll 的性能表现几乎不会降低。（当 N 值上升时，微小的性能下降可能是由于测试系统上的 CPU cache达到了上限。）  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/129.jpg" width = 60% height = 60% /></div>  

## 为什么epoll 的性能表现更好
- 每次调用 select()和 poll()时，内核必须检查所有在调用中指定的文件描述符。与之相反，当通过 epoll_ctl()指定了需要监视的文件描述符时，内核会在与打开的文件描述上下文相关联的列表中记录该描述符。之后每当执行 I/O 操作使得文件描述符成为就绪态时，内核就在 epoll 描述符的就绪列表中添加一个元素。（单个打开的文件描述上下文中的一次 I/O 事件可能导致与之相关的多个文件描述符成为就绪态。）之后的epoll_wait()调用从就绪列表中简单地取出这些元素。  

- 每次调用 select()或 poll()时，我们传递一个标记了所有待监视的文件描述符的数据结构给内核，调用返回时，内核将所有标记为就绪态的文件描述符的数据结构再传回给我们。与之相反，在 epoll 中我们使用 epoll_ctl()在内核空间中建立一个数据结构，该数据结构会将待监视的文件描述符都记录下来。一旦这个数据结构建立完成，稍后每次调用 epoll_wait()时就不需要再传递任何与文件描述符有关的信息给内核了，而调用返回的信息中只包含那些已经处于就绪态的描述符。  

> 除了以上几点外，对于 select()来说，我们必须在每次调用之前先初始化输入数据。而无论是 select()还是 poll()，我们必须对返回的数据结构做检查，以此找出 N 个文件描述符中有哪些是处于就绪态的。但是，通过一些测试得出的结果表明，这些额外的步骤所花费的时间同系统调用监视 N 个文件描述符所花费的时间相比就显得微不足道了。上表并没有包含这些检查步骤所用的时间。  

## 性能对比结论
粗略来看，我们可以认为当 N（被监视的文件描述符数量）取值很大时，select()和 poll()的性能会随着 N 的增大而线性下降。这可以从表 63-9 中 N=100 和 N=1000 时的情况得到。而当N=10000 时，性能伸缩性实际上比线性还要差。  

与之相反的是，epoll 的性能会根据发生 I/O 事件的数量而扩展（呈线性）。因此常见的能够高效使用 epoll API 的应用场景就是需要同时处理许多客户端的服务器：需要监视大量的文件描述符，但大部分处于空闲状态，只有少数文件描述符处于就绪态。  

## 边缘触发通知

**默认情况下 epoll 提供的是水平触发通知。**  

这表示 epoll 会告诉我们何时能在文件描述符上以非阻塞的方式执行 I/O 操作。这同 poll()和 select()所提供的通知类型相同。  

epoll API 还能以边缘触发方式进行通知—也就是说，会告诉我们自从上一次调用epoll_wait()以来文件描述符上是否已经有新的I/O 活动了（或者由于描述符被打开了，如果之前没有调用的话）。  

使用 epoll 的边缘触发通知在语义上类似于信号驱动 I/O，只是如果有多个 I/O事件发生的话，epoll 会将它们合并成一次单独的通知，通过 epoll_wait()返回，而在信号驱动I/O 中则可能会产生多个信号。  


要使用边缘触发通知，我们在调用 epoll_ctl()时在 ev.events 字段中指定 EPOLLET标志。

```C
struct epoll_event ev;
ev.data.fd = fd;
ev.events = EPOLLIN | EPOLLET;
if(epoll_ctl(epfd,EPOLL_CTL_ADD,fd,ev) == -1) errExit("epoll_ctl");
``` 

### 通过一个例子来说明 epoll 的水平触发和边缘触发通知之间的区别
假设我们使用epoll 来监视一个套接字上的输入（EPOLLIN），接下来会发生如下的事件。  
1. 套接字上有输入到来。  
2. 我们调用一次 epoll_wait()。无论我们采用的是水平触发还是边缘触发通知，该调用都会告诉我们套接字已经处于就绪态了。  
3. 再次调用 epoll_wait()。  

如果我们采用的是水平触发通知，那么第二个 epoll_wait()调用将告诉我们套接字处于就绪态。  

而如果我们采用边缘触发通知，那么第二个 epoll_wait()调用将阻塞，因为自从上一次调用 epoll_wait()以来并没有新的输入到来。  

### 边缘触发通知通常和非阻塞的文件描述符结合使用
边缘触发通知通常和非阻塞的文件描述符结合使用。因而，采用 epoll 的边缘触发通知机制的程序基本框架如下。  
- 让所有待监视的文件描述符都成为非阻塞的。
- 通过 epoll_ctl()构建 epoll 的兴趣列表。
- 通过如下的循环处理 I/O 事件。  
   - 通过 epoll_wait()取得处于就绪态的描述符列表。
   - 针对每一个处于就绪态的文件描述符，不断进行 I/O 处理直到相关的系统调用（例如 read()、write()、recv()、send()或 accept()）返回 EAGAIN 或 EWOULDBLOCK错误。


### 边缘触发通知常见问题——文件描述符饥饿现象
假设我们采用边缘触发通知监视多个文件描述符，其中一个处于就绪态的文件描述符上有着大量的输入存在（可能是一个不间断的输入流）。如果在检测到该文件描述符处于就绪态后，我们将尝试通过非阻塞式的读操作将所有的输入都读取，那么此时就会有使其
他的文件描述符处于饥饿状态的风险存在（即，在我们再次检查这些文件描述符是否处于就绪态并执行 I/O 操作前会有很长的一段处理时间）。  

该问题的一种解决方案是让应用程序维护一个列表，列表中存放着已经被通知为就绪态的文件描述符。通过一个循环按照如下方式不断处理。  

- 调用 epoll_wait()监视文件描述符，并将处于就绪态的描述符添加到应用程序维护的列表中。如果这个文件描述符已经注册到应用程序维护的列表中了，那么这次监视操作的超时时间应该设为较小的值或者是 0。这样如果没有新的文件描述符成为就绪态，应用程序就可以迅速进行到下一步，去处理那些已经处于就绪态的文件描述符了。  

- 在应用程序维护的列表中，只在那些已经注册为就绪态的文件描述符上进行一定限度的 I/O 操作（可能是以轮转调度（round-robin）方式循环处理，而不是每次 epoll_wait()调用后都从列表头开始处理）。当相关的非阻塞 I/O 系统调用出现 EAGAIN 或EWOULDBLOCK 错误时，文件描述符就可以从应用程序维护的列表中移除了。  

尽管采用这种方法需要做些额外的编程工作，但是除了能避免出现文件描述符饥饿现象外，我们还能获得其他益处。比如，我们可以在上述循环中加入其他的步骤，比如处理定时器以及用 sigwaitinfo()（或其他类似的机制）来接收信号。  

因为信号驱动 I/O 也是采用的边缘触发通知机制，因此也需要考虑文件描述符饥饿的情况。与之相反，在采用水平触发通知机制的应用程序中，考虑文件描述符饥饿的情况并不是必须的。这是因为我们可以采用水平触发通知在非阻塞式的文件描述符上通过循环连续地检
查描述符的就绪状态，然后在下一次检查文件描述符的状态前在处于就绪态的描述符上做一些 I/O 处理就可以了。  


