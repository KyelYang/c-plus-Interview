# 进程与线程
## 面试问题汇总
- 有没有多进程和多线程的开发经验，怎么同步，怎么通信
- 进程和线程的区别，进程间通信方式
- 解释孤儿进程，僵死进程，惊群效应
- 进程间通信方式有哪些？具体介绍一下管道？
- 一个进程内存空间都有什么
- 进程和线程的区别
- 进程共享了什么资源
- 线程不共享什么资源
- 进程通信的机制
- 你为啥觉得共享内存的效率最高
- 单核的CPU中跑8个进程是怎么做的
- 单核的CPU中跑8个进程和8核的CPU跑8个线程那个快，如果是8核的CPU跑64个线程呢
- 进程和线程有什么区别
- 僵尸进程？为什么这么设计？怎样避免僵尸进程呢
- 进程通信方式
- 线程有什么共享资源和独占资源
- 线程栈溢出会影响别的线程吗？
- 进程间通信
- 管道如何解决并发问题
- 如何监控进程异常退出
- 如果进程没有退出，但是处于异常状态 比如死循环或者挂起？
- 如何判断进程是由于死循环造成的100%cpu占用还是由于进行着一个及其耗资源的计算造成的100%cpu占用
- 进程和线程什么区别？线程有哪些独立的资源？
- 线程的状态都有哪些？
- 是否了解协程？讲一讲协程的原理
- 进程的状态？线程的状态？
- 进程通信方式
- 进程通信方式
- 进程与线程的区别？
- 僵尸进程
- 孤儿进程
- 进程与线程的区别（谁都问，大家都知道）
- 进程与线程的区别和联系
- 一个进程可以创建多少线程，和什么有关
- 进程调度方法详细介绍
- 怎么回收线程
- 僵尸进程问题
- 多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）
- 近程的通信里面的管道通信，有哪几种（命名和非命名）。写一个管道通信的命令，问第一个进程的输出传递给第二个进程的输入，那么它还保存这个数据吗
- 线程的状态有几种，画出状态转换图
- 进程和线程有什么区别，如何产生一个进程，子进程和父进程的内存空间是独立的吗，fork的原理，fork之后的子进程为什么会调用close
- 进程和线程了解吗，有啥区别？线程之间怎么同步的？
- 考虑你有一个服务，可能会起十个进程，如果某一个进程挂了，需要能感知到并且重新拉起来，请问你会怎么设计？
线程之间是怎么同步的呢？同一台机器上的进程之间如何做到互斥的进行某个操作呢？
- 进程间通信的方式，共享内存的原理
- 进程和线程的区别，进程调度算法，如何创建进程和线程，进程和线程的底层实现
- 已知进程名，使用命令查看当前进程打开的文件句柄？
- 已知进程名，使用命令查看当前进程的网络连接状态？
- 进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）
- 进程和线程的联系和区别，Linux下进程的通信方式IPC，进程调度的算法（讲了先来先服务、短作业优先、轮转、最高响应比），分别分析每一种的优缺点，死锁的产生条件，怎么解决死锁问题，怎么检测出死锁（怎么检测出死锁不知道）
- linux中的僵尸进程，怎么产生，怎么处理
- 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）
- Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令
- Linux进程调度算法
- Linux进程地址空间分布
- 惊群效应，如何避免

# 进程与线程
## 多线程无锁访问请求
使用先进先出队列（fifo）,串行获取请求。  
- [多线程访问共享内存的不加锁实现方式](https://www.cnblogs.com/zl1991/p/4758860.html)
- [超厉害的博客：如何实现超高并发的无锁缓存？](https://www.w3cschool.cn/architectroad/architectroad-high-concurrent-lockless-cache.html)

## 线程安全问题
### C++ stl库都不是线程安全的
在STL容器（和大多数厂商的愿望）里对多线程支持的黄金规则已经由SGI定义。大体上说，你能从实现里确定的最多是下列内容：
- 多个读取者是安全的。多线程可能同时读取一个容器的内容，这将正确地执行。当然，在读取时不能有任何写入者操作这个容器。
- 对不同容器的多个写入者是安全的。多线程可以同时写不同的容器。  

因此不能对STL容器的线程安全有任何期待。（来源：《effective stl》条款12）   

根据《Java Concurrency in Practice》的定义，一个线程安全的class应当满足以下三个条件：
- 多个线程同时访问时，其表现出正确的行为。
- 无论操作系统如何调度这些线程， 无论这些线程的执行顺序如何交织（interleaving）。
- 调用端代码无须额外的同步或其他协调动作。  

依据这个定义，C++ 标准库里的大多数class都不是线程安全的，包括std::string、std::vector、std::map、std::shared_ptr 等等。  

而C系统库大多数函数是线程安全的，包括 malloc/free/printf/gettimeofday 等等。

- [当我们在谈论XX是否线程安全时，我们在谈论什么？](https://www.zhihu.com/question/23244293)
- [如果你这样回答“什么是线程安全”，面试官都会对你刮目相看](https://zhuanlan.zhihu.com/p/67905621)

## 进程和线程的区别和联系
- 基础概念：[每个程序员都会遇到的面试问题：谈谈进程和线程的区别](https://zhuanlan.zhihu.com/p/46410285)
- 进程和线程的区别：[线程和进程的区别是什么？](https://www.zhihu.com/question/25532384/answer/81152571)

## 如何理解：程序、进程、线程、并发、并行、高并发？
- [如何理解：程序、进程、线程、并发、并行、高并发？](https://www.zhihu.com/question/307100151/answer/894486042)  

## 多进程和多线程在应用场景上的差别
- [linux下多进程与多线程的困惑？](https://www.zhihu.com/question/30101368)
- [Linux中进程和线程的开销基本一样啊，为什么还要多线程呢？](https://www.zhihu.com/question/19903801)
- [Linux 下多线程和多进程程序的优缺点，各自适合什么样的业务场景？](https://www.zhihu.com/question/24485648)
- [请你说一下多进程和多线程的使用场景](https://www.nowcoder.com/questionTerminal/fcd1ddb413a64b6eb66d4195dfc1e525)
- [Linux下多线程和多进程程序的优缺点，各个适合什么样的业务场景](https://zhidao.baidu.com/question/1767389138339419740.html)
- [多进程和多线程的应用场景](https://blog.csdn.net/PirLCK/article/details/52296716)

## 多进程和多线程的区别
### 概念不同
- 线程：是程序执行流的最小单元，是系统独立调度和分配CPU（独立运行）的基本单位。  
- 进程：是资源分配的基本单位。一个进程包括多个线程。  
### 内存空间独立：进程安全
- 进程间的内存空间是各自独立的，因此进程间的运行不会相互影响；但多线程运行时，当一个线程出现异常时，会结束掉所有线程包括当前进程。
### 切换的开销
- 因为每个进程都包含整个地址空间，而多线程是共享同一个地址空间，因此进程的调度、切换、通讯的开销远大于线程（30倍）
- 线程共享进程的堆空间、数据区等，只有自己的栈空间（运行函数），主线程的栈空间最大为135M？而其他线程平均只有8M的栈空间。这个需要再确认一下
### 多进程/多线程同步、通讯的方式不同
- 多进程IPC
- 多线程通过共享变量
### 应用场景不同
- 多进程可以使得系统鲁棒性更高，出错的时候容易找到错误的地方，而且不影响别的进程。所以在绝大多数的自动驾驶操作系统中，会使用多进程的发案，比如ROS，比如Apollo。如果是分布式，就用多进程。

- 多线程可以进行快速创建和数据共享，进程创建的开销很大，上下文切换开销也稍微大一些，频繁创建进程去响应服务器的请求会造成极大的开销，而且会增加响应时间，所以在进行服务器响应的时候会采用多线程。如果是多核处理用多线程。  


### 相关链接
- [操作系统：多进程、多线程](https://segmentfault.com/a/1190000009212759)
- [面试总结，多进程和多线程的区别](https://blog.csdn.net/leolinsheng/article/details/12979473)
- [多线程和多进程的区别（小结）](https://blog.csdn.net/hairetz/article/details/4281931)
- [Linux 下多线程和多进程程序的优缺点，各自适合什么样的业务场景？](https://www.zhihu.com/question/24485648)

### 乐观锁和悲观锁，以及其使用场景、cas和aba问题
- 上述的互斥锁均为悲观锁
- 乐观锁的实现在java中比较常见
- 相关url
   - [面试必备之乐观锁与悲观锁](https://zhuanlan.zhihu.com/p/40211594)
   - [何为乐观锁与悲观锁？](https://zhuanlan.zhihu.com/p/95296289)
   - [C++ 并发队列的原理简介与开源库 concurrentqueue 安利](https://www.miaoerduo.com/2018/04/30/cpp-concurrent/)

## 介绍一下fork、vfork还有clone的区别
- [fork()、vfork()、clone()的区别](https://blog.csdn.net/gogokongyin/article/details/51178257)
- [关于Linux中fork、vfork、clone的一些个人见解](https://zhuanlan.zhihu.com/p/59065065)
- [在如今的Linux编程中，还有必要使用vfork()吗？](https://www.zhihu.com/question/304323673)
- [C语言里，main 函数中 return x和 exit(x) 到底有什么区别 ?](https://www.zhihu.com/question/26591968)
## 如何产生一个进程/线程，子进程和父进程的内存空间是独立的吗，fork的原理

### 如何创建新的进程
进程调用fork()来复制自己。

### 如何创建一个线程
进程调用pthread_create函数来创建一个新的进程

### fork的系统调用过程  
进程调用fork，当控制转移到内核中的fork代码后，内核做：  

- 分配新的内存块和内核数据结构
- 复制原来的进程到新的进程
- 向运行进程集添加新的进程
- 将控制返回给两个进程  

当一个进程调用fork之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。但是每个进程都将可以开始它们自己的旅程。  

子进程不是从main函数的开始，而是从fork返回的地方开始它的生命之旅。


### 子进程和父进程的内存空间是独立的吗？  

是独立的。

### 如何分辨父进程和子进程
根据fork的返回值进程可以很容易的判断自己是子进程还是父进程。  

```C
#include<stdio.h>
#include <unistd.h>

int main(){
    int fork_rv;

    printf("Before:my pid is %d\n",getpid());

    fork_rv = fork();
    //sleep(1);
    if(fork_rv == -1) perror("fork");
    else if(fork_rv == 0) printf("I am the child.my pid is %d\n",getpid()); //子进程
    else printf("I am the parent.my child is %d\n",fork_rv);  //父进程

    return 0;
}
```
### Linux Copy On Write机制
- fork出的子进程共享父进程的物理空间，当父子进程有内存写入操作时，read-only内存页发生中断，将触发的异常的内存页复制一份(其余的页还是共享父进程的)。
> fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。  
- fork出的子进程功能实现和父进程是一样的。如果有需要，我们会用exec()把当前进程映像替换成新的进程文件，完成自己想要实现的功能。

- [COW奶牛！Copy On Write机制了解一下](https://zhuanlan.zhihu.com/p/48147304)
- [Linux写时拷贝技术(copy-on-write)](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html)  

### 父进程如何等待子进程的退出（进程同步）

答案：进程调用wait等待子进程结束。
```C
pid = wait(&status);
```

系统调用wait做两件事。首先，wait暂停调用它的进程直到子进程结束。然后，wait取得子进程结束时传给exit的值。

最终子进程会结束任务并调用exit(n)。n是0到255的一个数字。

当子进程调用exit，内核唤醒父进程同时将子进程传给exit的参数。唤醒和传递退出(exit)值的动作由从exit的括号到父进程的箭头表示。这样wait执行两个操作：通知和通信。

#### wait的三个重要特性  
- wait阻塞调用它的程序直到子进程结束 这一特征使两个进程能够同步它们的行为。比如，父进程用fork创建一个子进程来对一个文件排序。父进程必须等排序结束后才能继续处理这个文件。系统调用exit和wait是一种协调这些任务的方法。
- wait返回结束进程的pid。一个进程可以创建多个子进程。如果父进程需要等待其中某个子进程结束，则只需要判断返回的pid是否和该子进程的pid相同。
- 使用wait进行进程间的通信。wait可以吿诉父进程子进程是如何结束的。一个进程以3种方式(成功、失败或死亡)之一结束。


## 进程共享了什么资源
操作系统上进程能够访问、使用的资源，进程都共享了。包括操作系统空间、设备、内存等。
- [进程共享资源](https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90)

## 线程有什么共享资源和独占资源
- [同一进程中的线程究竟共享哪些资源](https://www.cnblogs.com/baoendemao/p/3804677.html)  
- [同一进程中线程的共享资源以及独占资源](https://blog.csdn.net/qq_24001803/article/details/100191953)

## 线程的状态都有哪些？画出状态转换图
- 新建 New
- 就绪 Runnable
- 运行 Running
- 阻塞 Blocked
- 死亡 Dead

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/122.jpg" width = 60% height = 60% /></div>


## 一个进程可以创建多少线程，和什么有关（这个问题还解决不了）
可以写一个程序来测试一个进程可以创建多少线程
```C
#include<pthread.h>
#include<stdio.h>
#include<unistd.h>
void foo();

int main()
{
     int i = 0;
     pthread_t thread;

     while (1) {
         if (pthread_create(&thread, NULL, (void *)foo, NULL) != 0){
             printf("end!\n");
            return 0;
         }
         sleep(0.05);
         i ++;
         printf("i = %d\n", i);
     }
     return 0;
}

void foo(){
    sleep(1000);
}
```
运行过程中再开个终端，查看该进程的属性
```shell
cat /proc/$pid/limits
```
其中可以看到，Max processes为7642。
```shell
yang@ubuntu:~/workspace/0515$ cat /proc/68398/limits
Limit                     Soft Limit           Hard Limit           Units     
Max cpu time              unlimited            unlimited            seconds   
Max file size             unlimited            unlimited            bytes     
Max data size             unlimited            unlimited            bytes     
Max stack size            8388608              unlimited            bytes     
Max core file size        0                    unlimited            bytes     
Max resident set          unlimited            unlimited            bytes     
Max processes             7642                 7642                 processes 
Max open files            1024                 1048576              files     
Max locked memory         65536                65536                bytes     
Max address space         unlimited            unlimited            bytes     
Max file locks            unlimited            unlimited            locks     
Max pending signals       7642                 7642                 signals   
Max msgqueue size         819200               819200               bytes     
Max nice priority         0                    0                    
Max realtime priority     0                    0                    
Max realtime timeout      unlimited            unlimited            us        
```
而且最终创建了7275个线程。  

现在的问题是不知道这个7225是怎么来的。

下述博客的思路是用 虚拟内存大小/一个线程栈大小（用命令 ulimit -s）查看。  

但是 2G / 8M = 250 个线程，和上述7275个线程差别过大，因此这个计算思路肯定是不对的。  

- [linux下进程的最大线程数、进程最大数、进程打开的文件数](https://www.cnblogs.com/niocai/archive/2012/04/01/2428154.html)
- [一个进程能运行多少线程](https://www.cnblogs.com/wozijisun/p/10370897.html)
- [Linux 一个进程所能创建的最大线程数](https://zhuanlan.zhihu.com/p/31803596)
- [Linux下限制一个进程可以创建的最大线程数是在哪里确定的？](https://www.zhihu.com/question/263697255/answer/273837521)

# 进程/线程调度
## 进程调度方法详细介绍

- 先来先服务（FCFS）调度算法
- 短作业优先（SJF）调度算法
- 时间片轮转（RR）调度算法
- 高响应比优先（Highest Response Ratio First，HRRF）调度算法
- 多级反馈队列（Multi-Level Feedback Queue）调度算法
- 最高优先级优先调度算法

[【原理】进程调度](https://github.com/chyyuu/simple_os_book/blob/master/zh/chapter-4/process_schedule_principal.md)

# 进程/线程通讯 

# 进程通信方法（IPC：InterProcess Communication）（Linux和windows下）
某一进程知道当前的时间，而另一进程想获取时间信息，如何让一个进程从另一个进程得到数据呢？  

三种解决方案：文件、管道、共享内存。  

这些方法分别通过磁盘、内核以及用户空间进行数据的传输。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/119.jpg" width = 60% height = 60% /></div>


## 通过文件的进程间通信
进程间可以通过文件来进行通信。某进程将数据写人文件，别的进程再将数据从文件中读出。  

比如：使用文件进行通信的时间/日期服务器

这里不必写一个完整的C程序，下面的一个shell脚本就可以完成任务了。  

```shell

#!/bin/sh

# 服务器发送时间数据
while true; do
  date > /temp/current_date
  sleep 1
done

# 客户端读取时间数据
cat /tmp/current_date
```
### 使用文件的IPC小结

- 访问控制
客户端必须能够读取文件。通过使用标准文件访问权限，可以给予服务器写权限并且限制客户端只有读权限。  

- 多客户端
任意数目的客户可以同时从文件中读取数据。Unix并不限制同时打开同一文件的进程数目。  

- 竞态条件
服务器通过清空内容再重写的方法来更新文件。如果某客户恰好在清空和重写之间读取文件，那么它得到的将是一个空的或只有部分的内容。  

- 避免竞态条件
服务器和客户端可以使用某种类型的互斥量来避免竞态条件，比如文件锁。另外，如果服务器在程序中使用lseek和write函数来替换create，这样文件永远都不可能为空，因为write是一个原子操作，它不会在执行中被打断。  

### 解决读写文件时的冲突问题——文件锁
#### 两种文件锁
第一种类型为写数据锁，它告诉其他进程：“我在写文件，在完成之前任何人都必须等待。”  

第二种类型的锁为读数据锁，它告诉其他进程: “我在读文件，要写文件必须等我完成，要读文件的不受影响。”  

#### 使用文件锁进行编程
Unix提供了 3种方法锁住打开的文件：flock、lockf和fcntl。三者中最灵活和移植性最好的应该是fcntl。  

下面介绍fcntl。  

**如何给已经打开的文件加读数据锁？**  

```C
fcntl(fd,F_SETLKW,&lockinfo)
```
第一个参数是该文件对应的文件描述符。第二个参数F_SETLKW说明若必要的话，可以等待其他的进程释放锁。第三个参数指向一个struct flock类型的变量。下列代码为一个文件描述符没置读数据锁：  
```C
set_read_lock(int fd)
{
    struct flock lockinfo;  
    lockinfo.l_type = F_RDLCK;  /* a read lock on a region */
    lockinfo.l_pid = getpid();  /* for ME */
    lockinfo.l_start = 0;   /* starting 0 bytes from. . */
    lockinfo,l_whence = SEEK_SET;   /* start of file */
    lockinfo.]_len = 0; /* extending until EOF */
    fcntl(fd,F_SETLKW,Slockinfo);
}
```
**如何在打开的文件上加写数据锁？**  

使用fcntl(£d,F_SETLKW,&lockinfo)，并将lockinfo.l_type置F_WRLCK。  

**怎样解锁？**  

使用fcntl(fd,F_SETLKW,&lockinfo)，并将lockinfo.l_type置F_UNLCK。  

**如何只锁住文件的一部分？**  

使用fcntl(fd,F_SETLKW,&lockinfo)，并将 lockinfo.l_start置为开始位置的偏移量，同时将lockinfo.l_len置为区域的长度。  

**小结**  

使用F_SETLKW参数调用fcntl可以使进程挂起直到内核允许进程设置指定的锁。在读取数据之前，客户必须设置读取数据的锁。若服务器对文件加写数据锁，客户只好等待服务器完成。服务器在重写数据之前，也必须对文件加写数据锁，如果这时客户加了一个读数据的锁，那服务器会被挂起直到所有客户释放这个锁。  

重要细节：进程可以忽略锁机制。  

## 管道

Linux上的管道分两种类型:  
- 匿名管道
- 命名管道

我们可以把匿名管道和命名管道分别叫做PIPE和FIFO。这主要因为在系统编程中，创建匿名管道的系统调用是pipe()，而创建命名管道的函数是mkfifo()。使用mknod()系统调用并指定文件类型为为S_IFIFO也可以创建一个FIFO。  


无论是匿名管道还是命名管道，其管道的性质都是一样的：  
- 性质类似普通文件但有区别  
- 读/写阻塞  
- 半双工通讯  

### 匿名管道

匿名管道最常见的形态就是我们在shell操作中最常用的”|”。它的特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的。此时除了父子进程外，没人知道这个管道文件的描述符，所以通过这个管道中的信息无法传递给其他进程。这保证了传输数据的安全性，当然也降低了管道了通用性，于是系统还提供了命名管道。  


使用pipe()系统调用可以创建一个匿名管道，这个系统调用的原型为：  
```C
#include <unistd.h>
int pipe(int pipefd[2]);
```

这个方法将会创建出两个文件描述符，可以使用pipefd这个数组来引用这两个描述符进行文件操作。pipefd[0]是读方式打开，作为管道的读描述符。pipefd[1]是写方式打开，作为管道的写描述符。从管道写端写入的数据会被内核缓存直到有人从另一端读取为止。  

匿名管道通常用于父子进程之间的通讯。通过使用pipe()、fork()、exec()的组合来创建父子之间的匿名管道，并进行通讯和工作。  

#### 匿名管道的缺点 

匿名管道使得进程向其他进程发送数据就像向文件差送数据一样容易，但是其具有两个重大的缺陷。匿名管道在一个进程中被创建，并且通过fork来实现共享。因此，匿名管道只能连接相关的进程（父子进程），也只能连接同一台主机上的进程。

### 命名管道

使用命名管道可以连接不相关的进程，并且可以独立于进程存在（如图15. 6所示）。称这样的命名管道为FIFO（先进先出队列）。FIFO类似于放在草坪上的一段给花园浇水的水管。任何人都可以将此水管的一端放在自己的耳朵边，而另一个人通过水管向对方说话。人们可以通过此水管进行交流，而在没有人使用的时候，水管仍然是存在的。FIFO可以看作由文件名标志的一根水管。

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/120.jpg" width = 60% height = 60% /></div>

#### 使用FIFO 

- 如何创建FIFO？
库函数mkfifo(char * name, mode_t mode)使用指定的权限模式来创建FIFO。mkfifo命令通常调用这个函数。  

- 如何删除FIFO？
类似于删除文件，unlink(fifoname)函数可以用来删除FIFO。  

- 如何监听FIFO的连接？
使用open(fifoname，O_RDONLY)函数。open函数**阻塞**进程直到某一进程打开FIFO进行写操作。  

- 如何通过FIF0开始会话？
使用open(fifoname,O_WRONLY)函数。此时open函数**阻塞**进程直到某一进程打开FIFO进行读取操作。  

- 两进程如何通过FIFO进行通信？
发送进程用write调用，而监听进程使用read调用。写进程调用close来通知读进程通信结束。  

下面两个shell脚本是基于FIFO的时间/日期服务的服务器和客户端程序：  
```shell
# !/bin/sh
# time server
while true; do
  rm - f /tmp/time_fifo
  mkfifo /tmp/time_fifo
  date > /tmp/time_fifo
done

# time client
# !/bin/sh
while true; do
  cat /tmp/time_fifo
  sleep 1
done
```

#### FIFO类型的IPC小结

- 访问
FIFO使用与通常文件相同的文件访问。服务器有写权限，而客户端只限于读权限。  

- 多个客户端
命名管道是一个队列而不是常规文件。写者将字节写人队列，而读者从队列头部移出字节。**每个客户端都会将时间/日期的数据移出队列，因此服务器必须重写数据。**   

- 竞态条件
FIFO版本的时间/日期服务器程序完全不存在竞态条件问题。  

在信息的长度不超过管道的容量的情况下，read和write系统调用只是原子操作。读取操作将管道清空而写人操作又将管道塞满。在读者和写者连通之前，系统内核将进程挂起。因此锁机制在这里并不需要。  

### 关于匿名管道和命名管道的介绍——讲解的非常细致
[Linux 的进程间通信：管道](https://zhuanlan.zhihu.com/p/58489873)

### 进程的通信里面的管道通信，有哪几种（命名和非命名）。写一个管道通信的命令，问第一个进程的输出传递给第二个进程的输入，那么它还保存这个数据吗

管道命令如上。  

管道中数据是一次性的：当进程从FIFO一端读取数据后，管道中的数据就清空了。  


### 管道如何解决并发问题


## 共享内存
### 在聊共享内存的概念之前，先了解：为什么会有共享内存？为什么共享内存的效率最高？

字节流是如何通过文件或FIFO来传输的？  

write将数据从内存复制到内核缓存中。read将数据从内核缓存复制到内存中。  

如果进程运行在用户空间的不同部分，进程间是如何将数据从内核缓存中复制进复制出的呢？  

同一个系统里的两个进程通过使用共享的内存段来交换数据。共享的内存段是用户内存的一部分。每一个进程都有一个指向此内存段的指针。依靠访问权 
限的设置，所有进程都可以读取这一块空间中的数据。因此进程间的资源是共享的，而不是被复制来复制去的。共享内存段对于进程而言，就类似于共享变量对于线程一样。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/121.jpg" width = 60% height = 60% /></div>

其实就类似于将一个对象进行传值、传引用到相应函数中的区别一样。  

### 共享内存的概念

- 共享内存段在内存中不依赖于进程的存在而存在。
- 共享内存段有自己的名字，称为关键字(key)。
- 关键字是一个整型数。
- 共享内存段有自己的拥有者以及权限位。
- 进程可以连接到某共享内存段，并且获得指向此段的指针。

### 如何使用共享内存段 

- 如何得到共享内存段？
```C
int seg_id = shmget(key, size-of-segment, flags);
```
如果内存段存在，函数shmget找到它的位置。如果不存在，可以通过在flags值中指定一个创建此段和初始化权限模式的请求。  

- 如何将进程连接到某个共享内存段？
```C
void ptr = * shmat(seg_id, NULL, flags);
```
shmat在进程的地址空间中创建共享内存段的部分，并返回一个指向此段的指针。flags参数用来指定此内存段是否为只读。  

- 如何与共享内存段进行读写交互？
```C
strcpy(ptr, "hello");
```
memcpy()、ptr\[i]及其他一些通用的指针操作。  

- 与共享内存段断开连接
```C
shmdt(ptr);
```

- 删除创建的内存段
```C
shmctl(seg_id, IPC_RMID, NULL);
```

### 共享内存段类型的IPC小结 

- 访问
客户端必须有对共享内存段的读权限。共享内存段拥有一个权限系统，它的工作原理和文件权限系统类似。共享内存段有自己的拥有者并且为用户、组或其他成员设置了权限位，来控制他们各自的访问权限。正因为有如此特性，才可以让服务器只有写权限而客户端只有读权限。  

- 多个客户
任意数目的客户都可以同时从共享内存段读数据。  

- 竞态条件
服务器通过调用一个运行在用户空间的库函数strcpy来更新共享的内存段。如果客户端正好在服务器向内存段中写人新数据的时候来访问内存段，那么它可能既读到新数据也读到老数据。  

- 避免竞态条件
服务器和客户段必须使用相同的系统来对资源加锁。内核提供了一种进程间加锁的机制，称为信号量机制。  

### 共享内存段避免数据冲突的方法——信号量（Semaphores）
信号量是一个内核变量，它可以被系统中的任何进程所访问。进程间可以使用这个变量来协调对于共享内存和其他资源的访问。上一章讨论了如何在特定的情况发生时使用条件变量来通知其他线程。条件对象是进程中的全局变量，而信号量则是系统中的全局变量。   

多个无关进程可以利用信号量同时交互，但只能在单机上工作。  

信号量最好的例子就是生产者消费者。  

## 套接字Socket
管道使得进程向其他进程发送数据就像向文件发送数据一样容易，但是管道具有两个重大的缺陷。管道在一个进程中被创建，通过fork来实现共享。因此，管道只能连接相 
关的进程，也只能连接同一台主机上的进程。  

Unix提供了另外一种进程间的通信机制——socket。socket允许在不相关的进程间创建类似管道的连接，甚至可以通过socket连接其他主机上的进程。  

### Internet sockets
Internet sockets是这样一条链接，它的两个端点是通过特定的端口号建立起来的。字节流通过socket进行传输，从一个进程到达另一个进程，类似于某人在波士顿打电话给在东京的朋友。  

Internet sockets有两种主要的实现方式：流socket和数据报socket。这两者皆可以双向传输。  

流socket更类似于文件描述符：程序员使用write和read调用来发送和接收数据。  

数据报socket则类似于明信片：写者将缓存中的一块数据发给读者。所有的交互都是以数据缓存的形式完成，而不是字节流。  

### Named Sockets
命名socket,又称Unix域socket。它使用文件名作为地址而不是主机名一端口号对。   

命名socket同时支持流和数据报版本。因为这种方式使用文件名而不是主机一端口作为地址，所以它们仅仅可以连接同一机器上的进程。  

## 信号

特点：能发送单个信号而不能传送数据。  

信号机制是UNIX为处理进程中断设计的，通过发送指定信号来通知进程某个异步事件的发生，以迫使进程执行信号处理程序。  

换言之，这个通信机制就相当于只能由一方发出某个命令让另一方按照约定去做相应的操作，至于另一方做了没做怎么做发出方并不关心。信号本质是一组预定义的值(比如SIGIN是与终端交互相关的信号，代表键盘中断等等),是一种“软中断”，信号主要用于相关进程之间。  

- kill:从另一个进程发送的信号
一个进程可以通过kill系统调用向另一个进程（也可以是自己）发送信号。  

一个进程可以向其他进程发送任何信息，包括一般来自键盘、间隔计时器或者内核的信号。  

比如：第一个程序设置一个间隔计时器，计时器的信号处理函数向OUCH!程序发送SIGINT信号。这样相应的处理函数就被调用。从而一个进程的计时器控制了另一个进程的函数调用。  

## 目前linux进程间通信的常用方法是什么(pipe？信号量？消息队列？)?
- [目前linux进程间通信的常用方法是什么(pipe？信号量？消息队列？)?](https://www.zhihu.com/question/23995948)


## 线程通信方法（Linux和windows下）

- 进程间资源是独立的，讲通讯：管道，共享内存  
- 线程间资源是共享的，讲安全：信号量，锁，原子操作

同一个进程下的多个线程在同一个地址空间，通信是很容易的事情，因此多线程间要同步就行。  

线程间锁定资源：语言自带机制


## 线程同步方法
### 互斥量
互斥量（mutex）从本质上来说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后解锁。  

对互斥量进行加锁后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。  

如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上面的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，
其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。  

如果不线程不希望被阻塞，它可以使用pthread_mutex_trylock尝试对互斥量进行加锁。如果调用pthread_mutex_trylock
### 读写锁
### 自旋锁
### 条件变量
### 屏障
屏障（barrier）是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一个点，然后从该点继续执行。  
我们已经看到过一种屏障，pthread_join函数是一种屏障，允许一个线程等待，知道另一个线程退出。  

但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作。  
比如当多个线程执行某一个任务的时候，可以使用屏障：  
- 800万个数的排序
   - 使用8个线程，每个线程排序100万个数字
   - 使用屏障，此时主线程等待8个子线程完成排序任务
   - 然后主线程调用merge()函数将结果合并到一起

屏障具体的函数调用见《UNIX环境高级编程》 P356

### 信号量
### 信号量与互斥锁的区别？
- 互斥量用于线程的互斥，信号量用于线程的同步。互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。  

- 互斥量值只能为0/1，信号量值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。

- 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

作者：韦东山嵌入式
链接：https://zhuanlan.zhihu.com/p/38651791
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 锁的思路解释的非常好
- [如何理解互斥锁、条件锁、读写锁以及自旋锁？ - 邱昊宇的回答 - 知乎](https://www.zhihu.com/question/66733477/answer/246535792)
### 相关url
- [Linux线程间同步的几种方式](https://www.shuzhiduo.com/A/WpdKlZlAzV/)
- [linux线程间同步方式总结梳理](https://www.shuzhiduo.com/A/MyJxNp6edn/)
- [linux 线程同步 互斥锁 读写锁 信号量](https://zhuanlan.zhihu.com/p/57699913)
- [Linux线程同步的三种方法](https://blog.csdn.net/Shannon_ying/article/details/51280623)
- [c++多线程同步](https://zhuanlan.zhihu.com/p/80308146)


## 解释孤儿进程，僵死进程
### 什么是僵尸进程？
Unix进程模型中，进程是按照父进程产生子进程，子进程产生子子进程这样的方式创建出完成各项相互协作功能的进程的。  

当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。如果父进程没有这么做的话，会产生什么后果呢？此时，子进程虽然已经退出了，但是在系统进程表中还为它保留了一些退出状态的信息，如果父进程一直不取得这些退出信息的话，这些进程表项就将一直被占用，此时，这些占着茅坑不拉屎的子进程就成为“僵尸进程”（zombie）。系统进程表是一项有限资源，如果系统进程表被僵尸进程耗尽的话，系统就可能无法创建新的进程。

### 什么是孤儿进程？
在进程还未退出之前，它的父进程就已经退出了，一个没有了父进程的子进程就是一个孤儿进程（orphan）。  

既然所有进程都必须在退出之后被wait()或waitpid()以释放其遗留在系统中的一些资源，那么应该由谁来处理孤儿进程的善后事宜呢？  

这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程“凄凉地”结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。  

孤儿进程并不会有什么危害，真正会对系统构成威胁的是僵尸进程。  

### 什么情况下僵尸进程会威胁系统的稳定呢？
设想有这样一个父进程：它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵尸进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。  

严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵尸进程的那个父进程。  

因此，当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶枪毙掉（通过kill发送SIGTERM或者SIGKILL信号）。  

枪毙了元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经“僵尸”的孤儿进程就能瞑目而去了。

### 如何避免僵尸进程的出现
```C
#include <stdio.h>
#include <unistd.h>
 
int main()
{
    int pid = fork();
    if ( pid > 0 )
    {
        while ( 1 )
        {
            sleep(3);
        }
    }
    else if ( pid == 0 )
    {
        printf("i die\n");
    }
}
```
上述程序中，fork了一个子进程，并且子进程很快就退出。父进程持续进行sleep，这样子进程就变成了僵尸进程。利用ps命令可以清晰的看到这一点。  
```shell
yang@ubuntu:~/workspace/git_workspace$ ps axu |grep test
yang       2760  0.0  0.0   4220   724 pts/19   S+   13:45   0:00 ./01-test
yang       2761  0.0  0.0      0     0 pts/19   Z+   13:45   0:00 [01-test] <defunct>
yang       2767  0.0  0.0  21292   960 pts/4    S+   13:45   0:00 grep --color=auto test

```

Z+代表进程2761是僵尸进程。  

僵尸进程和孤儿进程的区别是，孤儿进程是子进程还在运行，而父进程挂了，子进程被init进程收养。僵尸进程是父进程还在运行但是子进程挂了，但是父进程却没有使用wait来清理子进程的进程信息，导致子进程虽然运行实体已经消失，但是仍然在内核的进程表中占据一条记录，这样长期下去对于系统资源是一个浪费。  

这时候杀掉父进程即可清理该僵尸进程。当然这并非长久之计，根本的办法是从代码上进行控制，防止类似的事情再发生。  

除了等待子进程死亡外，父进程可以设置为接收表示子进程死亡的信号。当子进程退出或被终止时，内核发送SIGCHLD给父进程。但它不同于其他信号，默认时SIGCHLD是被忽略的。父进程可以为SIGCHLD设置一个信号处理函数，它可以调用wait和waitpid。更改后的代码如下：  

```C
#include <stdio.h>
#include <unistd.h>
#include <wait.h>
 
void handler(int sig)
{
  //使用wait
  printf("child is die,i know\n");
  wait(NULL);
  
  //使用waitpid
  if (waitpid(-1, &status, WNOHANG) >= 0)
  {
      printf("child is die,i know\n");
  }
}
 
int main()
{
    signal(SIGCHLD,handler);
    int pid = fork();
    if ( pid > 0 )
    {
        while ( 1 )
        {
            sleep(3);
        }
    }
    else if ( pid == 0 )
    {
        printf("i die\n");
    }
}
```

这样更改后执行的输出如下：

```shell
yang@ubuntu:~/workspace$ ps axu | grep test
yang       3402  0.0  0.0   4352   628 pts/4    S+   15:46   0:00 ./01-test
yang       3411  0.0  0.0  21292   968 pts/19   S+   15:46   0:00 grep --color=auto test
```
#### wait和waitpid的区别

当子进程退出时，父进程收到SIGCHLD信号，跳到处理函数并调用wait。子进程从进程表中被删除，父进程从处理函数返回到主函数。该过程看上去似乎很完美了，不过如果多个子进程几乎同时退出，会出现问题。  

假设同时有3个SIGCHLD发送到父进程。最先到达的信号导致父进程跳到处理函数，然后父进程调用wait来保证子进程已经从进程表中删除。

当父进程在运行信号处理函数时，其他两个信号的到达导致Unix阻塞，但是并不缓存信号。从而，第二个信号被阻塞，而第三个信号丢失了。此时，如果还有其他的子进程退出，来自于这些子进程的信号也将丢失。信号处理函数只调用了wait一次，所以每次丢失一个信号意味着少调用了一次wait，这将产生更多的僵尸进程(zombie)。解决方法是在处理函数中调用wait足够多的次数来去除所有的终止进程。  

waitpid函数能够很好地解决上述问题，具体使用方法参见上面的代码。  

waitpid提供了wait函数超集的功能。其第一个参数表示它所要等待的进程ID号。值-1表示等待所有的子进程。第二个参数是指向整型值的指针，用来获取状态。服务器并不关心子进程中发生了什么，不过一个健壮的服务器可能用该信息来跟踪错误。  

waitpid的最后一个参数表示选项。WNOHANG参数告诉waitpid:如果没有僵尸进程，则不必等待。  

该循环直到所有退由的子进程都被等待了才停止。即使多个子进程同时退出并产生了多个SIGCHLD，所有的这些信号都会被处理。  

#### 解决了之前的一个疑问：为什么fork之后父进程一定要wait 

这是为了防止产生僵尸进程！  

## 惊群效应，如何避免
- [Linux惊群效应详解（最详细的了吧）](https://blog.csdn.net/lyztyycode/article/details/78648798)
- [什么是惊群，如何有效避免惊群?](https://www.zhihu.com/question/22756773)

## 是否了解协程？讲一讲协程的原理
### 什么是协程
协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。  

最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。  

这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

### 协程的原理
- 让原来要使用异步+回调方式写的非人类代码，可以用看似同步的方式写出来

- 协程就是用户态线程，比内核线程低廉，切换阻塞成本低。单调度器下，访问共享资源无需上锁，用于提高cpu单核的并发能力

- 由于协程可以在用户空间内切换上下文（只需要切换CPU上寄存器中的内容），不再需要陷入内核来做线程切换，避免了大量的用户空间和内核空间之间的数据拷贝，降低了CPU的消耗，从而避免了追求高并发时CPU早早到达瓶颈的窘境

- 不再需要像异步编程时写那么一堆callback函数，代码结构不再支离破碎，整个代码逻辑上看上去和同步代码没什么区别，简单，易理解，优雅

- 缺点是无法利用多核资源，只能开多进程才行，不过现在使用协程的语言都用到了多调度器的架构，单进程下的协程也能用多核了协程可以用来解决很多问题，比如node js的嵌套回调，Erlang以及Golang的并发模型实现  

- [协程的好处有哪些？](https://www.zhihu.com/question/20511233)
- [为什么协程切换的代价比线程切换低](https://www.zhihu.com/question/308641794)

## 怎样理解阻塞非阻塞与同步异步的区别？
- [怎样理解阻塞非阻塞与同步异步的区别](https://www.zhihu.com/question/19732473)

## 创建单例进程
### socket方式
可以利用socket端口作为锁，而且程序退出后，操作系统会自动释放对该端口的绑定，即自动释放锁，不管程序是如何退出。  

- [进程单例模式](https://blog.csdn.net/werweqg/article/details/82623716)

### 文件锁
进程创建文件，给文件加锁，进程如果在运行，则文件被锁，其他进程访问失败，保证了进程的单例运行，进程退出，锁释放。  

- [linux创建守护进程且进程中只有唯一实例](https://blog.csdn.net/shenwansan_gz/article/details/48972099?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-4)

### 进程pid
- [在Linux下如何保证只创建一个进程](https://blog.csdn.net/weixin_42263483/article/details/80821842?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
