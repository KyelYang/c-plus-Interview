## 构造函数与析构函数
### 1. 知识点
- 由于析构函数不接收参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数
- 需要析构函数的类也需要拷贝和赋值操作
> 当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数  
> 通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符  
- 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符，
都不必然意味着也需要析构函数  

### 2. 面试问题
#### 1. 构造中能不能调虚函数

- 在base类构造期间，虚函数不是虚函数
> 不能。  
> 由于base类构造函数执行更早于derived类构造函数，当base类构造函数执行时derived类的成员变量尚未初始化。如果此期间调用virtual函数下降至derived类层级时，要知道derived类的函数必然取用local成员变量，而那些成员变量尚未初始化。要求使用对象内部尚未初始化的成分是危险的，所以C++不让你走这条路  
> 其实还有比上述理由更根本的原因
>> 在derived类对象的base类构造期间，对象的类型是base类而不是derived类。不只虚函数会被编译器解析至base类，若使用运行期类型信息（比如dynamic_cast和typeid），也会把对象视为base类类型。

#### 2. 析构中能不能调虚函数
> 不能。  
> 相同的道理也适用于析构函数。一旦derived类析构函数开始执行，对象内的derived类成员变量便呈现未定义值，所以C++视他们仿佛不再存在。进行base类析构函数后对象就成为一个base类对象，而C++的任何部分包括虚函数、dynamic_cast等等也就那么看待它  

#### 3. 构造函数可以使用virtual修饰吗？ 析构函数呢？
- 为什么构造函数不可以是虚函数——来源：[为什么C++的构造函数不可以是虚函数，而析构函数可以是虚函数](http://uusama.com/793.html)  
> 1.从存储空间角度  
>> 虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。  

> 2.从使用角度  

>> 虚函数主要用于在信息不全的情况下，能使覆盖的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。 
>> 虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。  

> 3.构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。  

> 4.从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数  

>> 从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数  

> 5.当一个构造函数被调用时，它做的首要的事情之一是初始化它的V P T R。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码- -既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。  

>> 所以它使用的V P T R必须是对于这个类的V TA B L E。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内， V P T R将保持被初始化为指向这个V TA B L E, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置V P T R指向它的 V TA B L E，等.直到最后的构造函数结束。V P T R的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的另一个理由。  

>> 但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置V P T R指向它自己的 V TA B L E。如果函数调用使用虚机制，它将只产生通过它自己的V TA B L E的调用，而不是最后的V TA B L E（所有构造函数被调用后才会有最后的V TA B L E）。  

- 为什么析构函数可以是虚函数  
> 编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。  
所以建议的方式是将析构函数声明为虚函数。如果你使用MFC，并且以CObject或其派生类为基类，那么MFC已经为你做了这件事情；CObject的析构函数是虚函数。一个函数一旦声明为虚函数，那么不管你是否加上virtual 修饰符，它在所有派生类中都成为虚函数。但是由于理解明确起见，建议的方式还是加上virtual 修饰符。  
C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和C语言的类型的兼容性。有虚函数的对象总是在开始的位置包含一个隐含的虚函数表指针成员。如果是对于MFC类CPoint和CSize这样的小型类，增加一个指针就增加了很多内存占用，而且使得其内存表示和基类POINT和SIZE不一致。  

- 构造函数可以使用virtual修饰吗？——来源：[构造函数不能是虚函数?](https://www.zhihu.com/question/35632207)  

> 观点1  
>> C++不支持虚拟构造函数，而Delphi支持。关于C++为什么不支持虚拟构造函数，Bjarne很早以前就在C++ Style and Technique FAQ里面做过回答：大意是说，虚拟函数调用只需要“部分的”信息，即只需要知道函数接口，而不需要对象的具体类型。但是构建一个对象，却必须知道具体的类型信息。如果你调用一个虚拟构造函数，编译器怎么知道你想构建是继承树上的哪种类型呢？所以这在逻辑上是一个悖论。  
Bjarne建议的解决方案是factory pattern，也就是为每一个要构建的类型再创建一个对应的factory，把问题放到factory的make方法中去解决。这也是C++中的通用解决方案。  

> 观点2  
>> TLDR：构造函数可以是虚函数，例如 Delphi 就有这样的设计，但是C++中构造函数不能是虚函数。  
从C++的视角来看，我们只能在编译时明确我们要构造的类的类型，才可以拿到这个类的构造函数，再使用这个构造函数构造我们想要的类，虚的构造函数从这个角度来看就是一个悖论。  
正是构造函数为虚函数，我们能通过基类的 Class Reference 构造出想要的派生类。然而 C++ 中没有 Class Reference，只有当我们有类的实例的时候才能调用虚函数，那么虚的构造函数自然毫无意义。 

> 观点3  
>> 在调用构造函数时，并不知道构造的是基类还是派生类，所以没办法判断调用哪个版本的构造函数。所以，这是个悖论。  

> 观点4  
>> 虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误。  

- 析构函数可以使用virtual修饰吗？  ———来源：《Effective C++》条款07
> 带有多态性质的base类应该声明一个virtual析构函数。即使该函数不执行任何实际操作也是如此  

>> C++指出，当derived对象经由一个base类指针被删除，而该base类带着一个非virtual析构函数，其结果未有定义————实际执行时通常发生的是对象的derived成分没被销毁，而base类成分被销毁，即造成一个“局部销毁”的结果  
消除这个问题的做法很简单：给base类一个virtual析构函数。此后删除derived类对象，它会销毁整个对象，包括所有derived类成分  

> 如果一个类带有任何的virtual函数，它就应该拥有一个virtual析构函数  

> 如果类不含虚函数，通常表示它不被用作一个base类  

>> 欲实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数被调用。这份信息通常由一个vptr指针指出。vptr指向衣蛾由函数指针构成的数组，成为vtbl；每一个带有virtual函数的类都有一个相应的vtbl。当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl————编译器在其中寻找适当的函数指针  
总而言之，如果单单增加virtual函数，其对象的体积会增加，因为增加了vptr；与此同时，含有指针的C++对象也不在和其他语言（如C）内的相同声明有一样的结构（因为其他语言的对应物并没有vptr），因此就不再具有移植性  

> 类的设计目的如果不是作为base类使用，或不是为了具备多态性，就不该声明为virtual析构函数  
>> 如果企图继承一个标准容器（所有的STL容器）或任何带有非virtual析构函数的类，都是不行的  
并非所有base类的设计目的都是为了多态用途。例如标准库容器都不被设计作为base类使用，更别提多态了。某些类的设计目的只是作为base类使用，但不是为了多态用途，比如Uncopyable类，因此它们不需要virtual析构函数  

> 简单解释——来源：[C++ 究竟什么时候该用虚析构函数(virtual destructor)?](https://www.zhihu.com/question/41538182)
>> 如果，你設計的程序裏，釋放對象實例的時候，有「使用某個基類的指針，來釋放它指向的繼承類的實例」這種用法出現的話，那麼，這個基類的 destructor 就應該設計成 virtual 的。  
其它的回答裏，還介紹了一些簡單易記的設計原則。  
例如：  
如果，一個類有 virtual 的 function，那它的 destructor 也應該是 virtual 的；  
如果，一個類將會被多態地使用，那讓它的 destructor 是 virtual 的；  

#### 4. C++ 拷贝构造函数 如何禁用
**方法1**
> 将该类的拷贝构造函数声明为private，用户代码将不能拷贝这个类型的对象。但是，friend和成员函数依旧可以拷贝对象。为了阻止friend和成员函数进行拷贝，我们可以将这些拷贝控制成员声明为private的，但并不定义它们  
> 声明但不定义一个成员函数是合法的。对此只有一个例外，可能会导致错误：试图访问一个未定义的成员将导致一个链接时错误。具体参考《C++primer》P451、P528  

**方法2**  
> 定义一个Uncopyable的父类，然后将其拷贝构造函数声明为private并且不予实现，这样如果有哪个类想禁用拷贝构造函数，直接继承该父类即可  

**方法3：推荐方法**
- 定义删除的函数
> 在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的
```CPP
struct NoCopy {
NoCopy () = default;
NoCopy (const NoCopy&) = delete;  // 阻止拷贝
NoCopy &operator= (const NoCopy&) = delete; // 阻止赋值
~NoCopy() = default;    //使用合成的析构函数 
... //其他成员
```
> =delete通知编译器（以及我们代码的读者），我们不希望定义这些成员。与=default不同，=delete必须出现在函数第一次声明的时候  
>> 与=default的另一个不同之处是，我们可以对任何函数指定=delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。
- 析构函数不能是删除的成员。如果析构函数被删除，就无法销毁此类型的对象了
- 在哪些情况下，需要将函数定义为删除的
> 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的

#### 5. 什么时候要重写拷贝构造函数？
- 在以下情况需要重写拷贝构造函数
> 1. 如果打算在一个内含reference成员、或const成员的class内支持赋值操作，你必须自己定义拷贝赋值操作符。因为更改引用或const成员是不合法的，编译器不知道如何自己生产赋值函数来面对它们  
> 2. 如果某个基类将copy assignment操作符声明为private，编译器将拒绝为其derived类生成copy assignment构造函数，因为它们无权访问base类的拷贝赋值构造函数，因此需要手动编写  
> 3. 含有指针类型的成员或者有动态分配内存的成员都应该提供自定义的拷贝构造函数,因为默认构造函数是浅拷贝。
> 4. 需要自己定义一个析构函数。一般这种情况成员中含有指针，或者其他对象，需要手动delete

知乎类似解释————来源：[什么时候必须自定义赋值构造函数？](https://www.zhihu.com/question/20529339)  
> 对于copy assignment操作符来说，编译器只有当生出的代码合法且有适当机会证明有意义才会生成operator=。比如class内含有const成员，或者某个基类将copy assignment操作符声明为private，这些情况就不会生成copy assignment构造函数，因此需要手动编写。另外，对于类中含有指针成员的，为了进行深拷贝，是必须要手动编写赋值构造函数的，而且在其中要注意异常安全性和自我赋值安全性。

#### 6. 构造函数的种类
当定义一个类时，我们显式地指定在此类型的对象拷贝、移动、复制和销毁时做什么。主要包含物种特殊的成员函数来控制这些操作，包括：
- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数  

拷贝构造函数和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么；  
拷贝和移动赋值运算符函数定义了将一个对象赋予同类型的另一个对象时做什么；  
析构函数定义了当此类型对象销毁时做什么；
#### 7. 构造函数的常用场景
- 对象创建的场景就是构造函数使用的常用场景  
- 一个经常被忽略的场景：在函数调用过程中，将对象以值传递，或者函数返回一个对象时，会隐式调用构造函数
#### 8. 构造函数和=运算符的区别
```CPP
int main(){
    Test t1;  //调用默认构造函数
    Test t2(1,"enn");//调用赋值构造函数
    Test t3(t2);//调用拷贝构造函数
    Test t4 = t3;//这里之前理解错误：这里依然调用的是拷贝构造函数
    t1 = t2;//调用operate=构造函数
}
```
1. 从原型上来区分  
> 复制构造函数原型ClassType(const ClassType &);无返回值  
> 赋值操作符原型ClassType& operator=(const ClassType &);返回值为ClassType的引用，便于连续赋值操作  
2. 从使用的场合来区分  
复制构造函数用于产生对象。调用拷贝构造函数主要有以下场景
> 对象作为函数的参数，以值传递的方式传给函数  
> 对象作为函数的返回值，以值的方式从函数返回  
> 使用一个对象给另一个对象初始化  

而赋值操作符要求‘=’的左右对象均已存在，它的作用就是把‘=’右边的对象的值赋给左边的对象  
3. 从调用结果上来区分
> 区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。
>> 拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个已经存在的实例。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。  
- 深拷贝和浅拷贝  
说到拷贝构造函数，就不得不提深拷贝和浅拷贝。  
通常，默认生成的拷贝构造函数和赋值运算符，只是简单的进行值的复制。  
深拷贝和浅拷贝主要是针对类中的指针和动态分配的空间来说的，因为对于指针只是简单的值复制并不能分割开两个对象的关联，任何一个对象对该指针的操作都会影响到另一个对象。这时候就需要提供自定义的深拷贝的拷贝构造函数，消除这种影响。通常的原则是：
> 1. 含有指针类型的成员或者有动态分配内存的成员都应该提供自定义的拷贝构造函数
> 2. 在提供拷贝构造函数的同时，还应该考虑实现自定义的赋值运算符

对于拷贝构造函数的实现要确保以下几点：
> 1. 对于值类型的成员进行值复制
> 2. 对于指针和动态分配的空间，在拷贝中应重新分配分配空间
> 3. 对于基类，要调用基类合适的拷贝方法，完成基类的拷贝

#### 9. 拷贝构造参数能不能是值类型
不能。拷贝构造函数必须以引用的方式传递参数。
这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。
#### 10. C++中，对函数的传参会有拷贝的发生，如何避免拷贝？ （我只说了引用 指针 还有move，请教各位大佬还有其他什么办法吗？我没想到诶

#### 11. C++ 重载(overload)、重写(overrride)、重定义(redefine)总结
- [C++ 重载(overload)、重写(overrride)、重定义(redefine)总结](https://www.cnblogs.com/tanky_woo/archive/2012/02/08/2343203.html)  
- [C++中函数重载、隐藏、覆盖和重写的区别](https://cloud.tencent.com/developer/article/1177174)  

