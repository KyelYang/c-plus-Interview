## myisam和innodb的区别
- [MyISAM与InnoDB 的区别（9个不同点）](https://zhuanlan.zhihu.com/p/89284150)
## MySQL 主从复制
- [深度探索MySQL主从复制原理](https://zhuanlan.zhihu.com/p/50597960)
- [数据库主从复制，读写分离，负载均衡，分库分表分别表达的什么概念？](https://www.zhihu.com/question/64597252)
- [MySQL高级(七) MySQL主从复制及读写分离实战](https://blog.csdn.net/why15732625998/article/details/80463041)
- [MySQL 主从复制、主主复制](http://cs-cjl.com/2019/11_16_mysql_master_replication)
- [MySQL Replication 主从复制全方位解决方案](https://www.cnblogs.com/clsn/p/8150036.html)
## MySQL 主从复制过程
- Slave 服务器上执行start slave，开启主从复制开关。
- 此时，Slave 服务器上的 IO 线程会通过 Master 服务器上授权的有复制权限的用户请求连接 Master 服务器，并请求从指定 binlog 日志文件的指定位置之后发送 binlog 日志内容。（日志文件名和位置就是在配置主从复制任务时执行change master命令时指定的）
- Master 服务器接收到来自 Slave 服务器的 IO 线程的请求后，Master 服务器上的 IO 线程根据 Slave 服务器的 IO 线程请求的信息，读取指定 binlog 日志文件指定位置之后的 binlog 日志信息，然后返回给 Slave 端的 IO 线程。返回的信息中除了 binlog 日志内容外，还有本次返回日志内容后在 Master 服务器端的新的 binlog 文件名以及在 binlog 中的下一个指定更新位置。
- 当 Slave 服务器的 IO 线程获取来自 Master 服务器上 IO 线程发送的日志内容及日志文件和位置点后，将 binlog 日志内容依次写入到 Slave 端自身的 relay log（即中继日志）文件（mysql-relay-bin.xxxxxx）的最末端，并将新的 binlog 文件名和位置记录到 master-info 文件中，以便下一次读取 Master 端新 binlog 日志时，能告诉 Master 服务器需要从新 binlog 日志的哪个文件哪个位置开始请求新的 binlog 日志内容。
- Slave 服务器端的 SQL 线程会实时检测本地 relay log 中新增加的日志内容，然后及时的把 relay log 文件中的内容解析成在 Master 端曾经执行的 SQL 语句的内容，并在自身 Slave 服务器上按语句的顺序执行应用这些 SQL 语句，应用完毕后清理应用过的日志。
- 经过了上面的过程，就可以确保在 Master 端和 Slave 端执行了同样的 SQL 语句。当复制状态正常的情况下，Master 端和 Slave 端的数据是完全一样的。

## MySQL和InnoDB
- [『浅入浅出』MySQL 和 InnoDB](https://draveness.me/mysql-innodb/)

## 索引
### MYSQL 索引类型、什么情况下用不上索引、什么情况下不推荐使用索引
- [MYSQL 索引类型、什么情况下用不上索引、什么情况下不推荐使用索引](https://zhuanlan.zhihu.com/p/24116198)

### 通俗易懂 索引、单列索引、复合索引、主键、唯一索引、聚簇索引、非聚簇索引、唯一聚簇索引 的区别与联系
- [通俗易懂 索引、单列索引、复合索引、主键、唯一索引、聚簇索引、非聚簇索引、唯一聚簇索引 的区别与联系](https://zhuanlan.zhihu.com/p/66553466)
### 写的很好的文章
- [我以为我对Mysql索引很了解，直到我遇到了阿里的面试官](https://zhuanlan.zhihu.com/p/73204847)

## Mysql中ACID的原理及其实现
- [MySQL事务：ACID特性的实现原理总结分析](https://zhuanlan.zhihu.com/p/60723043)
- [程序员，知道Mysql中ACID的原理吗？](https://zhuanlan.zhihu.com/p/65281198)


## 数据库隔离级别。脏读，不可重复读，幻读是什么
### 脏读，不可重复读，幻读是什么
#### 脏读

脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了不一定最终存在的数据，这就是脏读。  

#### 不可重复读

不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。  

#### 幻读

幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。  


### 数据库隔离级别
SQL标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：
- 读未提交（READ UNCOMMITTED）
- 读提交 （READ COMMITTED）
- 可重复读 （REPEATABLE READ）
- 串行化 （SERIALIZABLE）  

从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，可重复读是 MySQL 的默认级别。  

事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了4种隔离级别对这三个问题的解决程度。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/145.jpg" width = 60% height = 60% /></div>   


#### 读未提交
MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。 

任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。  

读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了，想都不要想。  

#### 读提交
既然读未提交没办法解决脏数据问题，那么就有了读提交。读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。    

读提交事务隔离级别是大多数流行数据库的默认事务隔离界别，比如 Oracle，但是不是 MySQL 的默认隔离界别。  

在同一事务中(本例中的事务B)，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果，这就是不可重复读，也就是读提交隔离级别。  

每个 select 语句都有自己的一份快照，而不是一个事务一份，所以在不同的时刻，查询出来的数据可能是不一致的。  

读提交解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。  

#### 可重复读

可重复是对比不可重复而言的，上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。  

注意，当你在 MySQL 中测试幻读的时候，并不会出现上图的结果，幻读并没有发生，MySQL 的可重复读隔离级别其实解决了幻读问题，主要是通过行锁和间隙锁的组合 Next-Key 锁实现的。   

#### 串行化
串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。  

- [MySQL事务隔离级别和实现原理（看这一篇文章就够了！）](https://zhuanlan.zhihu.com/p/117476959)

## varchar与char有什么区别？
### 区别一：定长和变长
char表示定长，长度固定，varchar表示变长，即长度可变。  

char如果插入的长度小于定义长度时，则用空格填充。  

varchar小于定义长度时，还是按实际长度存储，插入多长就存多长。

因为其长度固定，char的存取速度还是要比varchar要快得多，方便程序的存储与查找，但是char也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。  

varchar则刚好相反，以时间换空间。

### 区别二：存储的容量不同
对char来说，最多能存放的字符个数 255，和编码无关。  

而 varchar 呢，最多能存放 65532 个字符。varchar的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65532字节。  

