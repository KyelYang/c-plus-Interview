# 面向对象程序设计
## C++三大特性
### 封装
把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。  

类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。  

### 继承
继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。  

继承的作用：避免公用代码的重复开发，减少代码和数据冗余。
### 多态
多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。比如函数重载、运算符重载、虚函数等。  


### 1. 继承的相关概念
**防止继承的发生**  

有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final
```CPP
class NoDerived final { /* */ };  // NoDerived不能作为基类
class Base {/**/}; 
class Last final : Base { /* */ };  // Last不能作为基类 
class Bad : NoDerived { /* */ };  // 错误：NoDerived 是 final 的 
class Bad2 : Last { /* */ };  //错误：Last是final的
```
### 2. 动态类型与静态类型
- 静态类型：表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。  
- 动态类型：变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知。  


**在什么情况下表达式的静态类型可能与动态类型不同**  

基类的指针或引用的静态类型可能与其动态类型不一致，如果表达式既不是指针也不是引用，则它的动态类型永远与静态类型一致。  

**存在继承关系的类型之问的转换规则**  

要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：
- 从派生类向基类的类型转换只对指针或引用类型有效。  
- 基类向派生类不存在隐式类型转换。  
- 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。  

尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。  


## 2. 虚函数
### 1. 虚函数的作用和实现原理
### 2. 虚函数机制
### 3. 子类构造析构函数的调用顺序
**3.1 派生类构造函数的调用顺序**  

- 构造函数：从内向外构造。即首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。 
- 析构函数：从外向内析构。即首先析构派生类的成员，然后析构基类的部分。  

**3.2 相关知识点**  

> 每个类控制它自己的成员初始化过程  

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些 成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。  

除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。  



# 面试问题
## 多态
### 什么是多态
- 【深度探索C++对象模型】在C++中，多态表示“以一个public base class的指针（或引用），寻址出一个derived class object”的意思。
- [从 C++ 谈多态](https://zhuanlan.zhihu.com/p/44526108)

### 满足多态的三个条件
 多态存在的三个必要条件是：继承，重写，父类引用指向子类对象。  

### 问题
- 介绍一下C++多态 （说了重载，虚函数，template，类型转换，然后又说了下虚函数表虚指针虚机制
- 多态的实现

## 虚函数
### 为什么被称为虚函数
由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。  
### 虚函数的作用
虚函数主要是用来实现多态和多重继承的。   

心理念就是通过基类访问派生类定义的函数。
### 虚函数与纯虚函数
- 定义一个函数为虚函数，不代表函数为不被实现的函数。
- 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
- 定义一个函数为纯虚函数，才代表函数没有被实现。
- 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

### 什么是抽象类
含有纯虚拟函数的类称为抽象类，它不能生成对象。  

抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。  

如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。  

如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。  

### 虚函数、纯虚函数、抽象类
- [c++虚函数的作用是什么？](https://www.zhihu.com/question/23971699)

### C++ 虚函数的运行过程（讲了多态虚表指针啥的）/虚函数内部实现机制，调用的过程
- 每个对象都有一个对应的虚函数表，并且该对象的每个实例都含有一个虚指针，指向该虚函数表的起始位置。  

- 虚函数表在编译的时候构建。

- 每个虚函数在整个继承体系中在虚表中的位置都是固定的（即偏移量是固定的）。

- 在编译阶段并不知道虚函数调用的具体是哪个对象（基类还是派生类），只有在程序运行的过程中，通过续表中的RTTI（运行时类型信息Run-Time Type Identification）字段了解到具体是哪个对象。

### 子类可以调用父类的虚函数吗？
分情况讨论。 

#### 情况一：子类并没有重写父类的虚函数，此时可以直接调用
```CPP
class A{
public:
    virtual void fun_a(){cout << "A" << endl;};
};

class B: public A{
public:
    void fun_b(){cout << "B" << endl;};
    
};

int main(){
    B b;
    b.fun_a(); //会打印A
}
```
### 情况二：类并重写了父类的虚函数，此时可以间接调用
```CPP
class A{
public:
    virtual void fun_a(){cout << "A" << endl;};
};

class B: public A{
public:
    void fun_a(){cout << "B" << endl;};
    
};

class Player2{
private:
    int a; 
    double c; 
    char b; 
public: 
    virtual void fun(double c){};
};

int main(){
    B b;
    b.fun_a(); //默认调用的是B的虚函数，因此打印结果为B

    B *ptr = new B();
    ptr->A::fun_a(); //通过类作用域调用A的虚函数，打印结果为A

    return 0;
}
```
### 情况三：常规函数隐藏了父类虚函数
```CPP
class A{
public:
    virtual void fun_a(){cout << "A" << endl;};
};

class B: public A{
public:
    void fun_a(int b){cout << "B" << endl;};
    
};

class Player2{
private:
    int a; 
    double c; 
    char b; 
public: 
    virtual void fun(double c){};
};

int main(){
    B b;
    b.fun_a(1); //此时B无法直接调用父类的fun_a()函数，因为被常规函数fun_a(int)给隐藏了

    B *ptr = new B();
    ptr->A::fun_a(); //可以通过类作用符来调用

    return 0;
}
```
### 虚函数可以是内联函数吗？
- 非多态调用，可以是内联函数
- 多态调用，不能是内联函数。因为运行时多态无法在编译期进行内联
- [内联函数可以是虚函数吗？](https://www.zhihu.com/question/45894112)

## 虚函数表

### 虚函数指针是每个类一个还是每个对象一个？虚函数指针在实例内存里放在哪，前面中间还是末尾？
- 虚函数表是每个类一个。  
- 虚函数指针是每个对象一个都有一个。  
- 虚函数表的首地址储存在每一个对象之中，称为虚(表)指针(vptr)或者虚函数指针(vfptr)，这个虚指针始终位于对象的起始地址。  
- 如果在派生类中定义了新的虚函数，该虚函数将会被附加在虚函数表的最后，不会对与基类重合的部分造成影响。

### 什么是虚函数表，子类的虚函数表存储规则
三种情况。  
- 直接继承基类的虚函数。此时直接将基类的虚函数地址复制到派生类的虚函数表中的对应位置
- 重写基类定义的虚函数。此时将重写的虚函数地址覆盖到派生类虚函数表中原本基类定义的虚函数的位置
- 加入新的虚函数。此时派生类虚函数表会增大一个slot，用来存储新加入的虚函数的地址
### 虚函数表是在什么时期建立的，存在哪里？
- 虚函数表在编译时期建立
- 在gcc编译器的实现中虚函数表vtable存放在可执行文件的只读数据段.rodata中
- [虚函数表存放在哪里](https://www.cnblogs.com/chenhuan001/p/6485233.html)
### 如果类C继承自A，B，那么类C中有几个虚表？
- 一个虚表。将A的虚表与B的虚表整合到一起，并更新C重写后的虚函数地址，形成C的虚函数表。 
- 但此时类C的实例中，含有2个虚指针，即独立继承了n个类的话，就会含有n - 1个虚指针。
### 怎么找到虚函数的地址？
通过虚指针+偏移量找到虚函数的地址。  

### 虚函数表，基类指针怎么调用子类的函数
- 通过虚函数实现。
- 基类指针指向的子类对象中内部存在这一个指向该子类对象的虚函数表，当调用虚函数时，会通过该指针直接找到子类虚表中对应的虚函数地址并进行调用。  
 
## 多重继承、虚继承
### C++多重继承会出现什么问题/菱形继承、虚继承：解决菱形继承中的问题
- 会多次继承基类的基类
- 会带来二义性，无法确定是调用Base1的还是Base2的父类的虚函数，所以为了解决多重继承情况下成员访问的二义性，引入了虚继承机制
- [钻石问题（菱形继承问题） 和虚继承](https://www.cnblogs.com/sddai/p/6516668.html)


## 虚函数与构造函数、析构函数【答案参考01-构造and析构函数】
- 什么时候用虚析构函数
- 父类声明了虚析构函数，子类还要声明吗？  
  - 子类是否声明虚析构函数，具体要看该子类是否有多态性or有其他虚函数，如果满足上述条件，也该声明虚析构函数，这是为了防止以后还有一个derived类继承子类。
- 虚析构函数及其作用
- 构造函数、析构函数一般是不是虚函数，为什么构造函数不可以是虚函数；
- 构造函数中调用虚函数有什么问题
- 为什么基类的析构函数必须是虚函数
- 类的继承，虚构造析构函数、调用顺序
- 虚构造函数、虚析构函数、申请、释放顺序

## 其他
- 给定class Player2{private：int a; char b; double c; public： virtual fun(c){}}, 问sizeof(Player2)的大小？（虚函数表）
24。
### 重载和重写
- [C++ 重载(overload)、重写(overrride)、重定义(redefine)总结](https://www.cnblogs.com/tanky_woo/archive/2012/02/08/2343203.html)

#### 派生类中虚函数返回值必须与基类函数匹配，但有一个例外
当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。  

即一个返回\*base、一个返回\*derived时，是可以的。 

#### 重写：override
在C++11新标准中可以使用override关键字来说明派生类中重写了基类的虚函数。
#### 不允许重写：final
我们能把某个虚函数指定为final，这样的话后续任何尝试重写该函数的操作都将引发错误。
#### 防止继承发生：final
C++新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final。
```CPP
class NoDerived final {...}; //NoDerived不能作为基类
```

### 什么情况不能重载
- [C++函数重载(2) - 不能被重载的函数](https://blog.csdn.net/shltsh/article/details/45938663)
- [C++中不能重载的运算符](https://blog.csdn.net/qian_xia_er/article/details/79605761?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
