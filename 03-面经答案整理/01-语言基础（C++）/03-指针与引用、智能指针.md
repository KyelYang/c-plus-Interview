# 指针与引用、智能指针
## 面试问题
- 引用和指针
- 引用问题，int a = 1;int& b = a;int& c = b;
- C++11中的右值引用
- 引用的指针和指针的引用的场景
- C++中，对函数的传参会有拷贝的发生，如何避免拷贝？ 我只说了引用 指针 还有move，请教各位大佬还有其他什么办法吗？我没想到诶
- 指针和引用的区别？传指针和传引用的区别？
- 移动语义和完美转发介绍一下？
- 从汇编去解释一下引用

- C++ 11 智能指针用过吗？需要注意哪些？
- 智能指针，循环引用问题
- shared_ptr是否线程安全
- 了不了解智能指针，它是如何实现的
- 实现一个智能指针

# 指针与引用
## 引用
引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：
```CPP
int ival = 1024; 
int &refVal = ival; //refVal指向ival (是ival的另一个名字) 
int &refVal2; //报错：引用必须被初始化
```
一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定(bind)** 在一起，而不是将初始值拷贝给引用。  

一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，**因此引用必须初始化。**  

**引用即别名。**  

引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。  

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。  

因为引用本身不是一个对象，所以不能定义引用的引用。  

引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起（但是含有2个例外）：  
```CPP
int &refVal4 = 10;  //错误：引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval;  //错误：此处引用类型的初始值必须是int型对象
```

## 指针
指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。  

然而指针与引用相比又有很多不同点：  
- 其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。  
- 其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。  

### 获取对象的地址
指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）:  
```CPP
int ival =42;
int *p = &ival; // p存放变量ival的地址，或者说p是指向变量ival的指针  
```
除了将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配：  
```CPP
double dval;
double *pd = &dval; //正确：初始值是double型对象的地址
double *pd2 = pd; //正确：初始值是指向double对象的指针
int *pi = pd; //错误：指针pi的类型和pd的类型不匹配
pi = Sdval; //错误：试图把double型对象的地址赋给int型指针
```
因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。  

### 利用指针访问对象
如果指针指向了一个对象，则允许使川解引用符（操作符\*）来访问该对象：  
```CPP
int ival = 42;
int *p = Sival; // p存放着变量ival的地址，或者说p是指向变量ival的指针 
cout << *p;  //由符号*得到指针p所指的对象，输出42
```
解引用操作仅适用于那些确实指向了某个对象的有效指针。  

### 空指针
空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：  
```CPP
int *p1 = nullptr;  // 等价于 int *p1 = 0
int *p2 = 0;  //直接将p2初始化为字面常量0

// 需要引入#include<cstdlib>
int *p3 = NULL; // 等价于 int *p3 = 0
```
得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。  

nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。  

另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。  

过去的程序还会用到一个名为NULL的预处理变量来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。但这种方法不推荐。  

#### 空指针一定不能被赋值
- [NULL指针、零指针、野指针](https://www.cnblogs.com/fly1988happy/archive/2012/04/16/2452021.html)

### 赋值和指针
指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。  

指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样， 给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。  

### void* 指针
void\*是一种特殊的指针类型，可用于存放任意对象的地址。一个void\*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：  
```CPP
double obj = 3.14, *pd = &obj;  //正确：void*能存放任意类型对象的地址
void *pv = &obj ; //obj可以是任意类型的对象
pv = pd;  //pv可以存放任意类型的指针
```
利用void\*指针能做的事儿比较有限：拿它和別的指针比较、作为函数的输入或输出，或者赋给另外一个void\*指针。不能直接操作void\*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。  

概括说来，以void\*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。  

## 指针和引用的主要区别
- 引用在定义时必须初始化，而指针可不初始化。
- 引用在其生命周期内，只能指向一个对象，而指针可以先后指向不同的对象。
- 指针本身就是一个对象，允许对指针进行赋值和拷贝。

## 引用的指针和指针的引用
### 引用的指针
引用本身不是一个对象，因此不能定义指向引用的指针。  

### 指针的引用
指针是对象，所以存在对指针的引用：  
```CPP
int i = 42;
int *p; //p是一个int型指针
int *&r = p;  //r是一个对指针p的引用

r = &i; //r引用了一个指针，因此给r賦值&i就是令p指向i
*r = 0; //解引用r得到i，也就是p指向的对象，将i的值改为0
```
要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。  

离变量名最近的符号(此例中是&r的符号&)对变量的类型有最直接的影响，因此r是一个引用。  

声明符的其余部分用以确定r引用的类型是什么，此例中的符号\*说明r引用的是一个指针。  

最后，声明的基本数据类型部分指出r引用的是一个int指针。  

# 对象移动
新标准的一个最主要的特性是可以移动而非拷贝对象的能力。  

很多情况下都会发生对象拷贝，在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素（比如vector扩容）。   

使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型对象不能拷贝但可以移动。  

在旧C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如string），进 
行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。  

标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_Ptr类可以移动但不能拷贝。  

## 右值引用
为了支持移动操作，新标准引入了一种新的引用类型——右值引用(rvalue reference)。   

所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获得右值引用。如我们将要看到的，右值引用有一个重要的性质一只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。  

一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。  

类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对于常规引用(为了与右值引用区分开来，我们可以称之为左值引用(lvalue reference))，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。  

右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：  
```CPP
int i = 42;
int &r = i; //正确：r引用i
int &&rr = i; //错误：不能将一个右值引用绑定到一个左值上
int &r2 = i * 42; //错误：i*42是一个右值
const int &r3 = i * 42; //正确：我们可以将一个const的引用绑定到一个右值上
int &&rr2 = i * 42; //正确：将rr2绑定到乘法结果上
```
返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。  

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const的左值引用或者一个右值引用绑定到这类表达式上。  

###  左值持久；右值短暂
考察左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。  

由于右值引用只能绑定到临时对象，我们得知：
- 所引用的对象将要被销毁
- 该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。  

> 右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象“窃取”状态。  

### 变量是左值
变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行：  
```CPP
int &&rr1 = 42; //正确：字面常量是右值
int &&rr2 = rr1;  //错误：表达式rr1是左值！
```

### 标准库move函数
虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定 
到左值上的右值引用，此函数定义在头文件utility中：
```CPP
int &&rr3 = std::move(rr1); //ok
```
move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。  

> 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。  

> 使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。  


### 左值引用和右值引用的区别
- 右值引用是必须绑定到右值的引用；左值引用类似。
- 左值引用，也就是常规引用，返回左值的函数有赋值、下标、解引用和前置递增/递减运算符，左值有持久的状态。
- 右值引用就是必须绑定到右值上的引用，返回右值的函数包括算术、关系、位及后置递增/递减运算符，右值要么是字面常量，要么就是在表达式求值过程中创建的临时对象。  
- 左值持久，右值短暂

## 移动构造函数和移动赋值运算符
类似string类(及其他标准库类)，如果我们自己的类也同时支持移动和拷贝，那么也能从中受益。为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。  

### 类的移动操作过程
1. 检测自賦值
2. 清空新对象中的原始内容
3. 调用std::move()将源对象移动到新对象中
4. 销毁源对象

### 移动构造函数
类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。  

除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源一这些资源的所有权已经归属新创建的对象。  

作为一个例子，我们为StrVec类定义移动构造函数，实现从一个StrVec到另一个StrVec的元素移动而非拷贝：  
```CPP
StrVec: :StrVec (StrVec &&s) noexcept //移动操作不应抛出任何异常
//成员初始化器接管s中的资源
:elements(s.elements), first_free(s.first_free), cap(s.cap)
{
  s.elements = s.first_free = s.cap = nullptr;  //令s进入这样的状态——对其运行析构函数是安全的
}
```
与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptro这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。StrVec的析构函数在first_free上调用deallocate。如果我们忘记了改变s.first_free,则销毁移后源对&会释放掉我们刚刚移动的内存。  

### 移动操作、标准库容器和异常
noexcept是我们向标准库承诺一个函数不抛出异常的一种方法。  

不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。  

搞清楚为什么需要noexcept能帮助我们深入理解标准库是如何与我们自定义的类型交互的。我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实：首先，虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时其自身的行为提供保障。例如，vector保证，如果我们调用push_back时发生异常，vector自身不会发生改变。  

如我们刚刚看到的那样，移动一个对象通常会改变它的值。如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。在此情况下，vector将不能满足自身保持不变的要求。  

另一方面，如果vector使用了拷贝构造函数且发生了异常，它可以很容易地满足要求。在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生了异常，vector可以释放新分配的(但还未成功构造的)内存并返回。vector原有的元素仍然存在。  

为了避免这种潜在问题，除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。如果希望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数(及移动赋值运算符)标记为noexcept来做到这一点。  

### 移动赋值运算符
移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcepto类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：  
```CPP
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
  //直接检测自賦值
  if (this != &rhs) {
  free () ; //释放已有元素
  elements = rhs . elements;  //从rhs接管资源
  first free = rhs.first free;
  cap = rhs.cap;
  rhs.elements = rhs.first_free = rhs.cap = nullptr;  //将rhs置于可析构状态
  }
  return *this;
}
```

### 移后源对象必须可析构
在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。  

我们的StrVec的移动操作满足可析构的要求，这是通过将移后源对象的指针成员置为nullptr来实现的。  

### 合成的移动操作
与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。因此，某些类就没有移动构造函数或移动赋值运算符。  

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。  
```CPP
//编译器会为X和hasX合成移动操作
struct X {
  int i; //内置类型可以移动
  std: :string s; // string定义了自己的移动操作
};

struct hasX {
  X mem; // X有合成的移动操作
};

X x, x2 = std::move(x); //使用合成的移动构造函数
hasX hx, hx2 = std::move (hx); //使用合成的移动构造函数
```

移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。  

### 移动右值，拷贝左值
如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。  

例如，在我们的StrVec类中，拷贝构造函数接受一个const StrVec的引用。因此，它可以用于任何可以转换为StrVec的类型。而移动构造函数接受一个StrVec&&，因此只能用于实参是(非static)右值的情形：
```CPP
StrVec vl, v2;
vl = v2;  //v2是左值；使用拷贝賦值
StrVec getVec(istream &); //getVec返回一个右值
v2 = getVec(cin); //getVec (cin)是一个右值；使用移动赋值
```
在第一个赋值中，我们将v2传递给赋值运算符。v2的类型是StrVec ,表达式v2是一个左值。因此移动版本的赋值运算符是不可行的，因为我们不能隐式地将一个右值引用绑定到一个左值。因此，这个赋值语句使用拷贝赋值运算符。  

在第二个赋值中，我们赋予v2的是getVec调用的结果。此表达式是一个右值。在此情况下，两个赋值运算符都是可行的——将getVec的结果绑定到两个运算符的参数都是允许的。调用拷贝赋值运算符需要进行一次到const的转换，而StrVec&&则是精确匹配。因此，第二个赋值会使用移动赋值运算符。  

### 但如果没有移动构造函数，右值也被拷贝
如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。  
```CPP
class Foo {
  public:
  Foo() = default;
  Foo (const Foo&) ; //拷贝构造函数
  //其他成员定义，但Foo未定义移动构造函数
};

Foo x;
Foo y (x);  //拷贝构造函数；x是一个左值
Foo z (std::move(x));  //拷贝构造函数，因为未定义移动构造函数
```

### 拷贝并交换赋值运算符和移动操作
我们的HasPtr版本定义了一个拷贝并交换赋值运算符，它是函数匹配和移动操作间相互关系的一个很好的示例。如果我们为此类添加一个移动构 
造函数，它实际上也会获得一个移动赋值运算符。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。  
```CPP
class HasPtr {
public:
  //添加的移动构造函数
  HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;} 
  //賦值运算符既是移动賦值运算符，也是拷贝賦值运算符
  HasPtrS operator=(HasPtr rhs)
  { swap(*this, rhs); return *this; }
  ... //其他成员的定义
};

hp = hp2; // hp2是一个左值；hp2通过拷贝构造函数来拷贝
hp = std::move(hp2);  //移动构造函数移动hp2

```

### 移动迭代器
一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。  

我们通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代参数，返回一个移动迭代器。
原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别是，可以将移动迭代器传递给uninitialized_copy：
```CPP
void StrVec::reallocate(){
  //分配大小两倍于当前规模的内存空间
  auto newcapacity = size () ? 2 * size () : 1;
  auto first = alloc.allocate(newcapacity);
  auto last = uninitialized_copy(make_move_iterator(begin()),make_move_iterator(end()),first);  //移动元素
  free(); //释放空间 
  elements = first; //更新指针
  first free = last;
  cap = elements + newcapacity; 
}
```

uninitialized_copy对输入序列中的每个兀素调用construct来将元素“拷贝”到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素。由于我们传递给它的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着construct将使用移动构造函数来构造元素。  

值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。  

### 建议：不要随意使用移动操作
在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用std:move。  

## 右值引用和成员函数
除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。  

这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式————一个版本接受一个指向const的左值引用，第二个版本接受一个指向非const的右值引用。  

```CPP
void push_back (const X&);  //拷贝：绑定到任意类型的X
void push_back (X&&); //移动：只能绑定到类型X的可修改的右值
```
### 右值和左值引用成员函数
通常，我们在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值。例如:  
```CPP
string s1 = "a value", s2 = "another"; 
auto n = (s1 + s2).find("a");
```
此例中，我们在一个string右值上调用find成员，该string右值是通过连接两个string而得到的。有时，右值的使用方式可能令人惊讶：  
```CPP
si + s2 = "wow!";
```
此处我们对两个string的连接结果一一个右值，进行了赋值。  

在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望强制左侧运算对象(即，this指向的对象)是一个左值。  

我们指出this的左值/右值属性的方式与定义const成员函数相同，即在参数列表后放置一个引用限定符(reference qualifier)：  
```CPP
Foo &operator= (const Foo&) &; //只能向可修改的左值赋值
```
引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。类似const限定符，引用限定符只能用于(非static)成员函数，且必须同时出现在函数的声明和定义中。  

一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后：  
```CPP
class Foo {
public:
Foo someMem() & const;  //错误：const限定符必须在前
Foo anotherMem() const &; // 正确：const 限定符在前
};
```
### 重载和引用函数
就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和const来区分一个成员函数的重载版本。  

当我们定义const成员函数时，可以定义两个版本，唯一的差别是一个版本有const限定而另一个没有。  

引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加：
```CPP
class Foo {
public:
Foo sorted() &&;
Foo sorted() const; //错误：必须加上引用限定符
// Comp是函数类型的类型别名
//此函数类型可以用来比较int值
using Comp = bool(const int&, const int&);
Foo sorted (Comp*);   //正确：不同的参数列表
Foo sorted (Comp*) const; //正确：两个版本都没有引用限定符
};
```
# 移动语义和完美转发
## 讲的非常好的博客——从右值引用到移动语义到完美转发
### [C++右值引用](https://zhuanlan.zhihu.com/p/54050093)
### [C++11的右值引用和转移语义和完美转发](https://zhuanlan.zhihu.com/p/88584015)
### [如何评价 C++11 的右值引用（Rvalue reference）特性？](https://www.zhihu.com/question/22111546)

# 智能指针
## 智能指针的正确使用方式
- [C++ 智能指针的正确使用方式](https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/)
- [智能指针的正确实践](https://zhuanlan.zhihu.com/p/30933682)
## unique_ptr的应用场景
### 1.更加安全的管理动态对象
假如我们在一段代码中，需要创建一个对象，处理一些事情后返回，返回之前将对象销毁，如下所示：  
```CPP
void process()
{
    Widget* w = new Widget();
    w->do_something(); // 可能会发生异常
    delete w;
}
```
在正常流程下，我们会在函数末尾 delete 创建的对象 w，正常调用析构函数，释放内存。  

但是如果 w->do_something() 发生了异常，那么 delete w 将不会被执行。此时就会发生 内存泄漏。  
我们当然可以使用 try…catch 捕捉异常，在 catch 里面执行 delete，但是这样代码上并不美观，也容易漏写。  


如果我们用 std::unique_ptr，那么这个问题就迎刃而解了。无论代码怎么抛异常，在 unique_ptr 离开函数作用域的时候，内存就将会自动释放。  

### 2. 可以轻松高效隐式地转换为std::shared_ptr
std::unique_ptr最吸引人的特性之一是它可以轻松高效隐式地转换为std::shared_ptr:
```CPP
std::shared_ptr<Investment> sp = makeInvestment( arguments );
```
这即是std::unique_ptr适合作为工厂函数返回类型的关键原因所在。工厂函数无法知道调用者是否希望对返回的对象使用独占语义，或者共享语义。通过返回std::unique_pt，工厂函数得以保证当调用者需要实现共享语义时可以轻松从unique_ptr转换得到shared_ptr。




### [窥见C++11智能指针](https://zhuanlan.zhihu.com/p/78123220)
### [要是面试官再问你智能指针的问题，就拿这篇文章“盘他”！！！](https://zhuanlan.zhihu.com/p/63488452)
### [c++11&14-智能指针专题](https://zhuanlan.zhihu.com/p/73807983)
### [c++是否应避免使用普通指针，而使用智能指针（包括shared，unique，weak）？](https://www.zhihu.com/question/319277442)

## C++ 11 智能指针用过吗？需要注意哪些？

## auto_ptr为什么被废弃
### 理由1: auto_ptr在转移指针所有权后会产生野指针，导致程序运行时crash
### 理由2：copy的过程中强制所有权转移，因此不适用很多场景
auto_ptr采用copy语义来转移指针资源，转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的(不会修改原数据)，而这样的行为在有些场合下不是我们希望看到的。  

例如参考《Effective STL》第8条，sort的快排实现中有将元素复制到某个局部临时对象中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。  

而现在C++11的对move语义的支持，使得这样的资源转移通常只会在必要的场合发生，例如转移一个临时变量（右值）给某个named variable（左值），或者一个函数的返回（右值）这也就是用unique_ptr代替auto_ptr的原因。  

本质上来说，就是unique_ptr禁用了copy，而用move替代。之所以说通常，是因为，也可以用std:move来实现左值move给左值，例如：
```CPP
std::unique_ptr<bar> b0(new bar());
std::unique_ptr<bar> b1(std::move(b0));
```

## 智能指针，循环引用问题
使用weak_ptr。  

## shared_ptr是否线程安全
### [为什么多线程读写 shared_ptr 要加锁？](https://blog.csdn.net/Solstice/article/details/8547547)

## 实现一个智能指针
### 【这个博客写的非常好！推荐！】[C++ 智能指针：原理与实现](https://blog.imalan.cn/archives/322/)
