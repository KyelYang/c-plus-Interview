# 其他知识点
## 面试问题

## resize和reserve的区别
- [vector中resize()和reserve()的区别](https://www.cnblogs.com/jiu0821/p/4415829.html)
- [C++：vector中的resize()函数 VS reserve()函数](https://www.cnblogs.com/biyeymyhjob/archive/2013/05/11/3072893.html)
## memcpy和strcpy的区别
- 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。  

- 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。  

- 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

## memcpy和memmove的区别
他们的作用是一样的，唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。


## 数组名和指针区别
大部分情况下，数组名会被隐式转换成指向首元素的指针类型的右值。  
因此，大多数情况数组名可以当做是指向数组首地址的指针，但下述情况例外：  
### 数组名指针的类型和单独指针的类型不同，导致sizeof和&结果不同
```C
char arr[] = "abcd";
char *ptr = "abcd";

sizeof(arr);  //5，数组长度为4，结尾包含一个‘\0’，因此大小为5
sizeof(ptr);  //8，这个8指的是地址的大小，地址大小不随类型的改变而改变（double类型指针也为8），只随机器上地址位数的改变而改变，此机器为64位
```
arr是单独的类型，即「长度为4的char数组」类型，而不是「指向char的指针」类型。

因此，求sizeof(arr)得到的是数组的尺寸5(数组长度为4，结尾包含一个‘\0’，因此大小为5)。  

&arr得到的不是「指向指针的指针」类型，而是「指向长度为4的数组的指针」类型，即char(\*)\[4] 类型，此处4不能省略，因为「指向不确定长度数组的指针」是没有意义的，编译器若不知道该指针指向的类型，就无法编译指针的加减法运算(指针指向类型的长度未知，加减法的位移量就未知)。

### 数组名时指针常量，指针是变量
```C
char arr[] = "abcd";
char *ptr = "abcd";

ptr = arr; //可以修改
arr = ptr; //错误，不能给数组类型赋值
```
### 使用字符串常量初始化后的修改权限不同
arr的内容存放在栈上，函数返回后栈被清掉，它就没了。  

指针ptr指向的内容存放在只读内存区，因此该存放的内容无法被修改。  
```C
char arr[] = "abcd";
char *ptr = "abcd";

arr[1] = 'e'; //可以修改
ptr[1] = 'e'; //不能修改，导致内存段错误，主要是因为访问的是内存的只读区（only-read），只读区不允许修改内容
```
前者声明一个数组，字符串字面量用于初始化数组。假如数组没有 const限定符，字符串内容是可以修改的。  

后者声明一个指针。字符串字面量本身成为一个静态存储期的数组，它再隐式转换成指针以初始化声明的指针。这个字符串是不可修改的（修改会导致未定义行为，数组本身可放在只读内存区）。它的首地址可以在函数中返回。

## vector<vector<int> >中>>之间的空格是否是必须的？
- [vector<vector<int> >中>>之间的空格是否是必须的？](https://www.zhihu.com/question/40072405)

## inline的作用
### 可避免函数调用的开销 

- 函数调用的代价  

调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。  

将函数指定为内联函数(inline),通常就是将它在每个调用点上“内联地”展开。从而避免函数调用，减少开销。  

> 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。  

- 什么时候适用内联函数  

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。  

[史上最全的C++/游戏开发面试问题总结（一）——C++基础](https://zhuanlan.zhihu.com/p/47869981)  

## inline内联函数return怎么处理（内联函数涉及到编译原理相关知识，该问题先放放）

## main函数返回值的作用
main函数的返回值用于说明程序的退出状态，并且将该状态告知给操作系统。  

如果正常退出，操作系统会继续执行后续操作。如果异常退出，则程序中断。  

返回0，则代表程序正常退出。返回其它数字的含义则由系统决定。通常，返回非零代表程序异常退出。  


[细谈C语言中的main返回值](https://blog.csdn.net/piaojun_pj/article/details/5986516)  

## 如何获取main函数返回值  

访问main的返回值的方法依赖于系统。在UNIX和Windows系统中，执行完一个程序后，都可以通过echo命令获得其返回值。  


在UNIX系统中，通过如下命令获得状态：
```
$ echo $?
```
在Windows系统中查看状态可键入：
```
$ echo %ERRORLEVEL%
```

[在 C++ 中如何获得 main 函数的返回值，将它输出？](https://www.zhihu.com/question/24363915)  

## 如何在mian函数之前执行函数
[C/C++中如何在main()函数之前执行一条语句？](https://www.zhihu.com/question/26031933)  


## 为什么c++要“在头文件中声明，在源文件中定义”？
- [为什么c++要“在头文件中声明，在源文件中定义”？](https://www.zhihu.com/question/58547318/answer/157444718)

## 为什么要求模板类的类声明和类实现要都放在头文件而不能分离
- [C++ 中的模板类声明头文件和实现文件分离后，如何能实现正常编译？](https://www.zhihu.com/question/20630104/answer/15722407)

## static详解
- [C/C++ 中的static关键字](https://zhuanlan.zhihu.com/p/37439983)

## 内存泄露
- [C++不用工具，如何检测内存泄漏？ - andrew show的回答]( https://www.zhihu.com/question/29859828/answer/54865004)  
- [c++怎么检测内存泄露，怎么定位内存泄露？](https://www.zhihu.com/question/63946754)
- [C++ 如何避免内存泄漏](https://zhuanlan.zhihu.com/p/51898119)  

### 内存泄漏和内存溢出有啥区别？
- [内存泄漏和内存溢出有啥区别？](https://www.zhihu.com/question/40560123)

## volatile关键字
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。  

### volatile的应用场景
volatile常用在多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方：  
- 中断服务程序中修改的供其它程序检测的变量需要加volatile；
- 多任务环境下各任务间共享的标志应该加volatile；
- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。  

如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。  

volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。  

- [C/C++要点全掌握（五）——mutable、volatile](https://blog.csdn.net/tht2009/article/details/6920511)
- [C/C++中volatile关键字详解](https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html)
- [谈谈 C/C++ 中的 volatile](https://liam.page/2018/01/18/volatile-in-C-and-Cpp/)

## Python与C++的区别

### 语言特点
Python是一种灵活的，面向对象的开源编程语言，旨在提高开发速度并促进编写可理解，可重用和可修改的软件。它是专门为提高脚本开发要求的质量而设计的。  

C ++是对C编程语言的扩展而开发的，其主要应用是广义上的系统编程。 C++是一种通用编程语言，最适合资源有限的应用程序，例如：适用于软件基础结构中的应用程序。  

### 语言类型 
Python是一种动态类型化和强类型化语言，其中在运行时进行类型检查，并且不能将变量隐式限制为不相关的类型。  

C++是一种静态类型语言，其中在编译过程中显式声明和确定了各种类型。作为C++输入的静态语言将类型与变量而不是值相关联。

#### 强类型、弱类型、静态类型、动态类型
**轮子哥解释**  
- 强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double
- 弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double
- 静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。
- 动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。

从强弱类型的角度看，C语言是弱类型语言，相对C语言而言，C++是偏强类型的语言，JAVA是强类型语言。  

**其他人解释**  
- 动态类型语言：在运行期进行类型检查的语言，也就是在编写代码的时候可以不指定变量的数据类型，比如Python和Ruby
- 静态类型语言：它的数据类型是在编译期进行检查的，也就是说变量在使用前要声明变量的数据类型，这样的好处是把类型检查放在编译期，提前检查可能出现的类型错误，典型代表C/C++和Java
- 强类型语言，一个变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。举个例子：如果你定义了一个double类型变量a,不经过强制类型转换那么程序int b = a无法通过编译。典型代表是Java。
- 弱类型语言：它与强类型语言定义相反,允许编译器进行隐式的类型转换，典型代表C/C++。  


[弱类型、强类型、动态类型、静态类型语言的区别是什么？](https://www.zhihu.com/question/19918532)

### 内存管理
Python程序通常没有需要关注内存管理，语言为您做到了。在复杂的C应用程序中，您必须自己考虑内存管理。  

Python使用动态内存分配过程，该过程包括一个包含所有Python数据对象和结构的私有堆。当不再使用存储收集器时，它会自动将内存还原到系统中。集成的存储恢复系统可确保高效的存储管理。另一方面，C ++不需要存储收集器，因为它没有内存，这使其更容易发生内存泄漏。 C ++中的内存管理容易出错且耗时。区别在于性能和安全性之间的折衷。

### 性能
Python被编译为字节码，然后由大型C程序进行解释。 C直接编译为由CPU直接执行的机器代码。因此，C通常比等效的Python程序快很多。  

Python内置了一个系统，因此可以调用C代码，如果您有性能应用程序的关键部分始终可以用C编写，然后像使用Python函数一样使用。  

因为Python的默认实现当前是用C编码的，所以Python解释器具有将C程序与C ++程序混合的所有常用规则。如果Python嵌入在C ++程序中，则没有特殊规则可遵循：只需在Python库中创建一个链接，然后在C ++中调用其函数即可。 Python非常适合现代软件方法，例如模块化，结构化和面向对象的设计，这些方法允许编写一次代码并多次重用。 C ++是一种简单的语言，与Python相比，通用性较低，而且较难学习。  

### 标准库
Python附带了一个庞大的标准库，该库执行从Web服务到函数式编程的所有操作，并包括GUI framework。 C标准库提供了一些数学和I / O服务，您还需要自己构建其他内容-或找到第三方库/框架。  
Python的社区提供了100,000多种免费使用的软件包（所有软件包都存放在一个地方），几乎涵盖了所有可能的软件包。从天文库到Web框架的功能。除非您知道在哪里寻找，否则找到C的第三方库可能会很痛苦-而且其中许多都不是免费的。

## 4种强制类型的转换
### C++Primer解释
#### static_cast
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。  

#### const_cast
const_cast只能改变运算对象的底层const。  

#### reinterpret_cast
reinterpret_cast通常为运算对象的位模式（二进制地址）提供较低层次上的重新解释。  

使用reinterpret_cast是非常危险的。  

reinterpret_cast本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。  

#### dynamic_cast 运算符
运行时类型识别(run-time type identification，RTTI)的功能由两个运算符实现：  
- typeid运算符，用于返回表达式的类型。
- dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。  


当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型。  

这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。  

一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本。  

然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个RTTI运算符。另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。  

### 知乎解释
C风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是：TYPE b = (TYPE)a，但是c 风格的类型转换有不少的缺点 

有的时候用c风格的转换是不合适的，因为它可以在任意类型之间转换，比如你可以把一个指向const对象的指针转换成指向非const对象的指针，把一个指向基类对象的指针转换成指向一个派生类对象的指针，这两种转换之间的差别是巨大的，但是传统的c语言风格的类型转换没有区分这些。  

还有一个缺点就是，c风格的转换不容易查找，他由一个括号加上一个标识符组成，而这样的东西在c++程序里一大堆。  

所以c++为了克服这些缺点，引进了4种类型转换操作符（C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。）

#### static_cast
可以实现C++中内置基本数据类型之间的相互转换，enum、struct、 int、char、float等。它不能进行无关类型(如非基类和子类)指针之间的转换。
```CPP
int c=static_cast<int>(7.987);
```
如果涉及到类的话，static_cast只能在有相互联系的类型中进行相互转换，不一定包含虚函数。  

#### const_cast
const_cast操作不能在不同的种类间转换。相反，它仅仅把一个它作用的表达式转换成常量。  

它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。  

#### reinterpret_cast
interpret是解释的意思，reinterpret即为重新解释，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。有着和C风格的强制转换同样的能力。  

它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。  

#### dynamic_cast
- 其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。  
- 不能用于内置的基本数据类型的强制转换。  
- dynamic_cast转换如果成功的话返回的是指向类的指针或引用，指针转换失败的话则会返回NULL，引用转换失败会发送bad_cast异常。  
- 使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。  
> 需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见<Inside c++ object model>）中，只有定义了虚函数的类才有虚函数表。  

- 在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比 static_cast更安全。向上转换即为即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。  

