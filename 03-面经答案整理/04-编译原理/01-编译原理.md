# 编译原理
# 面试问题
## extern C 
extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。  


这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。  

- [C++学习之extern关键字](https://songlee24.github.io/2014/07/05/C-extern-C/)


## C++ 从编译到链接发生了什么 ？
简述过程就是：
- 预处理：预处理阶段主要处理预处理的相关命令，比如以#开头的代码，只是做简单的预处理代码的替换，代码逻辑没有发生改变。 
- 编译：将预处理后的文件翻译成汇编代码.s文件。 
- 汇编：将汇编文件翻译成机器指令，并打包成可重定位目标程序的O文件。该文件是二进制文件。 
- 链接：将引用的其他O文件并入到我们程序所在的o文件中，处理得到最终的可执行文件。

- [C/C++——程序实现过程之编译、链接和执行](https://blog.csdn.net/u010757264/article/details/50082925)

## 编译时链接有几种方式/静态链接和动态链接的区别
- [动态链接库与静态链接库相比，优势和劣势都在哪里？](https://www.zhihu.com/question/24306336)
- [Linux 中的动态链接库和静态链接库是干什么的？](https://www.zhihu.com/question/20484931)

## 如果一个动态编译后的文件，可能缺少了某些动态库，我们应该怎么把它们添加上？
设置载入路径的最简单方法是通过环境变量 LD_LIBRARY_PATH。  

例如，下面的命令设置载入路径为“/opt/gdbm-1.8.3/lib”，以便载入器能够找到“libgdbm.so”：   
```shell
$ LD_LIBRARY_PATH=/opt/gdbm-1.8.3/lib 
$ export LD_LIBRARY_PATH 
```
以上方式为设置新的载入路径，如果机器上原本就包含一些载入路径（多数情况如此），则应该在原始的基础上添加新的载入路径：
```shell
$ export LD_LIBRARY_PATH=/opt/gdbm-1.8.3/lib:$LD_LIBRARY_PATH 
```
## 静态库和动态库介绍
外部库通常用两种形式提供：静态库和共享库。  
### 静态库
静态库就是前面看到过的“.a”文件。当程序与一个静态库链接时，该程序用到的外部函数（在用到的静态库包含的对象文件中）的机器码被从库中复制到最终生成的可执行文件中。   

### 动态库以及动态链接
处理共享库用的是一种更加高级的链接形式，它会使得可执行文件比较小。共享库使用“.so”后缀名，它代表共享对象（shared object）。  

一个与共享库链接的可执行文件仅仅包含它用到的函数相关的一个表格，而不是外部函数所在的对象文件的整个机器码。在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该共享库中复制到内存中——这个过程被称作动态链接（dynamic linking）。   

因为一份库可以在多个程序间共享，所以动态链接使得可执行文件更小，也节省了磁盘空间。绝大部分操作系统提供了虚拟内存机制，该机制允许物理内存中的一份共享库被要用到该库的所有运行的程序共用，节省了内存和磁盘空间。   

此外，共享库使得升级库而无需重新编译用到它的程序（只要库提供的接口不变就行）。   

由于这些优点，如果可能，在绝大部分系统上 gcc 编译程序时默认链接到共享库。  

使用选项“-lNAME”的情况下，静态库“libNAME”可以用于链接，但编译器首先会检查具有相同名字
和“.so”为扩展名的共享库。   

在上面的例子中，当编译器在链接路径中搜索“libgdbm”时，它在“/opt/gdbm-1.8.3/lib”目录中找到下面两个文件： 
```shell
$ cd /opt/gdbm-1.8.3/lib 
$ ls libgdbm.* 
libgdbm.a libgdbm.so 
```
结果是，“libgdbm.so”共享库优先于“libgdbm.a”静态库被使用。   

和静态库相比，动态库需要特殊对待——编译后生成可执行文件之前，它必须先从磁盘上被载入到内存中。 

因此，当启动可执行文件时，载入器为了把共享库载入内存，必须先找到它。默认情况下，载入器仅在一些预定义的系统目录中查找共享库，比如“/usr/local/lib”和“/usr/lib”。如果库不在这些目录中，那它必须被添加到载入路径（load path）中去。  

设置载入路径的最简单方法是通过环境变量 LD_LIBRARY_PATH。  

例如，下面的命令设置载入路径为“/opt/gdbm-1.8.3/lib”，以便载入器能够找到“libgdbm.so”：   
```shell
$ LD_LIBRARY_PATH=/opt/gdbm-1.8.3/lib 
$ export LD_LIBRARY_PATH 
```

为了不要每次都输入，LD_LIBRARY_PATH 环境变量可以一次性的被设置到 shell 的相应登录文件中，象 GNU Bash shel的“.bash_profile”文件。   

### 正确添加载入路径的方法
多个共享库目录可以用冒号分隔列表 DIR1:DIR2:DIR3:...:DIRN 的形式放入载入路径中。  

例如下面的命令设置载入路径，用到了“/opt/gdbm-1.8.3”和“/opt/gtk-1.4”中的“lib”目录： 
```shell
$ LD_LIBRARY_PATH=/opt/gdbm-1.8.3/lib:/opt/gtk-1.4/lib 
$ export LD_LIBRARY_PATH 
```

**如果载入路径包含已有项，可以用语法：LD_LIBRARY_PATH=NEWDIRS: $LD_LIBRARY_PATH来扩展**  

例如，下面的命令象上面显示的那样把目录“/opt/gsl-1.5/lib”添加到载入路径中： 
```shell
$ LD_LIBRARY_PATH=/opt/gsl-1.5/lib:$LD_LIBRARY_PATH 
$ echo $LD_LIBRARY_PATH 
/opt/gsl-1.5/lib:/opt/gdbm-1.8.3/lib:/opt/gtk-1.4/lib 
```

系统管理员可以为所有用户设置 LD_LIBRARY_PATH 变量，只要把它添加到默认的登录脚本中，比如象“/etc/profile”。在 GNU 系统上，系统范围的路径也可以被定义在载入器配置文件“/etc/ld.so.conf”中。   

### 禁止使用动态库的方法——-static
相比较，使用“-static”选项可以迫使 gcc 静态链接，避免使用共享库： 
```shell
$ gcc -Wall -static -I/opt/gdbm-1.8.3/include/ 
-L/opt/gdbm-1.8.3/lib/ dbmain.c -lgdbm 
```
这就创建了一个与静态库“ libgdbm.a ”链接的可执行文件，它不需要设置环境变量LD_LIBRARY_PATH 或把共享库存放在默认目录中就可以运行。  

### 其他方法
正像前面一样要注意的，通过在命令行上指定库的完整路径，直接与个别库文件链接也是可以的。  

例如，下面的命令将直接与静态库“libgdbm.a” 链接：
```shell
$ gcc -Wall -I/opt/gdbm-1.8.3/include 
dbmain.c /opt/gdbm-1.8.3/lib/libgdbm.a 
```

而下面的命令将与共享库文件“libgdbm.so”链接：   
```shell
$ gcc -Wall -I/opt/gdbm-1.8.3/include 
dbmain.c /opt/gdbm-1.8.3/lib/libgdbm.so 
```

对于后者，要运行该可执行文件，还是需要设置该库的载入路径（因为是动态库）。  

## 检查core文件
- [ubuntu设置产生core文件](http://vra.github.io/2017/12/03/ubuntu-core-dump-debug/)

## c++模板类/模板函数的声明与定义应该放在头文件里

函数模板是编译时自动生成各种类型的函数实例，如同内联函数，编译时其实现必须可见，一般其实现应该包含在头文件中。  

模板函数的声明定义要放在头文件中，不可以分开放在.h和.cpp中，不然会导致链接错误。  

同样，在一个类中将一个成员函数定义为函数模板时也是要遵从这个规则：实现要放在头文件里。 
