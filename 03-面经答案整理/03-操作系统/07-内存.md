## 内存空间布局
- 一个进程内存空间都有什么
### 多个进程的地址可以一样吗？
有可能一样。  
- [【内存寻址】请问每个进程的线性空间是独立的吗还是系统中所有的进程共享一个线性空间?](https://www.zhihu.com/question/348151463)
- [A进程的虚拟地址对应一个物理地址空间，切换B进程，B进程用的物理地址空间会不会和A用到的是同一个？]()https://www.zhihu.com/question/343025010
- C++内存管理有哪些分区，堆和栈有什么区别
- 堆和栈（内存布局，内核空间、用户空间）
- linux 的虚拟内存是什么？
- 虚拟内存寻址空间大小
- 内存的映射空间有哪几个段？
- 什么数据存在堆，什么数据存在栈?
- 什么时候可以申请用堆的数据？
- 申请堆空间会有什么问题？
- c++类的内存布局，有虚函数时候和多继承时候
- 进程的地址空间（进程的内存地址分布）堆在栈之上
- 堆和栈的区别，在内存中分别是位于哪个方向？
- 内存映射的原理

## 内存分配
- 内存分配原理
- linux内存分配算法
- 内存分配，从代码段讲到栈了 问我栈上面是什么 GG
- new的内存分配
- Cpp 类对象的内存分布
- 熟悉vector和list吗，讲一下对应的内存分配策略，讲一下插入时间复杂度。
- 除了new和malloc，还有什么方式可以在堆中分配内存么？---mmap，怎么释放？munmap
- 内存分配算法了解吗，比如说给你一个内存池
- 内存分配方式有哪几种；区别是什么；
- Stl内存分配器
- Malloc函数如何分配内存
- Malloc分配的内存如何从虚拟内存到物理内存映射
- malloc分配的是虚拟内存还是物理内存？
- memset操作malloc的指针，是操作物理内存还是虚拟内存？
- new和malloc的区别和联系，如何判断申请内存失败；
- vector动态分配内存怎么实现的？旧数据会拷贝过去吗？
- 内核态用户态以及如何切换；是否每次申请内存都需要切换到内核态，linux内存分配器叫什么名字，具体内存分配实现；

## 内存分配的实际问题
- 在一台内存为2G的机器上，malloc(20G)会怎么样？new 20G呢？
- 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢
- 如果memcopy的俩字符串内存存在重叠怎么办（用指针倒着拷贝）
- C++程序崩溃申请的内存会释放吗
- vector内存增长问题
- 扩容的时候内存用什么来分配？
- 进程疯狂申请内存，new， kill掉以后内存会不会释放 会！
- 不同进程是如何保证使用的内存互不影响
- 问了一下平时怎么调试，内存不断增长的话怎么判断哪里出了问题，调试方面问了很多，用了什么调试方式（我基本只打断点，所以很尴尬，全程啥也不会）
- 4G的虚拟地址能否访问1G的物理内存？如果页满了怎么办？
- 进程的内存一直在涨，怎么定位
- 虚拟内存为什么是4G，是所有进程的虚拟内存都是4G吗？为什么？
- 当应用程序用到的内存超过4G了怎么办？
- new分配了100M内存没有使用它，它有没有占用物理内存？
- 场景题，假如我有32G的内存，要使用一个64G的内存，你会怎么做。（虚拟内存）那什么情况下使用虚拟内存的32G的内存会炸呢（运行一个完全使用33G的进程会炸）你如何写出这样的进程（在一个死循环里面疯\***作使用内存的操作）
- C语言变量如何找到内存地址

## 共享内存相关系统调用
## mmap
mmap()系统调用在调用进程的虚拟地址空间中创建一个新内存映射。映射分为两种。  

### mmap概述
mmap()系统调用在调用进程的虚拟地址空间中创建一个新内存映射。  

munmap()系统调用执行逆操作，即从进程的地址空间中删除一个映射。  


映射可以分为两种：基于文件的映射和匿名映射。  

文件映射将一个文件区域中的内容映射到进程的虚拟地址空间中。匿名映射（通过使用MAP_ANONYMOUS标记或映射/dev/zero来创建）并没有对应的文件区域，该映射中的字节会被初始化为0。  

映射既可以是私有的（MAP_PRIVATE），也可以是共享的（MAP_SHARED）。这种差别确定了在共享内存上发生的变更的可见性，对于文件映射来讲，这种差别还确定了内核是否会将映射内容上发生的变更传递到底层文件上。当一个进程使用 MAP_PRIVATE 映射了一个文件之后，在映射内容上发生的变更对其他进程是不可见的，并且也不会反应到映射文件上。MAP_SHARED 文件映射的做法则相反——在映射上发生的变更对其他进程可见并且会反应到映射文件上。  

尽管内核会自动将发生在一个 MAP_SHARED 映射内容上的变更反应到底层文件上，但它不保证何时会完成这个操作。应用程序可以使用 msync()系统调用来显式地控制一个映射的内容何时与映射文件进行同步。  

内存映射有很多用途，包括：  
- 分配进程私有的内存（私有匿名映射）
- 对一个进程的文本段和初始化数据段中的内容进行初始化（私有文件映射）
- 在通过 fork()关联起来的进程之间共享内存（共享匿名映射）
- 执行内存映射 I/O，还可以将其与无关进程之间的内存共享结合起来（共享文件映射）  

在访问一个映射的内容时可能会遇到两个信号。如果在访问映射时违反了映射之上的保护规则（或访问一个当前未被映射的地址），那么就会产生一个 SIGSEGV 信号。对于基于文件的映射来讲，如果访问的映射部分在文件中没有相关区域与之对应（即映射大于底层文件），那么就会产生一个 SIGBUS 信号。  


交换空间过度利用允许系统给进程分配比实际可用的 RAM 与交换空间之和更多的内存。过度利用之所以可能是因为所有进程都不会全部用完为其分配的内存。使用MAP_NORESERVE 标记可以控制每个 mmap()调用的过度利用情况，而使用/proc 文件则可以控制整个系统的过度利用情况。  

mremap()系统调用允许调整一个既有映射的大小。remap_file_pages()系统调用允许创建非线性文件映射。  


### 文件映射与匿名映射
#### 文件映射  
文件映射将一个文件的一部分直接映射到调用进程的虚拟内存中。一旦一个文件被映射之后就可以通过在相应的内存区域中操作字节来访问文件内容了。映射的分页会在需要的时候从文件中（自动）加载。这种映射也被称为基于文件的映射或内存映射文件。

#### 匿名映射  
一个匿名映射没有对应的文件。相反，这种映射的分页会被初始化为 0。  

### 根据进程能否看到其他进程对分页内容做出的变更，可分为私有映射与共享映射
#### 私有映射（MAP_PRIVATE）
在映射内容上发生的变更对其他进程不可见，对于文件映射来讲，变更将不会在底层文件上进行。  

尽管一个私有映射的分页在上面介绍的情况中初始时是共享的，但对映射内容所做出的变更对各个进程来讲则是私有的。内核使用了写时复制（copy-on-write）技术完成了这个任务。这意味着每当一个进程试图修改一个分页的内容时，内核首先会为该进程创建一个新分页并将需
修改的分页中的内容复制到新分页中（以及调整进程的页表）。正因为这个原因，MAP_PRIVATE 映射有时候会被称为私有、写时复制映射。  

#### 共享映射（MAP_SHARED）  
在映射内容上发生的变更对所有共享同一个映射的其他进程都可见，对于文件映射来讲，变更将会发生在底层的文件上。  


### 各种内存映射的用途
上面介绍的两个映射特性（文件与匿名以及私有和共享）可以以四种不同的方式加以组合：  
<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/144.jpg" width = 60% height = 60% /></div>  

要创建一个文件映射需要执行下面的步骤：  
- 获取文件的一个描述符，通常通过调用 open()来完成
- 将文件描述符作为 fd 参数传入 mmap()调用

执行上述步骤之后 mmap()会将打开的文件的内容映射到调用进程的地址空间中。  

一旦mmap()被调用之后就能够关闭文件描述符了，而不会对映射产生任何影响。但在一些情况下，将这个文件描述符保持在打开状态可能是有用的。  


#### 私有文件映射
映射的内容被初始化为一个文件区域中的内容。多个映射同一个文件的进程初始时会共享同样的内存物理分页，但系统使用写时复制技术使得一个进程对映射所做出的变更对其他进程不可见。  

这种映射的主要用途是使用一个文件的内容来初始化一块内存区域。一些常见的例子包括根据二进制可执行文件或共享库文件的相应部分来初始化一个进程的文本和数据段。

**两种常见用途和一种不常见用途**  
- 允许多个执行同一个程序或使用同一个共享库的进程共享同样的（只读的）文本段，它是从底层可执行文件或库文件的相应部分映射而来的。  
- 映射一个可执行文件或共享库的初始化数据段。这种映射会被处理成私有使得对映射数据段内容的变更不会发生在底层文件上。
- mmap()的这两种用法通常对程序是不可见的，因为这些映射是由程序加载器和动态链接器创建的。可以在/proc/PID/maps 的输出中发现这两种映射。  
- 私有文件映射的另一个不太常见的用途是简化程序的文件输入逻辑。这与使用共享文件映射来完成内存映射 I/O类似，但它只允许文件输入。

#### 共享文件映射
所有映射一个文件的同一区域的进程会共享同样的内存物理分页，这些分页的内容将被初始化为该文件区域。对映射内容的修改将直接在文件中进行。  

**两种主要用途**  

**用途一：内存映射 I/O**  
由于共享文件映射中的内容是从文件初始化而来的，并且对映射内容所做出的变更都会自动反应到文件上，因此可以简单地通过访问内存中的字节来执行文件 I/O，而依靠内核来确保对内存的变更会被传递到映射文件中。这项技术被称为内存映射 I/O，它是使用 read()和 write()来访问文件内容这种方法的替代方案。  

内存映射 I/O 具备两个潜在的优势：
- 使用内存访问来取代 read()和 write()系统调用能够简化一些应用程序的逻辑
- 在一些情况下，它能够比使用传统的 I/O 系统调用执行文件 I/O 这种做法提供更好的性能  


内存映射 I/O 之所以能够带来性能优势的原因：  
- 正常的 read()或 write()需要两次传输
> 一次是在文件和内核高速缓冲区之间，另一次是在高速缓冲区和用户空间缓冲区之间。使用 mmap()就无需第二次传输了。对于输入来讲，一旦内核将相应的文件块映射进内存之后用户进程就能够使用这些数据了。对于输出来讲，用户进程仅仅需要修改内存中的内容，然后可以依靠内核内存管理器来自动更新底层的文件。  

- 除了节省了内核空间和用户空间之间的一次传输之外，mmap()还能够通过减少所需使用的内存来提升性能  
> 当使用 read()或 write()时，数据将被保存在两个缓冲区中：一个位于用户空间，另一个位于内核空间。当使用 mmap()时，内核空间和用户空间会共享同一个缓冲区。此外，如果多个进程正在在同一个文件上执行 I/O，那么它们通
过使用 mmap()就能够共享同一个内核缓冲区，从而又能够节省内存的消耗。  

内存映射 I/O 所带来的性能优势在在大型文件中执行重复随机访问时最有可能体现出来。  

内存映射 I/O 也有一些缺点。对于小数据量 I/O 来讲，内存映射 I/O 的开销（即映射、分页故障、解除映射以及更新硬件内存管理单元的超前转换缓冲器）实际上要比简单的read()或 write()大。  

**用途二：使用共享文件映射的 IPC**  
- 允许无关进程共享一块内容以便以一种类似于 System V 共享内存段的方式来执行（快速）IPC。  
- 【持久化特性】这种共享内存区域与 System V 共享内存对象之间的区别在于区域中内容上的变更会反应到底层的映射文件上。这种特性对那些需要共享内存内容在应用程序或系统重启时能够持久化的应用程序来讲是非常有用的。 

#### MAP_PRIVATE 私有匿名映射

创建匿名映射存在两种不同但等价的方法：使用MAP_ANONYMOUS参数、/dev/zero文件描述符。  


每次调用 mmap()创建一个私有匿名映射时都会产生一个新映射，该映射与同一（或不同）进程创建的其他匿名映射是不同的（即不会共享物理分页）。  

尽管子进程会继承其父进程的映射，但写时复制语义确保在 fork()之后父进程和子进程不会看到其他进程对映射所做出的变更。  

私有匿名映射的主要用途是为一个进程分配新（用零填充）内存（如在分配大块内存时 malloc()会为此而使用 mmap()）。  

#### MAP_SHARED 共享匿名映射
共享匿名映射允许相关进程（如父进程和子进程）共享一块内存区域而无需一个对应的映射文件。  

与私有匿名映射一样，每次调用 mmap()创建一个共享匿名映射时都会产生一个新的、与任何其他映射不共享分页的截然不同的映射。  

这里的差别在于映射的分页不会被写时复制。这意味着当一个子进程在 fork()之后继承映射时，父进程和子进程共享同样的 RAM 分页，并且一个进程对映射内容所做出的变更会对其他进程可见。  

共享匿名映射允许以一种类似于 System V 共享内存段的方式来进行 IPC，但只有相关进程之间才能这么做。  

### 创建一个映射：mmap()
```C
#include<sys/mman.h>

void *mmap(void *addr,size_t length, int prot, int flags, int fd, off_t offset);
//addr 参数指定了映射被放置的虚拟地址。如果将 addr 指定为 NULL，那么内核会为映射选择一个合适的地址。这是创建映射的首选做法
//length 参数指定了映射的字节数
//prot 参数是一个位掩码，它指定了施加于映射之上的保护信息
//flags 参数是一个控制映射操作各个方面的选项的位掩码,这个掩码必须只包含下列值:MAP_PRIVATE、MAP_SHARED
//fd 参数是一个标识被映射的文件的文件描述符
//offset 参数指定了映射在文件中的起点，它必须是系统分页大小的倍数。要映射整个文件就需要将 offset 指定为 0 并且将 length 指定为文件大小
//成功时 mmap()会返回新映射的起始地址。发生错误时 mmap()会返回 MAP_FAILED
```
### 解除映射区域：munmap() 
```C
#include<sys/mman.h>

int munmap(void *addr,size_t length);
//addr 参数是待解除映射的地址范围的起始地址，它必须与一个分页边界对齐
//length 参数是一个非负整数，它指定了待解除映射区域的大小（字节数）。范围为系统分页大小的下一个倍数的地址空间将会被解除映射
```
当一个进程终止或执行了一个 exec()之后进程中所有的映射会自动被解除。  

为确保一个共享文件映射的内容会被写入到底层文件中，在使用 munmap()解除一个映射之前需要调用 msync()。  

### 重新映射一个映射区域：mremap()
在大多数 UNIX 实现上一旦映射被创建，其位置和大小就无法改变了。但 Linux 提供了（不可移植的）mremap()系统调用来执行此类变更。  
```C
#include<sys/mman.h>

void *mremap(void* old_address,size_t old_size,size_t new_size,int lfags,...);
```

###  同步映射区域：msync()  
内核会自动将发生在 MAP_SHARED 映射内容上的变更写入到底层文件中，但在默认情况下，内核不保证这种同步操作会在何时发生。 

msync()系统调用让应用程序能够显式地控制何时完成共享映射与映射文件之间的同步。  

同步一个映射与底层文件在多种情况下都是非常有用的。如，为确保数据完整性，一个数据库应用程序可能会调用 msync()强制将数据写入到磁盘上。调用 msync()还允许一个应用程序确保在可写入映射上发生的更新会对在该文件上执行 read()的其他进程可见。  

```C
#include<sys/mman.h>

int msync(void *addr,size_t length,int flags);
//传给 msync()的 addr 和 length 参数指定了需同步的内存区域的起始地址和大小。
//在 addr中指定的地址必须是分页对齐的，length 会被向上舍入到系统分页大小的下一个整数倍。
```


## Linux-Unix系统编程手册相关笔记

## 进程内存空间
每个进程所分配的内存由很多部分组成，通常称之为段（segment）。如下所示。

### 文本段（代码段）
文本段包含了进程运行的程序机器语言指令。  

文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。  

因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。

### 初始化数据段（data段、.data）
 
初始化数据段包含显式初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。

### 未初始化数据段（bss段、.bss）
 
未初始化数据段包含了未进行显式初始化的全局变量和静态变量。  

程序启动之前，系统将本段内所有内存初始化为 0。  

出于历史原因，此段常被称为 BSS 段，这源于老版本的汇编语言助记符“block started by symbol”。  

将经过初始化的全局变量和静态变量与未经初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。  

相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间。

### 栈
 
栈（stack）是一个动态增长和收缩的段，由栈帧（stack frames）组成。  

系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。

### 内存映射段
共享内存段被附加在向上增长的堆和向下增长的栈之间未被分配的空间中。  

为给堆和栈的增长腾出空间，附加共享内存段的虚拟地址从 0x40000000 开始。内存映射和共享也是被放置在这个区域中的。（共享内存映射和内存段默认被放置的位置可能会有些不同，这依赖于内核版本和进程的 RLIMIT_STACK 资源限制的设置。）  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/138.jpg" width = 60% height = 60% /></div>  

> 地址 0x40000000 被定义成了内核常量 TASK_UNMAPPED_BASE。通过将这个常量定义成一个不同的值并且重建内核可以修改这个地址的值。如果在调用 shmat()（或 mmap()）时采用了不推荐的方法，即显式地指定一个地址，那么一个共享内存段（或内存映射）可以被放置在低于 TASK_UNMAPPED_BASE 的地址处。  

通过 Linux 特有的/proc/PID/maps 文件能够看到一个程序映射的共享内存段和共享库的位置。  

> 从内核 2.6.14 开始，Linux 还提供了/proc/PID/smaps 文件，它给出了有关一个进程中各个映射的内存消耗方面的更多信息。  

### 堆
 
堆（heap）是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称作program break。  


对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）。

size(1)命令可显示二进制可执行文件的文本段、初始化数据段、非初始化数据段（bss）的段大小。


下图展示了各种内存段在 x86-32 体系结构中的布局，该图的顶部标记为 argv、environ的空间用来存储程序命令行实参（通过 C 语言中 main()函数的 argv 参数获得）和进程环境列表，图中十六进制的地址会因内核配置和程序链接选项差异而有所不同。图中标灰的区域表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表
（page table）  


<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/132.jpg" width = 60% height = 60% /></div>

## 虚拟内存管理
### 虚拟内存的局部性原理
Linux，像多数现代内核一样，采用了虚拟内存管理技术。该技术利用了大多数程序的一个典型特征，即访问局部性（locality of reference），以求高效使用 CPU 和 RAM（物理内存资源。大多数程序都展现了两种类型的局部性。  
 
- 空间局部性（Spatial locality）：是指程序倾向于访问在最近访问过的内存地址附近的内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。  
 - 时间局部性（Temporal locality）：是指程序倾向于在不久的将来再次访问最近刚访问过的内存地址（由于循环）。  

正是由于访问局部性特征，使得程序即便仅有部分地址空间存在于 RAM 中，依然可能得以执行。  

### 虚拟内存的原理
虚拟内存的规划之一是将每个程序使用的内存切割成小型的、固定大小的“页”（page）单元。  

相应地，将 RAM 划分成一系列与虚存页尺寸相同的页帧。任一时刻，每个程序仅有部分页需要驻留在物理内存页帧中。这些页构成了所谓驻留集（resident set）。  

程序未使用的页拷贝保存在交换区（swap area）内—这是磁盘空间中的保留区域，作为计算机 RAM 的补充—仅在需要时才会载入物理内存。  

若进程欲访问的页面目前并未驻留在物理内存中，将会发生页面错误（page fault），内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。

为支持这一组织方式，内核需要为每个进程维护一张页表（page table）。该页表描述了每页在进程虚拟地址空间（virtual address space）中的位置（可为进程所用的所有虚拟内存页面的集合）。  

页表中的每个条目要么指出一个虚拟页面在 RAM 中的所在位置，要么表明其当前驻留在磁盘上。  


在进程虚拟地址空间中，并非所有的地址范围都需要页表条目。通常情况下，由于可能存在大段的虚拟地址空间并未投入使用，故而也无必要为其维护相应的页表条目。若进程试图访问的地址并无页表条目与之对应，那么进程将收到一个 SIGSEGV 信号。  

### 进程虚拟地址空间的变化场景
由于内核能够为进程分配和释放页（和页表条目），所以进程的有效虚拟地址范围在其生命周期中可以发生变化。这可能会发生于如下场景。  

- 由于栈向下增长超出之前曾达到的位置。

- 当在堆中分配或释放内存时，通过调用 brk()、sbrk()或 malloc 函数族来提升 program break 的位置。
 
- 当调用 shmat()连接 System V 共享内存区时，或者当调用 shmdt()脱离共享内存区时。  

- 当调用 mmap()创建内存映射时，或者当调用 munmap()解除内存映射时。  

> 虚拟内存的实现需要硬件中分页内存管理单元（PMMU）的支持。PMMU 把要访问的每个虚拟内存地址转换成相应的物理内存地址，当特定虚拟内存地址所对应的页没有驻留于 RAM 中时，将以页面错误通知内核。  

### 虚拟内存管理的优点
虚拟内存管理使进程的虚拟地址空间与 RAM 物理地址空间隔离开来，这带来许多优点。  

- 进程与进程、进程与内核相互隔离，所以一个进程不能读取或修改另一进程或内核的内存。这是因为每个进程的页表条目指向 RAM（或交换区）中截然不同的物理页面集合。  
 
- 适当情况下，两个或者更多进程能够共享内存。这是由于内核可以使不同进程的页表条目指向相同的 RAM 页。内存共享常发生于如下两种场景。  
 
   – 执行同一程序的多个进程，可共享一份（只读的）程序代码副本。当多个程序执行相同的程序文件（或加载相同的共享库）时，会隐式地实现这一类型的共享。
 
   – 进程可以使用 shmget()和 mmap()系统调用显式地请求与其他进程共享内存区。这么做是出于进程间通信的目的。  

- 便于实现内存保护机制；也就是说，可以对页表条目进行标记，以表示相关页面内容是可读、可写、可执行亦或是这些保护措施的组合。多个进程共享 RAM 页面时，允许每个进程对内存采取不同的保护措施。例如，一个进程可能以只读方式访问某页面，而另一进程则以读写方式访问同一页面。  

 
- 程序员和编译器、链接器之类的工具无需关注程序在 RAM 中的物理布局。  
 
- 因为需要驻留在内存中的仅是程序的一部分，所以程序的加载和运行都很快。而且，一个进程所占用的内存（即虚拟内存大小）能够超出 RAM 容量。  

- 由于每个进程使用的 RAM 减少了，RAM 中同时可以容纳的进程数量就增多了。这增大了如下事件的概率：在任一时刻，CPU 都可执行至少一个进程，因而往往也会提高 CPU 的利用率。  

## 栈和栈帧

函数的调用和返回使栈的增长和收缩呈线性。X86-32 体系架构之上的 Linux（和多数其他 Linux 和 UNIX 实现），栈驻留在内存的高端并向下增长（朝堆的方向）。  

专用寄存器—栈指针（stack pointer），用于跟踪当前栈顶。每次调用函数时，会在栈上新分配一帧，每当函数返回时，再从栈上将此帧移去。  

### 栈的增长

虽然栈向下增长，但仍将栈的增长端称为栈顶，因为抽象地说来，情况本就如此。栈的实际增长方向是个（属于硬件范畴的）实现细节。  

在 HP PA-RISC 的 Linux 实现中，栈的增长方向就是向上的。  

就虚拟内存而言，分配栈帧后，栈段的大小将会增长，但在大多数（Linux）实现中，释放这些栈帧后，栈的大小并未减少（在分配新的栈帧时，会对这些内存重新加以利用）。当谈论栈段的增长和收缩时，只是从逻辑视角来看待栈帧在栈中的增减情况。  

### 用户栈与内核栈

有时，会用用户栈（user stack）来表示此处所讨论的栈，以便与内核栈区分开来。  

内核栈是每个进程保留在内核内存中的内存区域，在执行系统调用的过程中供（内核）内部函数调用使用。（由于用户栈驻留在不受保护的用户内存中，所以内核无法利用用户栈来达成这一目的。）  

### 用户栈栈帧存储的内容
每个（用户）栈帧包括如下信息。

#### 函数实参和局部变量
由于这些变量都是在调用函数时自动创建的，因此在 C 语言中称其为自动变量。函数返回时将自动销毁这些变量（因为栈帧会被释放），这也是自
动变量与静态（以及全局）变量主要的语义区别：后者与函数执行无关，且长期存在。  

#### （函数）调用的链接信息
 
每个函数都会用到一些 CPU 寄存器，比如程序计数器，其指向下一条将要执行的机器语言指令。每当一函数调用另一函数时，会在被调用函数的栈帧中保存这些寄存器的副本，以便函数返回时能为函数调用者将寄存器恢复原状。  


因为函数能够嵌套调用，所以栈中可能有多个栈帧。（若一函数递归调用自身，则该函数在栈中将有多个栈帧。）  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/133.jpg" width = 60% height = 60% /></div>

## 内存分配
### 在堆上分配内存

进程可以通过增加堆的大小来分配内存，所谓堆是一段长度可变的连续虚拟内存，始于进程的未初始化数据段末尾，随着内存的分配和释放而增减。 
 

通常将堆的当前内存边界称为“program break”。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/134.jpg" width = 60% height = 60% /></div>  


####  调整program break：brk()和 sbrk()

改变堆的大小（即分配或释放内存），其实就像命令内核改变进程的 program break 位置一样简单。最初，program break 正好位于未初始化数据段末尾之后。  

在 program break 的位置抬升后，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配。内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页。  


传统的 UNIX 系统提供了两个操纵 program break 的系统调用：brk()和 sbrk()，在 Linux 中依然可用。虽然代码中很少直接使用这些系统调用，但了解它们有助于弄清内存分配的工作过程。  

```C
#include<unistd.h>

//系统调用 brk()会将 program break 设置为参数 end_data_segment 所指定的位置。
//由于虚拟内存以页为单位进行分配，end_data_segment 实际会四舍五入到下一个内存页的边界处。

//当试图将 program break 设置为一个低于其初始值的位置时，有可能会导致无法预知的行为，
//例如，当程序试图访问的数据位于初始化或未初始化数据段中当前尚不存在的部分时，就会引发分段内存访问错误（segmentation fault）//
//（SIGSEGV 信号）。program break 可以设定的精确上限取决于一系列因素，
//这包括进程中对数据段大小的资源限制（36.3 节中描述的 RLIMIT_DATA），以及内存映射、共享内存段、共享库的位置。

int brk(void* end_data_segment);  //return 0 on seccess,or -1 on error

//调用 sbrk()将 program break 在原有地址上增加从参数 increment 传入的大小。
//在 Linux 中，sbrk()是在 brk()基础上实现的一个库函数。
//用于声明 increment 的 intptr_t 类型属于整数数据类型。
//若调用成功，sbrk()返回前一个 program break 的地址。
//换言之，如果 program break 增加，那么返回值是指向这块新分配内存起始位置的指针。
//调用 sbrk(0)将返回 program break 的当前位置，对其不做改变。
//在意图跟踪堆的大小，或是监视内存分配函数包的行为时，可能会用到这一用法。

void *sbrk(intptr_t increment);  //return previous program break on seccess, or (void *)-1 on error
```

#### 在堆上分配内存：malloc()和 free()
**malloc()**  

一般情况下，C 程序使用 malloc 函数族在堆上分配和释放内存。较之 brk()和 sbrk()，这些函数具备不少优点，如下所示。  
 
- 属于 C 语言标准的一部分。
- 更易于在多线程程序中使用。 
- 接口简单，允许分配小块内存。 
- 允许随意释放内存块，它们被维护于一张空闲内存列表中，在后续内存分配调用时循环使用。  

```C
#include<stdio.h>

//malloc( )函数在堆上分配参数 size 字节大小的内存，并返回指向新分配内存起始位置处的指针，其所分配的内存未经初始化。

void *malloc(size_t size);  //return pointer to allocated memory on success, or NULL on error
```

由于 malloc()的返回类型为 void*，因而可以将其赋给任意类型的 C 指针。malloc()返回内存块所采用的字节对齐方式，总是适宜于高效访问任何类型的 C 语言数据结构。  

在大多数硬件架构上，这实际意味着 malloc 是基于 8 字节或 16 字节边界来分配内存的。  

若无法分配内存（或许是因为已经抵达 program break 所能达到的地址上限），则 malloc()返回 NULL，并设置 errno 以返回错误信息。  

虽然分配内存失败的可能性很小，但所有对 malloc()以及后续提及的相关函数的调用都应对返回值进行错误检查。  

**free()**    

```C
#include<stdio.h>

//free()函数释放 ptr 参数所指向的内存块，该参数应该是之前由 malloc()，或者后续描述的其他堆内存分配函数之一所返回的地址。

void free(void *ptr);
```

一般情况下，free()并不降低 program break 的位置，而是将这块内存填加到空闲内存列表中，供后续的 malloc()函数循环使用。这么做是出于以下几个原因。  

- 被释放的内存块通常会位于堆的中间，而非堆的顶部，因而降低 porgram break 是不可能的。
 
- 它最大限度地减少了程序必须执行的 sbrk()调用次数。（系统调用的开销虽小，却也颇为可观。）

- 在大多数情况下，降低 program break 的位置不会对那些分配大量内存的程序有多少帮助，因为它们通常倾向于持有已分配内存或是反复释放和重新分配内存，而非释放所有内存后再持续运行一段时间。  


如果传给 free()的是一个空指针，那么函数将什么都不做。（换句话说，给 free()传入一个空指针并不是错误代码。）  


在调用 free()后对参数 ptr 的任何使用，例如将其再次传递给 free()，将产生错误，并可能导致不可预知的结果。  

**free在什么情况下会降低program break的地址**  

在堆顶部释放完整的一组连续内存块，会观察到 program break 从峰值上降下来，这表明 free()使用了 sbrk()来降低 program break。  

在这种情况下，free()函数的 glibc 实现会在释放内存时将相邻的空闲内存块合并为一整块更大的内存（这样做是为了避免在空闲内存列表中包含大量的小块内存碎片，这些碎片会因空间太小而难以满足后续的 malloc()请求），因而也有能力识别出堆顶部的整个空闲区域。  

仅当堆顶空闲内存“足够”大的时候，free()函数的 glibc 实现会调用 sbrk()来降低 programbreak 的地址，至于“足够”与否则取决于 malloc 函数包行为的控制参数（128 KB 为典型值）。这减少了必须对 sbrk()发起的调用次数（亦即对 brk()系统调用的调用次数）。  


#### malloc()和 free()的实现
**malloc的实现**  

malloc()的实现很简单。  

它首先会扫描之前由 free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存。（取决于具体实现，采用的扫描策略会有所不同。例如，first-fit 或 best-fito。）  

如果这一内存块的尺寸正好与要求相当，就把它直接返回给调用者。如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中。  


如果在空闲内存列表中根本找不到足够大的空闲内存块，那么 malloc()会调用 sbrk()以分配更多的内存。为减少对 sbrk()的调用次数，malloc()并未只是严格按所需字节数来分配内存，而是以更大幅度（以虚拟内存页大小的数倍）来增加 program break，并将超出部分置于空闲内存列表。  

**free的实现**   

当 free()将内存块置于空闲列表之上时，是如何知晓内存块大小的？这是通过一个小技巧来实现的。  

当 malloc()分配内存块时，会额外分配几个字节来存放记录这块内存大小的整数值。该整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于这一长度记录字节之后，如图所示。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/135.jpg" width = 60% height = 60% /></div>   

当将内存块置于空闲内存列表（双向链表）时，free()会使用内存块本身的空间来存放链表指针，将自身添加到列表中，如图所示。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/136.jpg" width = 60% height = 60% /></div>   

随着对内存不断地释放和重新分配，空闲列表中的空闲内存会和已分配的在用内存混杂在一起，如图所示。  

<div align=center><img src="https://github.com/KyelYang/c-plus-Interview-data/blob/master/02-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/03-Unix_Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/02-image/137.jpg" width = 60% height = 60% /></div>   


应该认识到，C 语言允许程序创建指向堆中任意位置的指针，并修改其指向的数据，包括由 free()和 malloc()函数维护的内存块长度、指向前一空闲块和后一空闲块的指针。辅之以之前的描述，一旦推究起隐晦难解的编程缺陷来，这无疑形同掉进了火药桶。  

例如，假设经由一个错误指针，程序无意间增加了冠于一块已分配内存的长度值，并随即释放这块内存，free()因之会在空闲列表中记录下这块长度失真的内存。随后，malloc()也许会重新分配这块内存，从而导致如下场景：程序的两个指针分别指向两块它认为互不相干的已分配内存，但实际上这两块内存却相互重叠。至于其他的出错情况则数不胜数。  


#### 在堆上分配内存的其他方法
除了 malloc()，C 函数库还提供了一系列在堆上分配内存的其他函数。  

**用 calloc()和 realloc()分配内存**  

函数 calloc()用于给一组相同对象分配内存。  

```C
#include<stdlib.h>

//参数 mumitems 指定分配对象的数量，size 指定每个对象的大小。
//在分配了适当大小的内存块后，calloc()返回指向这块内存起始处的指针（如果无法分配内存，则返回 NULL）。
//与 malloc()不同，calloc()会将已分配的内存初始化为 0。

void *calloc(size_t numitems, size_t size);  //return pointer to allocated memory on success,or NULL on error

//下面是 calloc()的一个使用范例：

struct {...} myStruct;
struct myStruct *p;

p = calloc(1000,sizeof(struct myStruct));
if(p == NULL) errExit("calloc");
```

realloc()函数用来调整（通常是增加）一块内存的大小，而此块内存应是之前由 malloc 包中函数所分配的。  

```C
#include<stdlib.h>

//参数 ptr 是指向需要调整大小的内存块的指针。参数 size 指定所需调整大小的期望值。
void *realloc(void *ptr, size_t size);  //return pointer to allocated memory on success,or NULL on error
```

如果成功，realloc()返回指向大小调整后内存块的指针。与调用前的指针相比，二者指向的位置可能不同。  

如果发生错误，realloc()返回 NULL，对 ptr 指针指向的内存块则原封不动。  

若 realloc()增加了已分配内存块的大小，则不会对额外分配的字节进行初始化。  

使用 calloc()或 realloc()分配的内存应使用 free()来释放。  

通常情况下，当增大已分配内存时，realloc()会试图去合并在空闲列表中紧随其后且大小满足要求的内存块。  

若原内存块位于堆的顶部，那么 realloc()将对堆空间进行扩展。  


如果这块内存位于堆的中部，且紧邻其后的空闲内存空间大小不足，realloc()会分配一块新内存，并将原有数据复制到新内存块中。  

最后这种情况最为常见，还会占用大量 CPU资源。一般情况下，应尽量避免调用 realloc()。  


既然 realloc()可能会移动内存，对这块内存的后续引用就必须使用 realloc()的返回指针。可以用 realloc()来重新定位由变量 ptr 指向的内存块。  

由于 realloc()可能会移动内存块，任何指向该内存块内部的指针在调用 realloc()之后都可能不再可用。仅有一种内存块内的位置引用方法依然有效，即以指向此块内存起始处的指针再加上一个偏移量来进行定位。  


**分配对齐的内存：memalign()和 posix_memalign()**    

详见书P150。  


### 在堆栈上分配内存：alloca()   

和 malloc 函数包中的函数功能一样，alloca()也可以动态分配内存，不过不是从堆上分配内存，而是通过增加栈帧的大小从堆栈上分配。  

根据定义，当前调用函数的栈帧位于堆栈的顶部，故而这种方法是可行的。因此，帧的上方存在扩展空间，只需修改堆栈指针值即可。  

```C
#include<alloca.h>

//参数 size 指定在堆栈上分配的字节数。函数 alloca()将指向已分配内存块的指针作为其返回值。
void *alloca(size_t size);  //return pointer to allocated block of memory
```
不需要（实际上也绝不能）调用 free()来释放由 alloca()分配的内存。同样，也不可能调用realloc()来调整由 alloca()分配的内存大小。  

若调用alloca()造成堆栈溢出，则程序的行为无法预知，特别是在没有收到一个NULL 返回值通知错误的情况下。（事实上，在此情况下，可能会收到一个SIGSEGV 信号）。  

#### 使用alloca()的优势  
- alloca()分配内存的速度要快于 malloc()，因为编译器将 alloca()作为内联代码处理，并通过直接调整堆栈指针来实
现。  
- alloca()也不需要维护空闲内存块列表。  
- 由 alloca()分配的内存随栈帧的移除而自动释放，亦即当调用 alloca 的函数返回之时。之所以如此，是因为函数返回时所执行的代码会重置栈指针寄存器，使其指向前一帧的末尾（即，假设堆栈向下增长，则指向恰好位于当前栈帧起始处之上的地址）。由于在函数的所有返回路径中都无需确保去释放所有的已分配内存，一些函数的编码也变得简单得多。


## 内存管理
### linux内存管理的方式
- [浅谈Linux内存管理](https://zhuanlan.zhihu.com/p/67059173)
- [深入理解Linux内存管理机制（一）](http://jm.taobao.org/2012/07/31/linux-memory-manage-1/)
- [linux内存管理概述](https://blog.csdn.net/bullbat/article/details/7166140?spm=a2c6h.12873639.0.0.43da312cUyuAOj)
- Linux内存管理笔记[](http://niliu.me/articles/2122.html)
- [Linux内存管理（最透彻的一篇）](https://blog.csdn.net/hustyangju/article/details/46330259)
- [Linux内存管理](http://gityuan.com/2015/10/30/kernel-memory/)
- [别再说你不懂Linux内存管理了，10张图给你安排的明明白白！](http://news.eeworld.com.cn/mp/rrgeek/a88088.jspx)
### 内存管理的概念
虽然计算机硬件一直在飞速发展，内存容量也在不断增长，但是仍然不可能将所有的用户进程和系统所需要的全部程序和数据放主存中，所以操作系统必须将内存空间进行合理划分和有效地动态分配。  

操作系统对内存的划分和动态分配，就是内存管理的概念。  

- C++ stl 的内存管理是怎么做的？
- Linux内存管理方法，页面置换算法，逻辑地址和物理地址的转换
- 面试官问我C++内存管理有什么办法，而我在两小时前的网易雷火面试中被问智能指针，以前只看过一遍，当时就没答上来，在两次面试间隔恶补了一下，所以我故意回答智能指针，果不其然，他让我手动实现share_ptr，我三下五除二就写完了（一小时前才看过代码）。

## 内存泄露的检测与解决
- 内存泄露
- 除了开辟堆空间没有释放导致内存泄露还有没有其他的可能性？（答得指针指向其他的地方之前没有释放，面试官好像不是很满意）
- 写代码的时候有什么办法避免内存泄漏？
- delete 删除数组为什么会造成内存泄露？只调用一次析构函数
- delete\[]怎么知道要调用多少次析构函数？讲了object的内存格式
- 怎么检查内存泄漏  讲了 valgrind

## 虚拟内存与物理内存
###  虚拟内存机制的作用
可以从逻辑上扩充内存。  

### 物理内存与虚拟内存的区别
#### 物理内存=运行内存
就是指计算机的安装内存“通俗的讲就是内存条的大小”。  

#### 虚拟内存
虚拟内存指的是把硬盘中的一部分空间用来当做内存使用。  

之所以成为虚拟存储器，是因为这种存储器实际不存在，只是由于系统提供了部分装入、请求调用和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大的多的存储器。  

#### 虚拟内存的作用
是为了解决计算机在运行较大的程序时内存不足的情况。  

其实在内存足够大的时候 虚拟内存存在的意义就不是很大了。另外由于虚拟内存是在硬盘上的，它的速度要比内存慢的多，虚拟内存其实就是为了运行很大的程序的一种妥协的办法，妥协了软件的运行速度。  

### 虚拟内存的置换算法
- 最佳置换算法（OPT）
- 先进先出（FIFO）页面置换算法
- 最近最久未使用（LRU）置换算法
- 时钟（CLOCK）置换算法
   - 简单时钟（CLOCK）置换算法（又称为最近未用NRU算法）
   - 改进型时钟（CLOCK）置换算法
   
具体内容见王道P176


### 讲讲虚拟内存，和物理内存怎么映射

#### 请求分页中的地址变换过程
王道P176
#### 虚实地址变换过程的实例
- 根据虚拟内存地址查找TLB（高速缓存），查看TLB中该虚拟地址的有效位是否为1，即是否缓存该虚拟地址对应的页面
- 如果有效位为1，说明缓存了该虚拟地址对应的页面，此时去data cache中查看该缓存页面的具体内容
- 如果有效位为0，此时需要去内存中查找该页面，查看内存页表中该页面对应的有效位是否为1
   - 如果为1，说明该页面在内存中，直接根据页面对应的页表物理地址+页内偏移计算出实际物理地址，访问物理地址上的数据
   - 如果为0，说明该页面不在内存中，产生缺页中断

#### 地址映射的简单过程
- 通过虚拟地址找到对应的页表项，页表项中有该页表的物理地址
- 通过上述物理地址 + 虚拟地址中的页内偏移 = 实际物理地址

具体内容见王道P181

## 共享内存
- 问共享内存的底层实现，我蒙mmap，问mmap在系统级怎么实现，我说虚拟内存到物理内存的映射， 问如何实现这个映射到实际使用，我说通过缺页中断
- 怎么共享内存(我不会cpp，但csapp上说mmap我就答的mmap)
- mmap有哪些应用（malloc分配内存，以及epoll往内核注册事件，这里回答上来了）

## 内存对齐
### 为什么要做内存对齐？
- 减少CPU访问内存的次数
- 增加可移植性

CPU访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如32位的CPU，字长为4字节，那么CPU访问内存的单位也是4字节。  

这么设计的目的，是减少CPU访问内存的次数，加大CPU访问内存的吞吐量。  

- [为什么要内存对齐](https://www.pengrl.com/p/20020/)
- [内存对齐规则之我见](https://levphy.github.io/2017/03/23/memory-alignment.html)
- [如何理解 struct 的内存对齐？](https://www.zhihu.com/question/27862634)
### 如何申请内存使得内存的首地址是16字节对齐？
- [使用gcc中的__attribute__指定字节对齐](https://blog.csdn.net/czg13548930186/article/details/78800859)

## 其他问题
- 宏定义和枚举的区别（枚举分不分配内存）
- 出现内存错误，可以通过反编译查出来吗？
- 内存有哪些技术（开放回答，交换技术与虚拟内存，重点讲虚拟内存、页面页框页表、缓存淘汰的策略一般是LRU）
- 内存外存知道吗（？）内存碎片知道吗，怎么产生的（回答中提到了stl allocator和系统调用ptmalloc的二级分配器）内存池是如何管理的？现在做一道编程题，自己实现一个内存池，要求对外两个接口申请和归还内存，必须要可以实际运行。（写了一会，说空闲链表我实现不好，归还逻辑没写）面试官笑了，那你背答案有什么用，原理说的挺好怎么写不出来呢？我考察的是你的编码能力和编码习惯。

### 主存、辅存、内存、外存、存储器是什么？
- [主存、辅存、内存、外存、存储器是什么？还傻傻分不清楚？看完这一篇就够了](https://zhuanlan.zhihu.com/p/113869761)

### 可重入程序
可重入程序主要是通过共享来使用同一块存储空间的，或者通过动态链接的方式将所需的程序段映射到相关进程中去，其最大的优点是减少了对程序段的调入/调出，因此减少了交换次数。  
