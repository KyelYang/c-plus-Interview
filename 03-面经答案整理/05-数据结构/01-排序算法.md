# 面试问题
- 排序算法比较，复杂度，稳定性等
- 排序算法了解哪个？时间复杂度？
- 归并排序的细节，复杂度
- 快排思想，复杂度
- 快排和堆排对比
- 各种排序算法的平均时间复杂度和最坏情况下的时间复杂度？

## 各种排序算法细节，复杂度，稳定性
### [基础排序算法](https://github.com/KyelYang/c-plus-Interview-data/blob/master/01-%E7%AE%97%E6%B3%95%E9%A2%98%E7%AC%94%E8%AE%B0/02-basic_sort_algorithm/README.md)  

## 内部排序算法的比较
### 从时间复杂度来看
- 简单选择排序、插入排序、和冒泡排序的平均情况下的时间复杂度都为O(N^2)，并且实现过程比较简单，但插入排序和冒泡排序在最好情况下时间复杂度可以达到O(N)，而简单选择排序则与序列的初始状态无关。  

- 希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但是目前未得出其精确的渐近时间。  

- 堆排序是利用了一种称为堆的数据结构，可以在线性时间O(N)内完成建堆，并且在O(NlogN)内完成排序过程。  

- 快排是基于分治的思想，虽然最快情况下时间复杂度会达到O(N^2)，但快排平均性能可以达到O(NlogN)，在实际应用中常常优于其他排序算法。  

- 归并排序同样是基于分治的思想，但由于其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均时间复杂度均为O(NlogN)。  

### 从空间复杂度来看
- 简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需要借助常数个O(1)辅助空间。

- 快排在空间上只使用一个小的辅助栈，用于实现递归，平均情况下大小为O(NlogN)，当然在最快情况下空间复杂度会增长到O(N)。  

- （二路）归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为O(N)。虽然有方法可以克服这个缺点，但是其代价是算法会变得更复杂，而且时间复杂度会相应增加。

### 从稳定性来看
- 稳定的排序算法：插入排序、冒泡排序、归并排序和基数排序
- 不稳定的排序算法：简单选择排序、快排、希尔排序和堆排序  

### 从过程特征来看
- 冒泡排序和堆排序在每次循环后都能产生当前的最大值和最小值
- 快速排序依次循环就确定一个元素的最终位置
- ...

### 如何选择排序算法
#### 通常情况下，对排序算法的比较和应用应考虑以下因素
- 待排序的元素个数N
- 元素本身信息量的大小
- 关键字的结构及其分布情况
- 稳定性要求
- 语言工具的条件，存储结构及辅助空间大小等

#### 如何选择
- 若N较小（N <= 50），则可以采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动操作较简单选择排序多，因而当记录本身信息量较大时，用简单选择排序较好。
- 若文件的初始状态已按照关键字基本有序，则选择直接插入排序或冒泡排序为宜。  
- 若N较大，则应采用时间复杂度为O(NlogN)的排序算法：快排、堆排序或归并排序。
  - 快排被认为是目前基于比较的内部排序法中最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短。
  - 堆排序所需的辅助空间少于快速排序，并且不会出现快排可能出现的最坏情况，这两种排序是不稳定的。
  - 若要求排序稳定且时间复杂度为O(NlogN)，则可以选用归并排序。
- 在基于比较的排序算法中，每次比较两个关键字的大小后，仅仅出现两种可能的转移，因此可以用一棵二叉树来描述比较判定的过程，由此可以证明，当文件的N个关键字随机分布时，任何借助于“比较”的排序算法，至少需要O(NlogN)的时间。  
- 若N很大，记录的关键字位数较少且可以分解时，采用基数排序较好。  
- 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。  

## 相关链接
- [十大经典排序算法](https://www.cnblogs.com/onepixel/p/7674659.html)
- [排序算法比较](https://troywu0.gitbooks.io/spark/content/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.html)
- [经典排序算法](https://www.cnblogs.com/kkun/archive/2011/11/23/2260312.html)——这个代码写的一般，看看执行过程即可


## 6月新的面试问题总结
## 快排
### 快速排序什么情况下复杂度退化
一般的快速排序是不稳定的，其时间复杂度为 O(NlogN)，其中n是所排序序列的大小。  

但是在选取的基准值为所排序序列的最值时其时间复杂度会退化成O(N^2)。比如如下情况：  

- 数组已经是正序排过序的
- 数组已经是倒序排过序的
- 所有的元素都相同

因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中间、最后一个元素的**中值**作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。  

### 有没有比快速排序还快的排序方法（需要再深入了解一下）
快速排序(Quick Sort)是目前应用最广泛的排序算法，因其时间复杂度低和内循环较小，而且不需要太多的额外空间，广泛应用于工业界。比如JDK源码中的排序算法就是使用的快速排序。  

虽然快速排序应用广泛，但其最优时间复杂度仍为O(NlogN)，不是O(n)。  

我们把时间复杂度为O(n)的排序算法叫做线性排序，常见的线性排序算法有:桶排序、计数排序、基数排序。这几种算法之所以能做到线性时间内完成排序，是因为其不是基于比较的排序算法。

### 为什么基于比较的排序时间复杂度上线为O(NlogN)
- [排序算法--基于比较vs线性排序](http://wfwei.github.io/posts/sort/)
### 为什么堆排比快排慢 and 从信息论的角度来看排序
- [数学之美番外篇：快排为什么那样快](http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/)
